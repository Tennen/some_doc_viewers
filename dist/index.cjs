"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    "use strict";
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    "use strict";
    module2.exports = __require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    "use strict";
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = __require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    "use strict";
    try {
      util = __require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = __require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    "use strict";
    module2.exports = __require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_5) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = __require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    "use strict";
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "node_modules/jszip/lib/support.js"(exports2) {
    "use strict";
    exports2.base64 = true;
    exports2.array = true;
    exports2.string = true;
    exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports2.nodebuffer = typeof Buffer !== "undefined";
    exports2.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports2.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports2.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports2.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports2.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports2.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports2.nodestream = false;
    }
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/jszip/lib/base64.js"(exports2) {
    "use strict";
    var utils2 = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports2.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils2.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports2.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "node_modules/jszip/lib/nodejsUtils.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size) {
        if (Buffer.alloc) {
          return Buffer.alloc(size);
        } else {
          var buf = new Buffer(size);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  }
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "node_modules/immediate/lib/index.js"(exports2, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/lie/lib/index.js"(exports2, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject2);
      function resolve2(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject2(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result = tryCatch(getThen, value);
      if (result.status === "error") {
        return handlers.reject(self2, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result = tryCatch(tryToUnwrap);
      if (result.status === "error") {
        onError(result.value);
      }
    }
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise2.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "node_modules/jszip/lib/external.js"(exports2, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/setimmediate/setImmediate.js"(exports2) {
    "use strict";
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
  }
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "node_modules/jszip/lib/utils.js"(exports2) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports2.newBlob = function(part, type) {
      exports2.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports2.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports2.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports2.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports2.checkSupport(outputType);
      var inputType = exports2.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports2.resolve = function(path) {
      var parts = path.split("/");
      var result = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports2.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports2.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports2.MAX_VALUE_16BITS = 65535;
    exports2.MAX_VALUE_32BITS = -1;
    exports2.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports2.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports2.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports2.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports2.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports2.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "node_modules/jszip/lib/stream/GenericWorker.js"(exports2, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk) {
        this.emit("data", chunk);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk) {
        this.push(chunk);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/jszip/lib/utf8.js"(exports2) {
    "use strict";
    var utils2 = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils2.applyFromCharCode(utf16buf);
    };
    exports2.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports2.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils2.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils2.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils2.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils2.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports2.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports2.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports2.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils2.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports2.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports2.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "node_modules/jszip/lib/stream/ConvertWorker.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils2 = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils2.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: utils2.transformTo(this.destType, chunk.data),
        meta: chunk.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils2 = require_utils();
    utils2.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "node_modules/jszip/lib/stream/StreamHelper.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils2.newBlob(utils2.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils2.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject(err);
        }).on("end", function() {
          try {
            var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils2.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk) {
            fn.call(self2, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils2.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils2.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils2.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/jszip/lib/defaults.js"(exports2) {
    "use strict";
    exports2.base64 = false;
    exports2.binary = false;
    exports2.dir = false;
    exports2.createFolders = true;
    exports2.date = null;
    exports2.compression = null;
    exports2.compressionOptions = null;
    exports2.comment = null;
    exports2.unixPermissions = null;
    exports2.dosPermissions = null;
  }
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "node_modules/jszip/lib/stream/DataWorker.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils2.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils2.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils2.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils2.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/jszip/lib/crc32.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils2.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "node_modules/jszip/lib/stream/Crc32Probe.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils2 = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils2.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk) {
      this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
      this.push(chunk);
    };
    module2.exports = Crc32Probe;
  }
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "node_modules/jszip/lib/stream/DataLengthProbe.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils2.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk) {
      if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk);
    };
    module2.exports = DataLengthProbe;
  }
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/jszip/lib/compressedObject.js"(exports2, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/jszip/lib/zipObject.js"(exports2, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result = new GenericWorker("error");
          result.error(e);
        }
        return new StreamHelper(result, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils2 = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils2 = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS + 1);
      this.heap = new utils2.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils2.Buf8(s.w_size * 2);
      s.head = new utils2.Buf16(s.hash_size);
      s.prev = new utils2.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils2.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils2.Buf8(s.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils2 = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils2.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils2.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils2.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils2.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils2 = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils2.Buf16(MAXBITS + 1);
      var offs = new utils2.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils2 = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils2.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils2.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils2.Buf32(512);
        distfix = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils2.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils2.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils2.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils2.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils2.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils2 = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils2.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils2.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "node_modules/jszip/lib/flate.js"(exports2) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports2.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils2.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk) {
      this.meta = chunk.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils2.transformTo(ARRAY_TYPE, chunk.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports2.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports2.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "node_modules/jszip/lib/compressions.js"(exports2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports2.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports2.DEFLATE = require_flate();
  }
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "node_modules/jszip/lib/signature.js"(exports2) {
    "use strict";
    exports2.LOCAL_FILE_HEADER = "PK";
    exports2.CENTRAL_FILE_HEADER = "PK";
    exports2.CENTRAL_DIRECTORY_END = "PK";
    exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports2.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "node_modules/jszip/lib/generate/ZipFileWorker.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils2.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils2.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils2.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils2.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils2.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils2.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk) {
      var currentFilePercent = chunk.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk);
      } else {
        this.bytesWritten += chunk.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "node_modules/jszip/lib/generate/index.js"(exports2) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports2.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils2.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk) {
        self2.push({
          data: chunk,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "node_modules/jszip/lib/object.js"(exports2, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils2 = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name, data, originalOptions) {
      var dataType = utils2.getTypeOf(data), parent;
      var o = utils2.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils2.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object;
    };
    var parentFolder = function(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils2.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils2.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "node_modules/jszip/lib/reader/DataReader.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size) {
        var result = 0, i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size) {
        return utils2.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/ArrayReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils2 = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils2.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = ArrayReader;
  }
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "node_modules/jszip/lib/reader/StringReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils2 = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils2.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = StringReader;
  }
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports2, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils2 = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils2.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "node_modules/jszip/lib/reader/NodeBufferReader.js"(exports2, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils2 = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils2.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = NodeBufferReader;
  }
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "node_modules/jszip/lib/reader/readerFor.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils2.getTypeOf(data);
      utils2.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils2.transformTo("uint8array", data));
      }
      return new ArrayReader(utils2.transformTo("array", data));
    };
  }
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/jszip/lib/zipEntry.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils2 = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils2.pretty(this.compressionMethod) + " unknown (inner file : " + utils2.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils2.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils2.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils2.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils2.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils2.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils2.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/jszip/lib/zipEntries.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils2 = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils2.pretty(signature) + ", expected " + utils2.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils2.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils2.MAX_VALUE_16BITS || this.centralDirRecords === utils2.MAX_VALUE_16BITS || this.centralDirSize === utils2.MAX_VALUE_32BITS || this.centralDirOffset === utils2.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "node_modules/jszip/lib/load.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip = this;
      options = utils2.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils2.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils2.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      });
    };
  }
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jszip/lib/index.js"(exports2, module2) {
    "use strict";
    function JSZip2() {
      if (!(this instanceof JSZip2)) {
        return new JSZip2();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip2();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip2.prototype = require_object();
    JSZip2.prototype.loadAsync = require_load();
    JSZip2.support = require_support();
    JSZip2.defaults = require_defaults();
    JSZip2.version = "3.10.1";
    JSZip2.loadAsync = function(content, options) {
      return new JSZip2().loadAsync(content, options);
    };
    JSZip2.external = require_external();
    module2.exports = JSZip2;
  }
});

// src/components/PDFPreview.tsx
var _react = require('react');
var _reactpdf = require('react-pdf');
require('react-pdf/dist/esm/Page/TextLayer.css');
var _jsxruntime = require('react/jsx-runtime');
_reactpdf.pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${_reactpdf.pdfjs.version}/build/pdf.worker.min.mjs`;
var PDFPreview = ({ fileUrl }) => {
  const [pageNumber, setPageNumber] = _react.useState.call(void 0, 1);
  function onDocumentLoadSuccess({ numPages }) {
    setPageNumber(numPages);
  }
  return _jsxruntime.jsx.call(void 0, "div", { className: "pdf-preview", children: _jsxruntime.jsx.call(void 0, _reactpdf.Document, { file: fileUrl, onLoadSuccess: onDocumentLoadSuccess, children: Array.from({ length: pageNumber }, (_5, index) => _jsxruntime.jsx.call(void 0, _reactpdf.Page, { pageNumber: index + 1, renderTextLayer: false, scale: 1.5 }, index)) }) });
};
var PDFPreview_default = PDFPreview;

// src/components/XLSXPreview.tsx

var _xlsx = require('xlsx'); var XLSX = _interopRequireWildcard(_xlsx);

var XLSXPreview = ({ fileUrl }) => {
  const [data, setData] = _react.useState.call(void 0, []);
  _react.useEffect.call(void 0, () => {
    const fetchData = () => __async(void 0, null, function* () {
      const response = yield fetch(fileUrl);
      const arrayBuffer = yield response.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: "array" });
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      setData(jsonData);
    });
    fetchData();
  }, [fileUrl]);
  return _jsxruntime.jsx.call(void 0, "div", { className: "xlsx-preview", children: _jsxruntime.jsx.call(void 0, "table", { children: _jsxruntime.jsx.call(void 0, "tbody", { children: data.map((row, rowIndex) => _jsxruntime.jsx.call(void 0, "tr", { children: row.map((cell, cellIndex) => _jsxruntime.jsx.call(void 0, "td", { children: cell }, cellIndex)) }, rowIndex)) }) }) });
};
var XLSXPreview_default = XLSXPreview;

// src/components/DOCXPreview.tsx

var _mammoth = require('mammoth'); var _mammoth2 = _interopRequireDefault(_mammoth);

var DOCXPreview = ({ fileUrl }) => {
  const [content, setContent] = _react.useState.call(void 0, "");
  _react.useEffect.call(void 0, () => {
    const fetchData = () => __async(void 0, null, function* () {
      const response = yield fetch(fileUrl);
      const arrayBuffer = yield response.arrayBuffer();
      const result = yield _mammoth2.default.convertToHtml({ arrayBuffer });
      setContent(result.value);
    });
    fetchData();
  }, [fileUrl]);
  return _jsxruntime.jsx.call(void 0, "div", { className: "docx-preview", dangerouslySetInnerHTML: { __html: content } });
};
var DOCXPreview_default = DOCXPreview;

// src/components/PPTXPreview.tsx


// src/helpers/pptx/usePPTX.tsx


// src/helpers/pptx/PPTX.ts
var _lodash = require('lodash'); var _2 = _interopRequireWildcard(_lodash);

// src/helpers/pptx/utils/numeric.ts
var archaicNumbers = (arr) => {
  const arrParse = arr.slice().sort((a, b) => b[1].length - a[1].length);
  return {
    format: (n) => {
      let ret = "";
      for (const [source, replacement] of arrParse) {
        if (typeof source === "number") {
          while (n >= source) {
            ret += replacement;
            n -= source;
          }
        } else {
          ret = ret.replace(source, replacement);
        }
      }
      return ret;
    }
  };
};
var hebrew2Minus = archaicNumbers([
  [1e3, ""],
  [400, "\u05EA"],
  [300, "\u05E9"],
  [200, "\u05E8"],
  [100, "\u05E7"],
  [90, "\u05E6"],
  [80, "\u05E4"],
  [70, "\u05E2"],
  [60, "\u05E1"],
  [50, "\u05E0"],
  [40, "\u05DE"],
  [30, "\u05DC"],
  [20, "\u05DB"],
  [10, "\u05D9"],
  [9, "\u05D8"],
  [8, "\u05D7"],
  [7, "\u05D6"],
  [6, "\u05D5"],
  [5, "\u05D4"],
  [4, "\u05D3"],
  [3, "\u05D2"],
  [2, "\u05D1"],
  [1, "\u05D0"],
  [/יה/, "\u05D8\u05F4\u05D5"],
  [/יו/, "\u05D8\u05F4\u05D6"],
  [/([א-ת])([א-ת])$/, "$1\u05F4$2"],
  [/^([א-ת])$/, "$1\u05F3"]
]);
var getNumTypeNum = (numTyp, num) => {
  let rtrnNum = "";
  switch (numTyp) {
    case "arabicPeriod":
      rtrnNum = num + ". ";
      break;
    case "arabicParenR":
      rtrnNum = num + ") ";
      break;
    case "alphaLcParenR":
      rtrnNum = alphaNumeric(num, "lowerCase") + ") ";
      break;
    case "alphaLcPeriod":
      rtrnNum = alphaNumeric(num, "lowerCase") + ". ";
      break;
    case "alphaUcParenR":
      rtrnNum = alphaNumeric(num, "upperCase") + ") ";
      break;
    case "alphaUcPeriod":
      rtrnNum = alphaNumeric(num, "upperCase") + ". ";
      break;
    case "romanUcPeriod":
      rtrnNum = romanize(num) + ". ";
      break;
    case "romanLcParenR":
      rtrnNum = romanize(num) + ") ";
      break;
    case "hebrew2Minus":
      rtrnNum = hebrew2Minus.format(num) + "-";
      break;
    default:
      rtrnNum = `${num}`;
  }
  return rtrnNum;
};
var alphaNumeric = (num, upperLower) => {
  num = Number(num) - 1;
  let aNum = "";
  if (upperLower == "upperCase") {
    aNum = ((num / 26 >= 1 ? String.fromCharCode(num / 26 + 64) : "") + String.fromCharCode(num % 26 + 65)).toUpperCase();
  } else if (upperLower == "lowerCase") {
    aNum = ((num / 26 >= 1 ? String.fromCharCode(num / 26 + 64) : "") + String.fromCharCode(num % 26 + 65)).toLowerCase();
  }
  return aNum;
};
var romanizeValues = [
  "",
  "C",
  "CC",
  "CCC",
  "CD",
  "D",
  "DC",
  "DCC",
  "DCCC",
  "CM",
  "",
  "X",
  "XX",
  "XXX",
  "XL",
  "L",
  "LX",
  "LXX",
  "LXXX",
  "XC",
  "",
  "I",
  "II",
  "III",
  "IV",
  "V",
  "VI",
  "VII",
  "VIII",
  "IX"
];
var romanize = (num) => {
  if (!+num)
    return false;
  let digits = String(+num).split(""), roman = "", i = 3;
  while (i--)
    roman = (romanizeValues[+digits.pop() + i * 10] || "") + roman;
  return Array(+digits.join("") + 1).join("M") + roman;
};

// src/helpers/pptx/assets/d3.min.js
!function() {
  function n(n2) {
    return n2 && (n2.ownerDocument || n2.document || n2).documentElement;
  }
  function t(n2) {
    return n2 && (n2.ownerDocument && n2.ownerDocument.defaultView || n2.document && n2 || n2.defaultView);
  }
  function e(n2, t2) {
    return t2 > n2 ? -1 : n2 > t2 ? 1 : n2 >= t2 ? 0 : NaN;
  }
  function r(n2) {
    return null === n2 ? NaN : +n2;
  }
  function u(n2) {
    return !isNaN(n2);
  }
  function i(n2) {
    return { left: function(t2, e2, r2, u2) {
      for (arguments.length < 3 && (r2 = 0), arguments.length < 4 && (u2 = t2.length); u2 > r2; ) {
        var i2 = r2 + u2 >>> 1;
        n2(t2[i2], e2) < 0 ? r2 = i2 + 1 : u2 = i2;
      }
      return r2;
    }, right: function(t2, e2, r2, u2) {
      for (arguments.length < 3 && (r2 = 0), arguments.length < 4 && (u2 = t2.length); u2 > r2; ) {
        var i2 = r2 + u2 >>> 1;
        n2(t2[i2], e2) > 0 ? u2 = i2 : r2 = i2 + 1;
      }
      return r2;
    } };
  }
  function a(n2) {
    return n2.length;
  }
  function o(n2) {
    for (var t2 = 1; n2 * t2 % 1; ) t2 *= 10;
    return t2;
  }
  function l(n2, t2) {
    for (var e2 in t2) Object.defineProperty(n2.prototype, e2, { value: t2[e2], enumerable: false });
  }
  function c() {
    this._ = /* @__PURE__ */ Object.create(null);
  }
  function s(n2) {
    return (n2 += "") === xa || n2[0] === ba ? ba + n2 : n2;
  }
  function f(n2) {
    return (n2 += "")[0] === ba ? n2.slice(1) : n2;
  }
  function h(n2) {
    return s(n2) in this._;
  }
  function g(n2) {
    return (n2 = s(n2)) in this._ && delete this._[n2];
  }
  function p() {
    var n2 = [];
    for (var t2 in this._) n2.push(f(t2));
    return n2;
  }
  function v() {
    var n2 = 0;
    for (var t2 in this._) ++n2;
    return n2;
  }
  function d() {
    for (var n2 in this._) return false;
    return true;
  }
  function m() {
    this._ = /* @__PURE__ */ Object.create(null);
  }
  function y(n2) {
    return n2;
  }
  function M(n2, t2, e2) {
    return function() {
      var r2 = e2.apply(t2, arguments);
      return r2 === t2 ? n2 : r2;
    };
  }
  function x(n2, t2) {
    if (t2 in n2) return t2;
    t2 = t2.charAt(0).toUpperCase() + t2.slice(1);
    for (var e2 = 0, r2 = _a.length; r2 > e2; ++e2) {
      var u2 = _a[e2] + t2;
      if (u2 in n2) return u2;
    }
  }
  function b() {
  }
  function _5() {
  }
  function w(n2) {
    function t2() {
      for (var t3, r3 = e2, u2 = -1, i2 = r3.length; ++u2 < i2; ) (t3 = r3[u2].on) && t3.apply(this, arguments);
      return n2;
    }
    var e2 = [], r2 = new c();
    return t2.on = function(t3, u2) {
      var i2, a2 = r2.get(t3);
      return arguments.length < 2 ? a2 && a2.on : (a2 && (a2.on = null, e2 = e2.slice(0, i2 = e2.indexOf(a2)).concat(e2.slice(i2 + 1)), r2.remove(t3)), u2 && e2.push(r2.set(t3, { on: u2 })), n2);
    }, t2;
  }
  function S() {
    oa.event.preventDefault();
  }
  function k() {
    for (var n2, t2 = oa.event; n2 = t2.sourceEvent; ) t2 = n2;
    return t2;
  }
  function N(n2) {
    for (var t2 = new _5(), e2 = 0, r2 = arguments.length; ++e2 < r2; ) t2[arguments[e2]] = w(t2);
    return t2.of = function(e3, r3) {
      return function(u2) {
        try {
          var i2 = u2.sourceEvent = oa.event;
          u2.target = n2, oa.event = u2, t2[u2.type].apply(e3, r3);
        } finally {
          oa.event = i2;
        }
      };
    }, t2;
  }
  function E(n2) {
    return Sa(n2, Aa), n2;
  }
  function A(n2) {
    return "function" == typeof n2 ? n2 : function() {
      return ka(n2, this);
    };
  }
  function C(n2) {
    return "function" == typeof n2 ? n2 : function() {
      return Na(n2, this);
    };
  }
  function z(n2, t2) {
    function e2() {
      this.removeAttribute(n2);
    }
    function r2() {
      this.removeAttributeNS(n2.space, n2.local);
    }
    function u2() {
      this.setAttribute(n2, t2);
    }
    function i2() {
      this.setAttributeNS(n2.space, n2.local, t2);
    }
    function a2() {
      var e3 = t2.apply(this, arguments);
      null == e3 ? this.removeAttribute(n2) : this.setAttribute(n2, e3);
    }
    function o2() {
      var e3 = t2.apply(this, arguments);
      null == e3 ? this.removeAttributeNS(n2.space, n2.local) : this.setAttributeNS(n2.space, n2.local, e3);
    }
    return n2 = oa.ns.qualify(n2), null == t2 ? n2.local ? r2 : e2 : "function" == typeof t2 ? n2.local ? o2 : a2 : n2.local ? i2 : u2;
  }
  function L(n2) {
    return n2.trim().replace(/\s+/g, " ");
  }
  function q(n2) {
    return new RegExp("(?:^|\\s+)" + oa.requote(n2) + "(?:\\s+|$)", "g");
  }
  function T(n2) {
    return (n2 + "").trim().split(/^|\s+/);
  }
  function R(n2, t2) {
    function e2() {
      for (var e3 = -1; ++e3 < u2; ) n2[e3](this, t2);
    }
    function r2() {
      for (var e3 = -1, r3 = t2.apply(this, arguments); ++e3 < u2; ) n2[e3](this, r3);
    }
    n2 = T(n2).map(D);
    var u2 = n2.length;
    return "function" == typeof t2 ? r2 : e2;
  }
  function D(n2) {
    var t2 = q(n2);
    return function(e2, r2) {
      if (u2 = e2.classList) return r2 ? u2.add(n2) : u2.remove(n2);
      var u2 = e2.getAttribute("class") || "";
      r2 ? (t2.lastIndex = 0, t2.test(u2) || e2.setAttribute("class", L(u2 + " " + n2))) : e2.setAttribute("class", L(u2.replace(t2, " ")));
    };
  }
  function P(n2, t2, e2) {
    function r2() {
      this.style.removeProperty(n2);
    }
    function u2() {
      this.style.setProperty(n2, t2, e2);
    }
    function i2() {
      var r3 = t2.apply(this, arguments);
      null == r3 ? this.style.removeProperty(n2) : this.style.setProperty(n2, r3, e2);
    }
    return null == t2 ? r2 : "function" == typeof t2 ? i2 : u2;
  }
  function j(n2, t2) {
    function e2() {
      delete this[n2];
    }
    function r2() {
      this[n2] = t2;
    }
    function u2() {
      var e3 = t2.apply(this, arguments);
      null == e3 ? delete this[n2] : this[n2] = e3;
    }
    return null == t2 ? e2 : "function" == typeof t2 ? u2 : r2;
  }
  function U(n2) {
    function t2() {
      var t3 = this.ownerDocument, e3 = this.namespaceURI;
      return e3 ? t3.createElementNS(e3, n2) : t3.createElement(n2);
    }
    function e2() {
      return this.ownerDocument.createElementNS(n2.space, n2.local);
    }
    return "function" == typeof n2 ? n2 : (n2 = oa.ns.qualify(n2)).local ? e2 : t2;
  }
  function F() {
    var n2 = this.parentNode;
    n2 && n2.removeChild(this);
  }
  function H(n2) {
    return { __data__: n2 };
  }
  function O(n2) {
    return function() {
      return Ea(this, n2);
    };
  }
  function I(n2) {
    return arguments.length || (n2 = e), function(t2, e2) {
      return t2 && e2 ? n2(t2.__data__, e2.__data__) : !t2 - !e2;
    };
  }
  function Y(n2, t2) {
    for (var e2 = 0, r2 = n2.length; r2 > e2; e2++) for (var u2, i2 = n2[e2], a2 = 0, o2 = i2.length; o2 > a2; a2++) (u2 = i2[a2]) && t2(u2, a2, e2);
    return n2;
  }
  function Z(n2) {
    return Sa(n2, za), n2;
  }
  function V(n2) {
    var t2, e2;
    return function(r2, u2, i2) {
      var a2, o2 = n2[i2].update, l2 = o2.length;
      for (i2 != e2 && (e2 = i2, t2 = 0), u2 >= t2 && (t2 = u2 + 1); !(a2 = o2[t2]) && ++t2 < l2; ) ;
      return a2;
    };
  }
  function X(n2, t2, e2) {
    function r2() {
      var t3 = this[a2];
      t3 && (this.removeEventListener(n2, t3, t3.$), delete this[a2]);
    }
    function u2() {
      var u3 = l2(t2, ca(arguments));
      r2.call(this), this.addEventListener(n2, this[a2] = u3, u3.$ = e2), u3._ = t2;
    }
    function i2() {
      var t3, e3 = new RegExp("^__on([^.]+)" + oa.requote(n2) + "$");
      for (var r3 in this) if (t3 = r3.match(e3)) {
        var u3 = this[r3];
        this.removeEventListener(t3[1], u3, u3.$), delete this[r3];
      }
    }
    var a2 = "__on" + n2, o2 = n2.indexOf("."), l2 = $;
    o2 > 0 && (n2 = n2.slice(0, o2));
    var c2 = La.get(n2);
    return c2 && (n2 = c2, l2 = B), o2 ? t2 ? u2 : r2 : t2 ? b : i2;
  }
  function $(n2, t2) {
    return function(e2) {
      var r2 = oa.event;
      oa.event = e2, t2[0] = this.__data__;
      try {
        n2.apply(this, t2);
      } finally {
        oa.event = r2;
      }
    };
  }
  function B(n2, t2) {
    var e2 = $(n2, t2);
    return function(n3) {
      var t3 = this, r2 = n3.relatedTarget;
      r2 && (r2 === t3 || 8 & r2.compareDocumentPosition(t3)) || e2.call(t3, n3);
    };
  }
  function W(e2) {
    var r2 = ".dragsuppress-" + ++Ta, u2 = "click" + r2, i2 = oa.select(t(e2)).on("touchmove" + r2, S).on("dragstart" + r2, S).on("selectstart" + r2, S);
    if (null == qa && (qa = "onselectstart" in e2 ? false : x(e2.style, "userSelect")), qa) {
      var a2 = n(e2).style, o2 = a2[qa];
      a2[qa] = "none";
    }
    return function(n2) {
      if (i2.on(r2, null), qa && (a2[qa] = o2), n2) {
        var t2 = function() {
          i2.on(u2, null);
        };
        i2.on(u2, function() {
          S(), t2();
        }, true), setTimeout(t2, 0);
      }
    };
  }
  function J(n2, e2) {
    e2.changedTouches && (e2 = e2.changedTouches[0]);
    var r2 = n2.ownerSVGElement || n2;
    if (r2.createSVGPoint) {
      var u2 = r2.createSVGPoint();
      if (0 > Ra) {
        var i2 = t(n2);
        if (i2.scrollX || i2.scrollY) {
          r2 = oa.select("body").append("svg").style({ position: "absolute", top: 0, left: 0, margin: 0, padding: 0, border: "none" }, "important");
          var a2 = r2[0][0].getScreenCTM();
          Ra = !(a2.f || a2.e), r2.remove();
        }
      }
      return Ra ? (u2.x = e2.pageX, u2.y = e2.pageY) : (u2.x = e2.clientX, u2.y = e2.clientY), u2 = u2.matrixTransform(n2.getScreenCTM().inverse()), [u2.x, u2.y];
    }
    var o2 = n2.getBoundingClientRect();
    return [e2.clientX - o2.left - n2.clientLeft, e2.clientY - o2.top - n2.clientTop];
  }
  function G() {
    return oa.event.changedTouches[0].identifier;
  }
  function K(n2) {
    return n2 > 0 ? 1 : 0 > n2 ? -1 : 0;
  }
  function Q(n2, t2, e2) {
    return (t2[0] - n2[0]) * (e2[1] - n2[1]) - (t2[1] - n2[1]) * (e2[0] - n2[0]);
  }
  function nn(n2) {
    return n2 > 1 ? 0 : -1 > n2 ? ja : Math.acos(n2);
  }
  function tn(n2) {
    return n2 > 1 ? Ha : -1 > n2 ? -Ha : Math.asin(n2);
  }
  function en(n2) {
    return ((n2 = Math.exp(n2)) - 1 / n2) / 2;
  }
  function rn(n2) {
    return ((n2 = Math.exp(n2)) + 1 / n2) / 2;
  }
  function un(n2) {
    return ((n2 = Math.exp(2 * n2)) - 1) / (n2 + 1);
  }
  function an(n2) {
    return (n2 = Math.sin(n2 / 2)) * n2;
  }
  function on() {
  }
  function ln(n2, t2, e2) {
    return this instanceof ln ? (this.h = +n2, this.s = +t2, void (this.l = +e2)) : arguments.length < 2 ? n2 instanceof ln ? new ln(n2.h, n2.s, n2.l) : _n("" + n2, wn, ln) : new ln(n2, t2, e2);
  }
  function cn(n2, t2, e2) {
    function r2(n3) {
      return n3 > 360 ? n3 -= 360 : 0 > n3 && (n3 += 360), 60 > n3 ? i2 + (a2 - i2) * n3 / 60 : 180 > n3 ? a2 : 240 > n3 ? i2 + (a2 - i2) * (240 - n3) / 60 : i2;
    }
    function u2(n3) {
      return Math.round(255 * r2(n3));
    }
    var i2, a2;
    return n2 = isNaN(n2) ? 0 : (n2 %= 360) < 0 ? n2 + 360 : n2, t2 = isNaN(t2) ? 0 : 0 > t2 ? 0 : t2 > 1 ? 1 : t2, e2 = 0 > e2 ? 0 : e2 > 1 ? 1 : e2, a2 = 0.5 >= e2 ? e2 * (1 + t2) : e2 + t2 - e2 * t2, i2 = 2 * e2 - a2, new yn(u2(n2 + 120), u2(n2), u2(n2 - 120));
  }
  function sn(n2, t2, e2) {
    return this instanceof sn ? (this.h = +n2, this.c = +t2, void (this.l = +e2)) : arguments.length < 2 ? n2 instanceof sn ? new sn(n2.h, n2.c, n2.l) : n2 instanceof hn ? pn(n2.l, n2.a, n2.b) : pn((n2 = Sn((n2 = oa.rgb(n2)).r, n2.g, n2.b)).l, n2.a, n2.b) : new sn(n2, t2, e2);
  }
  function fn(n2, t2, e2) {
    return isNaN(n2) && (n2 = 0), isNaN(t2) && (t2 = 0), new hn(e2, Math.cos(n2 *= Oa) * t2, Math.sin(n2) * t2);
  }
  function hn(n2, t2, e2) {
    return this instanceof hn ? (this.l = +n2, this.a = +t2, void (this.b = +e2)) : arguments.length < 2 ? n2 instanceof hn ? new hn(n2.l, n2.a, n2.b) : n2 instanceof sn ? fn(n2.h, n2.c, n2.l) : Sn((n2 = yn(n2)).r, n2.g, n2.b) : new hn(n2, t2, e2);
  }
  function gn(n2, t2, e2) {
    var r2 = (n2 + 16) / 116, u2 = r2 + t2 / 500, i2 = r2 - e2 / 200;
    return u2 = vn(u2) * Ka, r2 = vn(r2) * Qa, i2 = vn(i2) * no, new yn(mn(3.2404542 * u2 - 1.5371385 * r2 - 0.4985314 * i2), mn(-0.969266 * u2 + 1.8760108 * r2 + 0.041556 * i2), mn(0.0556434 * u2 - 0.2040259 * r2 + 1.0572252 * i2));
  }
  function pn(n2, t2, e2) {
    return n2 > 0 ? new sn(Math.atan2(e2, t2) * Ia, Math.sqrt(t2 * t2 + e2 * e2), n2) : new sn(NaN, NaN, n2);
  }
  function vn(n2) {
    return n2 > 0.206893034 ? n2 * n2 * n2 : (n2 - 4 / 29) / 7.787037;
  }
  function dn(n2) {
    return n2 > 8856e-6 ? Math.pow(n2, 1 / 3) : 7.787037 * n2 + 4 / 29;
  }
  function mn(n2) {
    return Math.round(255 * (304e-5 >= n2 ? 12.92 * n2 : 1.055 * Math.pow(n2, 1 / 2.4) - 0.055));
  }
  function yn(n2, t2, e2) {
    return this instanceof yn ? (this.r = ~~n2, this.g = ~~t2, void (this.b = ~~e2)) : arguments.length < 2 ? n2 instanceof yn ? new yn(n2.r, n2.g, n2.b) : _n("" + n2, yn, cn) : new yn(n2, t2, e2);
  }
  function Mn(n2) {
    return new yn(n2 >> 16, n2 >> 8 & 255, 255 & n2);
  }
  function xn(n2) {
    return Mn(n2) + "";
  }
  function bn(n2) {
    return 16 > n2 ? "0" + Math.max(0, n2).toString(16) : Math.min(255, n2).toString(16);
  }
  function _n(n2, t2, e2) {
    var r2, u2, i2, a2 = 0, o2 = 0, l2 = 0;
    if (r2 = /([a-z]+)\((.*)\)/.exec(n2 = n2.toLowerCase())) switch (u2 = r2[2].split(","), r2[1]) {
      case "hsl":
        return e2(parseFloat(u2[0]), parseFloat(u2[1]) / 100, parseFloat(u2[2]) / 100);
      case "rgb":
        return t2(Nn(u2[0]), Nn(u2[1]), Nn(u2[2]));
    }
    return (i2 = ro.get(n2)) ? t2(i2.r, i2.g, i2.b) : (null == n2 || "#" !== n2.charAt(0) || isNaN(i2 = parseInt(n2.slice(1), 16)) || (4 === n2.length ? (a2 = (3840 & i2) >> 4, a2 = a2 >> 4 | a2, o2 = 240 & i2, o2 = o2 >> 4 | o2, l2 = 15 & i2, l2 = l2 << 4 | l2) : 7 === n2.length && (a2 = (16711680 & i2) >> 16, o2 = (65280 & i2) >> 8, l2 = 255 & i2)), t2(a2, o2, l2));
  }
  function wn(n2, t2, e2) {
    var r2, u2, i2 = Math.min(n2 /= 255, t2 /= 255, e2 /= 255), a2 = Math.max(n2, t2, e2), o2 = a2 - i2, l2 = (a2 + i2) / 2;
    return o2 ? (u2 = 0.5 > l2 ? o2 / (a2 + i2) : o2 / (2 - a2 - i2), r2 = n2 == a2 ? (t2 - e2) / o2 + (e2 > t2 ? 6 : 0) : t2 == a2 ? (e2 - n2) / o2 + 2 : (n2 - t2) / o2 + 4, r2 *= 60) : (r2 = NaN, u2 = l2 > 0 && 1 > l2 ? 0 : r2), new ln(r2, u2, l2);
  }
  function Sn(n2, t2, e2) {
    n2 = kn(n2), t2 = kn(t2), e2 = kn(e2);
    var r2 = dn((0.4124564 * n2 + 0.3575761 * t2 + 0.1804375 * e2) / Ka), u2 = dn((0.2126729 * n2 + 0.7151522 * t2 + 0.072175 * e2) / Qa), i2 = dn((0.0193339 * n2 + 0.119192 * t2 + 0.9503041 * e2) / no);
    return hn(116 * u2 - 16, 500 * (r2 - u2), 200 * (u2 - i2));
  }
  function kn(n2) {
    return (n2 /= 255) <= 0.04045 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4);
  }
  function Nn(n2) {
    var t2 = parseFloat(n2);
    return "%" === n2.charAt(n2.length - 1) ? Math.round(2.55 * t2) : t2;
  }
  function En(n2) {
    return "function" == typeof n2 ? n2 : function() {
      return n2;
    };
  }
  function An(n2) {
    return function(t2, e2, r2) {
      return 2 === arguments.length && "function" == typeof e2 && (r2 = e2, e2 = null), Cn(t2, e2, n2, r2);
    };
  }
  function Cn(n2, t2, e2, r2) {
    function u2() {
      var n3, t3 = l2.status;
      if (!t3 && Ln(l2) || t3 >= 200 && 300 > t3 || 304 === t3) {
        try {
          n3 = e2.call(i2, l2);
        } catch (r3) {
          return void a2.error.call(i2, r3);
        }
        a2.load.call(i2, n3);
      } else a2.error.call(i2, l2);
    }
    var i2 = {}, a2 = oa.dispatch("beforesend", "progress", "load", "error"), o2 = {}, l2 = new XMLHttpRequest(), c2 = null;
    return !this.XDomainRequest || "withCredentials" in l2 || !/^(http(s)?:)?\/\//.test(n2) || (l2 = new XDomainRequest()), "onload" in l2 ? l2.onload = l2.onerror = u2 : l2.onreadystatechange = function() {
      l2.readyState > 3 && u2();
    }, l2.onprogress = function(n3) {
      var t3 = oa.event;
      oa.event = n3;
      try {
        a2.progress.call(i2, l2);
      } finally {
        oa.event = t3;
      }
    }, i2.header = function(n3, t3) {
      return n3 = (n3 + "").toLowerCase(), arguments.length < 2 ? o2[n3] : (null == t3 ? delete o2[n3] : o2[n3] = t3 + "", i2);
    }, i2.mimeType = function(n3) {
      return arguments.length ? (t2 = null == n3 ? null : n3 + "", i2) : t2;
    }, i2.responseType = function(n3) {
      return arguments.length ? (c2 = n3, i2) : c2;
    }, i2.response = function(n3) {
      return e2 = n3, i2;
    }, ["get", "post"].forEach(function(n3) {
      i2[n3] = function() {
        return i2.send.apply(i2, [n3].concat(ca(arguments)));
      };
    }), i2.send = function(e3, r3, u3) {
      if (2 === arguments.length && "function" == typeof r3 && (u3 = r3, r3 = null), l2.open(e3, n2, true), null == t2 || "accept" in o2 || (o2.accept = t2 + ",*/*"), l2.setRequestHeader) for (var s2 in o2) l2.setRequestHeader(s2, o2[s2]);
      return null != t2 && l2.overrideMimeType && l2.overrideMimeType(t2), null != c2 && (l2.responseType = c2), null != u3 && i2.on("error", u3).on("load", function(n3) {
        u3(null, n3);
      }), a2.beforesend.call(i2, l2), l2.send(null == r3 ? null : r3), i2;
    }, i2.abort = function() {
      return l2.abort(), i2;
    }, oa.rebind(i2, a2, "on"), null == r2 ? i2 : i2.get(zn(r2));
  }
  function zn(n2) {
    return 1 === n2.length ? function(t2, e2) {
      n2(null == t2 ? e2 : null);
    } : n2;
  }
  function Ln(n2) {
    var t2 = n2.responseType;
    return t2 && "text" !== t2 ? n2.response : n2.responseText;
  }
  function qn(n2, t2, e2) {
    var r2 = arguments.length;
    2 > r2 && (t2 = 0), 3 > r2 && (e2 = Date.now());
    var u2 = e2 + t2, i2 = { c: n2, t: u2, n: null };
    return io ? io.n = i2 : uo = i2, io = i2, ao || (oo = clearTimeout(oo), ao = 1, lo(Tn)), i2;
  }
  function Tn() {
    var n2 = Rn(), t2 = Dn() - n2;
    t2 > 24 ? (isFinite(t2) && (clearTimeout(oo), oo = setTimeout(Tn, t2)), ao = 0) : (ao = 1, lo(Tn));
  }
  function Rn() {
    for (var n2 = Date.now(), t2 = uo; t2; ) n2 >= t2.t && t2.c(n2 - t2.t) && (t2.c = null), t2 = t2.n;
    return n2;
  }
  function Dn() {
    for (var n2, t2 = uo, e2 = 1 / 0; t2; ) t2.c ? (t2.t < e2 && (e2 = t2.t), t2 = (n2 = t2).n) : t2 = n2 ? n2.n = t2.n : uo = t2.n;
    return io = n2, e2;
  }
  function Pn(n2, t2) {
    return t2 - (n2 ? Math.ceil(Math.log(n2) / Math.LN10) : 1);
  }
  function jn(n2, t2) {
    var e2 = Math.pow(10, 3 * Ma(8 - t2));
    return { scale: t2 > 8 ? function(n3) {
      return n3 / e2;
    } : function(n3) {
      return n3 * e2;
    }, symbol: n2 };
  }
  function Un(n2) {
    var t2 = n2.decimal, e2 = n2.thousands, r2 = n2.grouping, u2 = n2.currency, i2 = r2 && e2 ? function(n3, t3) {
      for (var u3 = n3.length, i3 = [], a2 = 0, o2 = r2[0], l2 = 0; u3 > 0 && o2 > 0 && (l2 + o2 + 1 > t3 && (o2 = Math.max(1, t3 - l2)), i3.push(n3.substring(u3 -= o2, u3 + o2)), !((l2 += o2 + 1) > t3)); ) o2 = r2[a2 = (a2 + 1) % r2.length];
      return i3.reverse().join(e2);
    } : y;
    return function(n3) {
      var e3 = so.exec(n3), r3 = e3[1] || " ", a2 = e3[2] || ">", o2 = e3[3] || "-", l2 = e3[4] || "", c2 = e3[5], s2 = +e3[6], f2 = e3[7], h2 = e3[8], g2 = e3[9], p2 = 1, v2 = "", d2 = "", m2 = false, y2 = true;
      switch (h2 && (h2 = +h2.substring(1)), (c2 || "0" === r3 && "=" === a2) && (c2 = r3 = "0", a2 = "="), g2) {
        case "n":
          f2 = true, g2 = "g";
          break;
        case "%":
          p2 = 100, d2 = "%", g2 = "f";
          break;
        case "p":
          p2 = 100, d2 = "%", g2 = "r";
          break;
        case "b":
        case "o":
        case "x":
        case "X":
          "#" === l2 && (v2 = "0" + g2.toLowerCase());
        case "c":
          y2 = false;
        case "d":
          m2 = true, h2 = 0;
          break;
        case "s":
          p2 = -1, g2 = "r";
      }
      "$" === l2 && (v2 = u2[0], d2 = u2[1]), "r" != g2 || h2 || (g2 = "g"), null != h2 && ("g" == g2 ? h2 = Math.max(1, Math.min(21, h2)) : ("e" == g2 || "f" == g2) && (h2 = Math.max(0, Math.min(20, h2)))), g2 = fo.get(g2) || Fn;
      var M2 = c2 && f2;
      return function(n4) {
        var e4 = d2;
        if (m2 && n4 % 1) return "";
        var u3 = 0 > n4 || 0 === n4 && 0 > 1 / n4 ? (n4 = -n4, "-") : "-" === o2 ? "" : o2;
        if (0 > p2) {
          var l3 = oa.formatPrefix(n4, h2);
          n4 = l3.scale(n4), e4 = l3.symbol + d2;
        } else n4 *= p2;
        n4 = g2(n4, h2);
        var x2, b2, _6 = n4.lastIndexOf(".");
        if (0 > _6) {
          var w2 = y2 ? n4.lastIndexOf("e") : -1;
          0 > w2 ? (x2 = n4, b2 = "") : (x2 = n4.substring(0, w2), b2 = n4.substring(w2));
        } else x2 = n4.substring(0, _6), b2 = t2 + n4.substring(_6 + 1);
        !c2 && f2 && (x2 = i2(x2, 1 / 0));
        var S2 = v2.length + x2.length + b2.length + (M2 ? 0 : u3.length), k2 = s2 > S2 ? new Array(S2 = s2 - S2 + 1).join(r3) : "";
        return M2 && (x2 = i2(k2 + x2, k2.length ? s2 - b2.length : 1 / 0)), u3 += v2, n4 = x2 + b2, ("<" === a2 ? u3 + n4 + k2 : ">" === a2 ? k2 + u3 + n4 : "^" === a2 ? k2.substring(0, S2 >>= 1) + u3 + n4 + k2.substring(S2) : u3 + (M2 ? n4 : k2 + n4)) + e4;
      };
    };
  }
  function Fn(n2) {
    return n2 + "";
  }
  function Hn() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  function On(n2, t2, e2) {
    function r2(t3) {
      var e3 = n2(t3), r3 = i2(e3, 1);
      return r3 - t3 > t3 - e3 ? e3 : r3;
    }
    function u2(e3) {
      return t2(e3 = n2(new go(e3 - 1)), 1), e3;
    }
    function i2(n3, e3) {
      return t2(n3 = new go(+n3), e3), n3;
    }
    function a2(n3, r3, i3) {
      var a3 = u2(n3), o3 = [];
      if (i3 > 1) for (; r3 > a3; ) e2(a3) % i3 || o3.push(/* @__PURE__ */ new Date(+a3)), t2(a3, 1);
      else for (; r3 > a3; ) o3.push(/* @__PURE__ */ new Date(+a3)), t2(a3, 1);
      return o3;
    }
    function o2(n3, t3, e3) {
      try {
        go = Hn;
        var r3 = new Hn();
        return r3._ = n3, a2(r3, t3, e3);
      } finally {
        go = Date;
      }
    }
    n2.floor = n2, n2.round = r2, n2.ceil = u2, n2.offset = i2, n2.range = a2;
    var l2 = n2.utc = In(n2);
    return l2.floor = l2, l2.round = In(r2), l2.ceil = In(u2), l2.offset = In(i2), l2.range = o2, n2;
  }
  function In(n2) {
    return function(t2, e2) {
      try {
        go = Hn;
        var r2 = new Hn();
        return r2._ = t2, n2(r2, e2)._;
      } finally {
        go = Date;
      }
    };
  }
  function Yn(n2) {
    function t2(n3) {
      function t3(t4) {
        for (var e3, u3, i3, a3 = [], o3 = -1, l3 = 0; ++o3 < r3; ) 37 === n3.charCodeAt(o3) && (a3.push(n3.slice(l3, o3)), null != (u3 = vo[e3 = n3.charAt(++o3)]) && (e3 = n3.charAt(++o3)), (i3 = A2[e3]) && (e3 = i3(t4, null == u3 ? "e" === e3 ? " " : "0" : u3)), a3.push(e3), l3 = o3 + 1);
        return a3.push(n3.slice(l3, o3)), a3.join("");
      }
      var r3 = n3.length;
      return t3.parse = function(t4) {
        var r4 = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, u3 = e2(r4, n3, t4, 0);
        if (u3 != t4.length) return null;
        "p" in r4 && (r4.H = r4.H % 12 + 12 * r4.p);
        var i3 = null != r4.Z && go !== Hn, a3 = new (i3 ? Hn : go)();
        return "j" in r4 ? a3.setFullYear(r4.y, 0, r4.j) : "W" in r4 || "U" in r4 ? ("w" in r4 || (r4.w = "W" in r4 ? 1 : 0), a3.setFullYear(r4.y, 0, 1), a3.setFullYear(r4.y, 0, "W" in r4 ? (r4.w + 6) % 7 + 7 * r4.W - (a3.getDay() + 5) % 7 : r4.w + 7 * r4.U - (a3.getDay() + 6) % 7)) : a3.setFullYear(r4.y, r4.m, r4.d), a3.setHours(r4.H + (r4.Z / 100 | 0), r4.M + r4.Z % 100, r4.S, r4.L), i3 ? a3._ : a3;
      }, t3.toString = function() {
        return n3;
      }, t3;
    }
    function e2(n3, t3, e3, r3) {
      for (var u3, i3, a3, o3 = 0, l3 = t3.length, c3 = e3.length; l3 > o3; ) {
        if (r3 >= c3) return -1;
        if (u3 = t3.charCodeAt(o3++), 37 === u3) {
          if (a3 = t3.charAt(o3++), i3 = C2[a3 in vo ? t3.charAt(o3++) : a3], !i3 || (r3 = i3(n3, e3, r3)) < 0) return -1;
        } else if (u3 != e3.charCodeAt(r3++)) return -1;
      }
      return r3;
    }
    function r2(n3, t3, e3) {
      _6.lastIndex = 0;
      var r3 = _6.exec(t3.slice(e3));
      return r3 ? (n3.w = w2.get(r3[0].toLowerCase()), e3 + r3[0].length) : -1;
    }
    function u2(n3, t3, e3) {
      x2.lastIndex = 0;
      var r3 = x2.exec(t3.slice(e3));
      return r3 ? (n3.w = b2.get(r3[0].toLowerCase()), e3 + r3[0].length) : -1;
    }
    function i2(n3, t3, e3) {
      N2.lastIndex = 0;
      var r3 = N2.exec(t3.slice(e3));
      return r3 ? (n3.m = E2.get(r3[0].toLowerCase()), e3 + r3[0].length) : -1;
    }
    function a2(n3, t3, e3) {
      S2.lastIndex = 0;
      var r3 = S2.exec(t3.slice(e3));
      return r3 ? (n3.m = k2.get(r3[0].toLowerCase()), e3 + r3[0].length) : -1;
    }
    function o2(n3, t3, r3) {
      return e2(n3, A2.c.toString(), t3, r3);
    }
    function l2(n3, t3, r3) {
      return e2(n3, A2.x.toString(), t3, r3);
    }
    function c2(n3, t3, r3) {
      return e2(n3, A2.X.toString(), t3, r3);
    }
    function s2(n3, t3, e3) {
      var r3 = M2.get(t3.slice(e3, e3 += 2).toLowerCase());
      return null == r3 ? -1 : (n3.p = r3, e3);
    }
    var f2 = n2.dateTime, h2 = n2.date, g2 = n2.time, p2 = n2.periods, v2 = n2.days, d2 = n2.shortDays, m2 = n2.months, y2 = n2.shortMonths;
    t2.utc = function(n3) {
      function e3(n4) {
        try {
          go = Hn;
          var t3 = new go();
          return t3._ = n4, r3(t3);
        } finally {
          go = Date;
        }
      }
      var r3 = t2(n3);
      return e3.parse = function(n4) {
        try {
          go = Hn;
          var t3 = r3.parse(n4);
          return t3 && t3._;
        } finally {
          go = Date;
        }
      }, e3.toString = r3.toString, e3;
    }, t2.multi = t2.utc.multi = ct;
    var M2 = oa.map(), x2 = Vn(v2), b2 = Xn(v2), _6 = Vn(d2), w2 = Xn(d2), S2 = Vn(m2), k2 = Xn(m2), N2 = Vn(y2), E2 = Xn(y2);
    p2.forEach(function(n3, t3) {
      M2.set(n3.toLowerCase(), t3);
    });
    var A2 = { a: function(n3) {
      return d2[n3.getDay()];
    }, A: function(n3) {
      return v2[n3.getDay()];
    }, b: function(n3) {
      return y2[n3.getMonth()];
    }, B: function(n3) {
      return m2[n3.getMonth()];
    }, c: t2(f2), d: function(n3, t3) {
      return Zn(n3.getDate(), t3, 2);
    }, e: function(n3, t3) {
      return Zn(n3.getDate(), t3, 2);
    }, H: function(n3, t3) {
      return Zn(n3.getHours(), t3, 2);
    }, I: function(n3, t3) {
      return Zn(n3.getHours() % 12 || 12, t3, 2);
    }, j: function(n3, t3) {
      return Zn(1 + ho.dayOfYear(n3), t3, 3);
    }, L: function(n3, t3) {
      return Zn(n3.getMilliseconds(), t3, 3);
    }, m: function(n3, t3) {
      return Zn(n3.getMonth() + 1, t3, 2);
    }, M: function(n3, t3) {
      return Zn(n3.getMinutes(), t3, 2);
    }, p: function(n3) {
      return p2[+(n3.getHours() >= 12)];
    }, S: function(n3, t3) {
      return Zn(n3.getSeconds(), t3, 2);
    }, U: function(n3, t3) {
      return Zn(ho.sundayOfYear(n3), t3, 2);
    }, w: function(n3) {
      return n3.getDay();
    }, W: function(n3, t3) {
      return Zn(ho.mondayOfYear(n3), t3, 2);
    }, x: t2(h2), X: t2(g2), y: function(n3, t3) {
      return Zn(n3.getFullYear() % 100, t3, 2);
    }, Y: function(n3, t3) {
      return Zn(n3.getFullYear() % 1e4, t3, 4);
    }, Z: ot, "%": function() {
      return "%";
    } }, C2 = { a: r2, A: u2, b: i2, B: a2, c: o2, d: tt, e: tt, H: rt, I: rt, j: et, L: at, m: nt, M: ut, p: s2, S: it, U: Bn, w: $n, W: Wn, x: l2, X: c2, y: Gn, Y: Jn, Z: Kn, "%": lt };
    return t2;
  }
  function Zn(n2, t2, e2) {
    var r2 = 0 > n2 ? "-" : "", u2 = (r2 ? -n2 : n2) + "", i2 = u2.length;
    return r2 + (e2 > i2 ? new Array(e2 - i2 + 1).join(t2) + u2 : u2);
  }
  function Vn(n2) {
    return new RegExp("^(?:" + n2.map(oa.requote).join("|") + ")", "i");
  }
  function Xn(n2) {
    for (var t2 = new c(), e2 = -1, r2 = n2.length; ++e2 < r2; ) t2.set(n2[e2].toLowerCase(), e2);
    return t2;
  }
  function $n(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 1));
    return r2 ? (n2.w = +r2[0], e2 + r2[0].length) : -1;
  }
  function Bn(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2));
    return r2 ? (n2.U = +r2[0], e2 + r2[0].length) : -1;
  }
  function Wn(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2));
    return r2 ? (n2.W = +r2[0], e2 + r2[0].length) : -1;
  }
  function Jn(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 4));
    return r2 ? (n2.y = +r2[0], e2 + r2[0].length) : -1;
  }
  function Gn(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.y = Qn(+r2[0]), e2 + r2[0].length) : -1;
  }
  function Kn(n2, t2, e2) {
    return /^[+-]\d{4}$/.test(t2 = t2.slice(e2, e2 + 5)) ? (n2.Z = -t2, e2 + 5) : -1;
  }
  function Qn(n2) {
    return n2 + (n2 > 68 ? 1900 : 2e3);
  }
  function nt(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.m = r2[0] - 1, e2 + r2[0].length) : -1;
  }
  function tt(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.d = +r2[0], e2 + r2[0].length) : -1;
  }
  function et(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 3));
    return r2 ? (n2.j = +r2[0], e2 + r2[0].length) : -1;
  }
  function rt(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.H = +r2[0], e2 + r2[0].length) : -1;
  }
  function ut(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.M = +r2[0], e2 + r2[0].length) : -1;
  }
  function it(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 2));
    return r2 ? (n2.S = +r2[0], e2 + r2[0].length) : -1;
  }
  function at(n2, t2, e2) {
    mo.lastIndex = 0;
    var r2 = mo.exec(t2.slice(e2, e2 + 3));
    return r2 ? (n2.L = +r2[0], e2 + r2[0].length) : -1;
  }
  function ot(n2) {
    var t2 = n2.getTimezoneOffset(), e2 = t2 > 0 ? "-" : "+", r2 = Ma(t2) / 60 | 0, u2 = Ma(t2) % 60;
    return e2 + Zn(r2, "0", 2) + Zn(u2, "0", 2);
  }
  function lt(n2, t2, e2) {
    yo.lastIndex = 0;
    var r2 = yo.exec(t2.slice(e2, e2 + 1));
    return r2 ? e2 + r2[0].length : -1;
  }
  function ct(n2) {
    for (var t2 = n2.length, e2 = -1; ++e2 < t2; ) n2[e2][0] = this(n2[e2][0]);
    return function(t3) {
      for (var e3 = 0, r2 = n2[e3]; !r2[1](t3); ) r2 = n2[++e3];
      return r2[0](t3);
    };
  }
  function st() {
  }
  function ft(n2, t2, e2) {
    var r2 = e2.s = n2 + t2, u2 = r2 - n2, i2 = r2 - u2;
    e2.t = n2 - i2 + (t2 - u2);
  }
  function ht(n2, t2) {
    n2 && _o.hasOwnProperty(n2.type) && _o[n2.type](n2, t2);
  }
  function gt(n2, t2, e2) {
    var r2, u2 = -1, i2 = n2.length - e2;
    for (t2.lineStart(); ++u2 < i2; ) r2 = n2[u2], t2.point(r2[0], r2[1], r2[2]);
    t2.lineEnd();
  }
  function pt(n2, t2) {
    var e2 = -1, r2 = n2.length;
    for (t2.polygonStart(); ++e2 < r2; ) gt(n2[e2], t2, 1);
    t2.polygonEnd();
  }
  function vt() {
    function n2(n3, t3) {
      n3 *= Oa, t3 = t3 * Oa / 2 + ja / 4;
      var e3 = n3 - r2, a2 = e3 >= 0 ? 1 : -1, o2 = a2 * e3, l2 = Math.cos(t3), c2 = Math.sin(t3), s2 = i2 * c2, f2 = u2 * l2 + s2 * Math.cos(o2), h2 = s2 * a2 * Math.sin(o2);
      So.add(Math.atan2(h2, f2)), r2 = n3, u2 = l2, i2 = c2;
    }
    var t2, e2, r2, u2, i2;
    ko.point = function(a2, o2) {
      ko.point = n2, r2 = (t2 = a2) * Oa, u2 = Math.cos(o2 = (e2 = o2) * Oa / 2 + ja / 4), i2 = Math.sin(o2);
    }, ko.lineEnd = function() {
      n2(t2, e2);
    };
  }
  function dt(n2) {
    var t2 = n2[0], e2 = n2[1], r2 = Math.cos(e2);
    return [r2 * Math.cos(t2), r2 * Math.sin(t2), Math.sin(e2)];
  }
  function mt(n2, t2) {
    return n2[0] * t2[0] + n2[1] * t2[1] + n2[2] * t2[2];
  }
  function yt(n2, t2) {
    return [n2[1] * t2[2] - n2[2] * t2[1], n2[2] * t2[0] - n2[0] * t2[2], n2[0] * t2[1] - n2[1] * t2[0]];
  }
  function Mt(n2, t2) {
    n2[0] += t2[0], n2[1] += t2[1], n2[2] += t2[2];
  }
  function xt(n2, t2) {
    return [n2[0] * t2, n2[1] * t2, n2[2] * t2];
  }
  function bt(n2) {
    var t2 = Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1] + n2[2] * n2[2]);
    n2[0] /= t2, n2[1] /= t2, n2[2] /= t2;
  }
  function _t(n2) {
    return [Math.atan2(n2[1], n2[0]), tn(n2[2])];
  }
  function wt(n2, t2) {
    return Ma(n2[0] - t2[0]) < Da && Ma(n2[1] - t2[1]) < Da;
  }
  function St(n2, t2) {
    n2 *= Oa;
    var e2 = Math.cos(t2 *= Oa);
    kt(e2 * Math.cos(n2), e2 * Math.sin(n2), Math.sin(t2));
  }
  function kt(n2, t2, e2) {
    ++No, Ao += (n2 - Ao) / No, Co += (t2 - Co) / No, zo += (e2 - zo) / No;
  }
  function Nt() {
    function n2(n3, u2) {
      n3 *= Oa;
      var i2 = Math.cos(u2 *= Oa), a2 = i2 * Math.cos(n3), o2 = i2 * Math.sin(n3), l2 = Math.sin(u2), c2 = Math.atan2(Math.sqrt((c2 = e2 * l2 - r2 * o2) * c2 + (c2 = r2 * a2 - t2 * l2) * c2 + (c2 = t2 * o2 - e2 * a2) * c2), t2 * a2 + e2 * o2 + r2 * l2);
      Eo += c2, Lo += c2 * (t2 + (t2 = a2)), qo += c2 * (e2 + (e2 = o2)), To += c2 * (r2 + (r2 = l2)), kt(t2, e2, r2);
    }
    var t2, e2, r2;
    jo.point = function(u2, i2) {
      u2 *= Oa;
      var a2 = Math.cos(i2 *= Oa);
      t2 = a2 * Math.cos(u2), e2 = a2 * Math.sin(u2), r2 = Math.sin(i2), jo.point = n2, kt(t2, e2, r2);
    };
  }
  function Et() {
    jo.point = St;
  }
  function At() {
    function n2(n3, t3) {
      n3 *= Oa;
      var e3 = Math.cos(t3 *= Oa), a2 = e3 * Math.cos(n3), o2 = e3 * Math.sin(n3), l2 = Math.sin(t3), c2 = u2 * l2 - i2 * o2, s2 = i2 * a2 - r2 * l2, f2 = r2 * o2 - u2 * a2, h2 = Math.sqrt(c2 * c2 + s2 * s2 + f2 * f2), g2 = r2 * a2 + u2 * o2 + i2 * l2, p2 = h2 && -nn(g2) / h2, v2 = Math.atan2(h2, g2);
      Ro += p2 * c2, Do += p2 * s2, Po += p2 * f2, Eo += v2, Lo += v2 * (r2 + (r2 = a2)), qo += v2 * (u2 + (u2 = o2)), To += v2 * (i2 + (i2 = l2)), kt(r2, u2, i2);
    }
    var t2, e2, r2, u2, i2;
    jo.point = function(a2, o2) {
      t2 = a2, e2 = o2, jo.point = n2, a2 *= Oa;
      var l2 = Math.cos(o2 *= Oa);
      r2 = l2 * Math.cos(a2), u2 = l2 * Math.sin(a2), i2 = Math.sin(o2), kt(r2, u2, i2);
    }, jo.lineEnd = function() {
      n2(t2, e2), jo.lineEnd = Et, jo.point = St;
    };
  }
  function Ct(n2, t2) {
    function e2(e3, r2) {
      return e3 = n2(e3, r2), t2(e3[0], e3[1]);
    }
    return n2.invert && t2.invert && (e2.invert = function(e3, r2) {
      return e3 = t2.invert(e3, r2), e3 && n2.invert(e3[0], e3[1]);
    }), e2;
  }
  function zt() {
    return true;
  }
  function Lt(n2, t2, e2, r2, u2) {
    var i2 = [], a2 = [];
    if (n2.forEach(function(n3) {
      if (!((t3 = n3.length - 1) <= 0)) {
        var t3, e3 = n3[0], r3 = n3[t3];
        if (wt(e3, r3)) {
          u2.lineStart();
          for (var o3 = 0; t3 > o3; ++o3) u2.point((e3 = n3[o3])[0], e3[1]);
          return void u2.lineEnd();
        }
        var l3 = new Tt(e3, n3, null, true), c3 = new Tt(e3, null, l3, false);
        l3.o = c3, i2.push(l3), a2.push(c3), l3 = new Tt(r3, n3, null, false), c3 = new Tt(r3, null, l3, true), l3.o = c3, i2.push(l3), a2.push(c3);
      }
    }), a2.sort(t2), qt(i2), qt(a2), i2.length) {
      for (var o2 = 0, l2 = e2, c2 = a2.length; c2 > o2; ++o2) a2[o2].e = l2 = !l2;
      for (var s2, f2, h2 = i2[0]; ; ) {
        for (var g2 = h2, p2 = true; g2.v; ) if ((g2 = g2.n) === h2) return;
        s2 = g2.z, u2.lineStart();
        do {
          if (g2.v = g2.o.v = true, g2.e) {
            if (p2) for (var o2 = 0, c2 = s2.length; c2 > o2; ++o2) u2.point((f2 = s2[o2])[0], f2[1]);
            else r2(g2.x, g2.n.x, 1, u2);
            g2 = g2.n;
          } else {
            if (p2) {
              s2 = g2.p.z;
              for (var o2 = s2.length - 1; o2 >= 0; --o2) u2.point((f2 = s2[o2])[0], f2[1]);
            } else r2(g2.x, g2.p.x, -1, u2);
            g2 = g2.p;
          }
          g2 = g2.o, s2 = g2.z, p2 = !p2;
        } while (!g2.v);
        u2.lineEnd();
      }
    }
  }
  function qt(n2) {
    if (t2 = n2.length) {
      for (var t2, e2, r2 = 0, u2 = n2[0]; ++r2 < t2; ) u2.n = e2 = n2[r2], e2.p = u2, u2 = e2;
      u2.n = e2 = n2[0], e2.p = u2;
    }
  }
  function Tt(n2, t2, e2, r2) {
    this.x = n2, this.z = t2, this.o = e2, this.e = r2, this.v = false, this.n = this.p = null;
  }
  function Rt(n2, t2, e2, r2) {
    return function(u2, i2) {
      function a2(t3, e3) {
        var r3 = u2(t3, e3);
        n2(t3 = r3[0], e3 = r3[1]) && i2.point(t3, e3);
      }
      function o2(n3, t3) {
        var e3 = u2(n3, t3);
        d2.point(e3[0], e3[1]);
      }
      function l2() {
        y2.point = o2, d2.lineStart();
      }
      function c2() {
        y2.point = a2, d2.lineEnd();
      }
      function s2(n3, t3) {
        v2.push([n3, t3]);
        var e3 = u2(n3, t3);
        x2.point(e3[0], e3[1]);
      }
      function f2() {
        x2.lineStart(), v2 = [];
      }
      function h2() {
        s2(v2[0][0], v2[0][1]), x2.lineEnd();
        var n3, t3 = x2.clean(), e3 = M2.buffer(), r3 = e3.length;
        if (v2.pop(), p2.push(v2), v2 = null, r3) if (1 & t3) {
          n3 = e3[0];
          var u3, r3 = n3.length - 1, a3 = -1;
          if (r3 > 0) {
            for (b2 || (i2.polygonStart(), b2 = true), i2.lineStart(); ++a3 < r3; ) i2.point((u3 = n3[a3])[0], u3[1]);
            i2.lineEnd();
          }
        } else r3 > 1 && 2 & t3 && e3.push(e3.pop().concat(e3.shift())), g2.push(e3.filter(Dt));
      }
      var g2, p2, v2, d2 = t2(i2), m2 = u2.invert(r2[0], r2[1]), y2 = { point: a2, lineStart: l2, lineEnd: c2, polygonStart: function() {
        y2.point = s2, y2.lineStart = f2, y2.lineEnd = h2, g2 = [], p2 = [];
      }, polygonEnd: function() {
        y2.point = a2, y2.lineStart = l2, y2.lineEnd = c2, g2 = oa.merge(g2);
        var n3 = Ot(m2, p2);
        g2.length ? (b2 || (i2.polygonStart(), b2 = true), Lt(g2, jt, n3, e2, i2)) : n3 && (b2 || (i2.polygonStart(), b2 = true), i2.lineStart(), e2(null, null, 1, i2), i2.lineEnd()), b2 && (i2.polygonEnd(), b2 = false), g2 = p2 = null;
      }, sphere: function() {
        i2.polygonStart(), i2.lineStart(), e2(null, null, 1, i2), i2.lineEnd(), i2.polygonEnd();
      } }, M2 = Pt(), x2 = t2(M2), b2 = false;
      return y2;
    };
  }
  function Dt(n2) {
    return n2.length > 1;
  }
  function Pt() {
    var n2, t2 = [];
    return { lineStart: function() {
      t2.push(n2 = []);
    }, point: function(t3, e2) {
      n2.push([t3, e2]);
    }, lineEnd: b, buffer: function() {
      var e2 = t2;
      return t2 = [], n2 = null, e2;
    }, rejoin: function() {
      t2.length > 1 && t2.push(t2.pop().concat(t2.shift()));
    } };
  }
  function jt(n2, t2) {
    return ((n2 = n2.x)[0] < 0 ? n2[1] - Ha - Da : Ha - n2[1]) - ((t2 = t2.x)[0] < 0 ? t2[1] - Ha - Da : Ha - t2[1]);
  }
  function Ut(n2) {
    var t2, e2 = NaN, r2 = NaN, u2 = NaN;
    return { lineStart: function() {
      n2.lineStart(), t2 = 1;
    }, point: function(i2, a2) {
      var o2 = i2 > 0 ? ja : -ja, l2 = Ma(i2 - e2);
      Ma(l2 - ja) < Da ? (n2.point(e2, r2 = (r2 + a2) / 2 > 0 ? Ha : -Ha), n2.point(u2, r2), n2.lineEnd(), n2.lineStart(), n2.point(o2, r2), n2.point(i2, r2), t2 = 0) : u2 !== o2 && l2 >= ja && (Ma(e2 - u2) < Da && (e2 -= u2 * Da), Ma(i2 - o2) < Da && (i2 -= o2 * Da), r2 = Ft(e2, r2, i2, a2), n2.point(u2, r2), n2.lineEnd(), n2.lineStart(), n2.point(o2, r2), t2 = 0), n2.point(e2 = i2, r2 = a2), u2 = o2;
    }, lineEnd: function() {
      n2.lineEnd(), e2 = r2 = NaN;
    }, clean: function() {
      return 2 - t2;
    } };
  }
  function Ft(n2, t2, e2, r2) {
    var u2, i2, a2 = Math.sin(n2 - e2);
    return Ma(a2) > Da ? Math.atan((Math.sin(t2) * (i2 = Math.cos(r2)) * Math.sin(e2) - Math.sin(r2) * (u2 = Math.cos(t2)) * Math.sin(n2)) / (u2 * i2 * a2)) : (t2 + r2) / 2;
  }
  function Ht(n2, t2, e2, r2) {
    var u2;
    if (null == n2) u2 = e2 * Ha, r2.point(-ja, u2), r2.point(0, u2), r2.point(ja, u2), r2.point(ja, 0), r2.point(ja, -u2), r2.point(0, -u2), r2.point(-ja, -u2), r2.point(-ja, 0), r2.point(-ja, u2);
    else if (Ma(n2[0] - t2[0]) > Da) {
      var i2 = n2[0] < t2[0] ? ja : -ja;
      u2 = e2 * i2 / 2, r2.point(-i2, u2), r2.point(0, u2), r2.point(i2, u2);
    } else r2.point(t2[0], t2[1]);
  }
  function Ot(n2, t2) {
    var e2 = n2[0], r2 = n2[1], u2 = [Math.sin(e2), -Math.cos(e2), 0], i2 = 0, a2 = 0;
    So.reset();
    for (var o2 = 0, l2 = t2.length; l2 > o2; ++o2) {
      var c2 = t2[o2], s2 = c2.length;
      if (s2) for (var f2 = c2[0], h2 = f2[0], g2 = f2[1] / 2 + ja / 4, p2 = Math.sin(g2), v2 = Math.cos(g2), d2 = 1; ; ) {
        d2 === s2 && (d2 = 0), n2 = c2[d2];
        var m2 = n2[0], y2 = n2[1] / 2 + ja / 4, M2 = Math.sin(y2), x2 = Math.cos(y2), b2 = m2 - h2, _6 = b2 >= 0 ? 1 : -1, w2 = _6 * b2, S2 = w2 > ja, k2 = p2 * M2;
        if (So.add(Math.atan2(k2 * _6 * Math.sin(w2), v2 * x2 + k2 * Math.cos(w2))), i2 += S2 ? b2 + _6 * Ua : b2, S2 ^ h2 >= e2 ^ m2 >= e2) {
          var N2 = yt(dt(f2), dt(n2));
          bt(N2);
          var E2 = yt(u2, N2);
          bt(E2);
          var A2 = (S2 ^ b2 >= 0 ? -1 : 1) * tn(E2[2]);
          (r2 > A2 || r2 === A2 && (N2[0] || N2[1])) && (a2 += S2 ^ b2 >= 0 ? 1 : -1);
        }
        if (!d2++) break;
        h2 = m2, p2 = M2, v2 = x2, f2 = n2;
      }
    }
    return (-Da > i2 || Da > i2 && 0 > So) ^ 1 & a2;
  }
  function It(n2) {
    function t2(n3, t3) {
      return Math.cos(n3) * Math.cos(t3) > i2;
    }
    function e2(n3) {
      var e3, i3, l3, c2, s2;
      return { lineStart: function() {
        c2 = l3 = false, s2 = 1;
      }, point: function(f2, h2) {
        var g2, p2 = [f2, h2], v2 = t2(f2, h2), d2 = a2 ? v2 ? 0 : u2(f2, h2) : v2 ? u2(f2 + (0 > f2 ? ja : -ja), h2) : 0;
        if (!e3 && (c2 = l3 = v2) && n3.lineStart(), v2 !== l3 && (g2 = r2(e3, p2), (wt(e3, g2) || wt(p2, g2)) && (p2[0] += Da, p2[1] += Da, v2 = t2(p2[0], p2[1]))), v2 !== l3) s2 = 0, v2 ? (n3.lineStart(), g2 = r2(p2, e3), n3.point(g2[0], g2[1])) : (g2 = r2(e3, p2), n3.point(g2[0], g2[1]), n3.lineEnd()), e3 = g2;
        else if (o2 && e3 && a2 ^ v2) {
          var m2;
          d2 & i3 || !(m2 = r2(p2, e3, true)) || (s2 = 0, a2 ? (n3.lineStart(), n3.point(m2[0][0], m2[0][1]), n3.point(m2[1][0], m2[1][1]), n3.lineEnd()) : (n3.point(m2[1][0], m2[1][1]), n3.lineEnd(), n3.lineStart(), n3.point(m2[0][0], m2[0][1])));
        }
        !v2 || e3 && wt(e3, p2) || n3.point(p2[0], p2[1]), e3 = p2, l3 = v2, i3 = d2;
      }, lineEnd: function() {
        l3 && n3.lineEnd(), e3 = null;
      }, clean: function() {
        return s2 | (c2 && l3) << 1;
      } };
    }
    function r2(n3, t3, e3) {
      var r3 = dt(n3), u3 = dt(t3), a3 = [1, 0, 0], o3 = yt(r3, u3), l3 = mt(o3, o3), c2 = o3[0], s2 = l3 - c2 * c2;
      if (!s2) return !e3 && n3;
      var f2 = i2 * l3 / s2, h2 = -i2 * c2 / s2, g2 = yt(a3, o3), p2 = xt(a3, f2), v2 = xt(o3, h2);
      Mt(p2, v2);
      var d2 = g2, m2 = mt(p2, d2), y2 = mt(d2, d2), M2 = m2 * m2 - y2 * (mt(p2, p2) - 1);
      if (!(0 > M2)) {
        var x2 = Math.sqrt(M2), b2 = xt(d2, (-m2 - x2) / y2);
        if (Mt(b2, p2), b2 = _t(b2), !e3) return b2;
        var _6, w2 = n3[0], S2 = t3[0], k2 = n3[1], N2 = t3[1];
        w2 > S2 && (_6 = w2, w2 = S2, S2 = _6);
        var E2 = S2 - w2, A2 = Ma(E2 - ja) < Da, C2 = A2 || Da > E2;
        if (!A2 && k2 > N2 && (_6 = k2, k2 = N2, N2 = _6), C2 ? A2 ? k2 + N2 > 0 ^ b2[1] < (Ma(b2[0] - w2) < Da ? k2 : N2) : k2 <= b2[1] && b2[1] <= N2 : E2 > ja ^ (w2 <= b2[0] && b2[0] <= S2)) {
          var z2 = xt(d2, (-m2 + x2) / y2);
          return Mt(z2, p2), [b2, _t(z2)];
        }
      }
    }
    function u2(t3, e3) {
      var r3 = a2 ? n2 : ja - n2, u3 = 0;
      return -r3 > t3 ? u3 |= 1 : t3 > r3 && (u3 |= 2), -r3 > e3 ? u3 |= 4 : e3 > r3 && (u3 |= 8), u3;
    }
    var i2 = Math.cos(n2), a2 = i2 > 0, o2 = Ma(i2) > Da, l2 = ve(n2, 6 * Oa);
    return Rt(t2, e2, l2, a2 ? [0, -n2] : [-ja, n2 - ja]);
  }
  function Yt(n2, t2, e2, r2) {
    return function(u2) {
      var i2, a2 = u2.a, o2 = u2.b, l2 = a2.x, c2 = a2.y, s2 = o2.x, f2 = o2.y, h2 = 0, g2 = 1, p2 = s2 - l2, v2 = f2 - c2;
      if (i2 = n2 - l2, p2 || !(i2 > 0)) {
        if (i2 /= p2, 0 > p2) {
          if (h2 > i2) return;
          g2 > i2 && (g2 = i2);
        } else if (p2 > 0) {
          if (i2 > g2) return;
          i2 > h2 && (h2 = i2);
        }
        if (i2 = e2 - l2, p2 || !(0 > i2)) {
          if (i2 /= p2, 0 > p2) {
            if (i2 > g2) return;
            i2 > h2 && (h2 = i2);
          } else if (p2 > 0) {
            if (h2 > i2) return;
            g2 > i2 && (g2 = i2);
          }
          if (i2 = t2 - c2, v2 || !(i2 > 0)) {
            if (i2 /= v2, 0 > v2) {
              if (h2 > i2) return;
              g2 > i2 && (g2 = i2);
            } else if (v2 > 0) {
              if (i2 > g2) return;
              i2 > h2 && (h2 = i2);
            }
            if (i2 = r2 - c2, v2 || !(0 > i2)) {
              if (i2 /= v2, 0 > v2) {
                if (i2 > g2) return;
                i2 > h2 && (h2 = i2);
              } else if (v2 > 0) {
                if (h2 > i2) return;
                g2 > i2 && (g2 = i2);
              }
              return h2 > 0 && (u2.a = { x: l2 + h2 * p2, y: c2 + h2 * v2 }), 1 > g2 && (u2.b = { x: l2 + g2 * p2, y: c2 + g2 * v2 }), u2;
            }
          }
        }
      }
    };
  }
  function Zt(n2, t2, e2, r2) {
    function u2(r3, u3) {
      return Ma(r3[0] - n2) < Da ? u3 > 0 ? 0 : 3 : Ma(r3[0] - e2) < Da ? u3 > 0 ? 2 : 1 : Ma(r3[1] - t2) < Da ? u3 > 0 ? 1 : 0 : u3 > 0 ? 3 : 2;
    }
    function i2(n3, t3) {
      return a2(n3.x, t3.x);
    }
    function a2(n3, t3) {
      var e3 = u2(n3, 1), r3 = u2(t3, 1);
      return e3 !== r3 ? e3 - r3 : 0 === e3 ? t3[1] - n3[1] : 1 === e3 ? n3[0] - t3[0] : 2 === e3 ? n3[1] - t3[1] : t3[0] - n3[0];
    }
    return function(o2) {
      function l2(n3) {
        for (var t3 = 0, e3 = d2.length, r3 = n3[1], u3 = 0; e3 > u3; ++u3) for (var i3, a3 = 1, o3 = d2[u3], l3 = o3.length, c3 = o3[0]; l3 > a3; ++a3) i3 = o3[a3], c3[1] <= r3 ? i3[1] > r3 && Q(c3, i3, n3) > 0 && ++t3 : i3[1] <= r3 && Q(c3, i3, n3) < 0 && --t3, c3 = i3;
        return 0 !== t3;
      }
      function c2(i3, o3, l3, c3) {
        var s3 = 0, f3 = 0;
        if (null == i3 || (s3 = u2(i3, l3)) !== (f3 = u2(o3, l3)) || a2(i3, o3) < 0 ^ l3 > 0) {
          do
            c3.point(0 === s3 || 3 === s3 ? n2 : e2, s3 > 1 ? r2 : t2);
          while ((s3 = (s3 + l3 + 4) % 4) !== f3);
        } else c3.point(o3[0], o3[1]);
      }
      function s2(u3, i3) {
        return u3 >= n2 && e2 >= u3 && i3 >= t2 && r2 >= i3;
      }
      function f2(n3, t3) {
        s2(n3, t3) && o2.point(n3, t3);
      }
      function h2() {
        C2.point = p2, d2 && d2.push(m2 = []), S2 = true, w2 = false, b2 = _6 = NaN;
      }
      function g2() {
        v2 && (p2(y2, M2), x2 && w2 && E2.rejoin(), v2.push(E2.buffer())), C2.point = f2, w2 && o2.lineEnd();
      }
      function p2(n3, t3) {
        n3 = Math.max(-Fo, Math.min(Fo, n3)), t3 = Math.max(-Fo, Math.min(Fo, t3));
        var e3 = s2(n3, t3);
        if (d2 && m2.push([n3, t3]), S2) y2 = n3, M2 = t3, x2 = e3, S2 = false, e3 && (o2.lineStart(), o2.point(n3, t3));
        else if (e3 && w2) o2.point(n3, t3);
        else {
          var r3 = { a: { x: b2, y: _6 }, b: { x: n3, y: t3 } };
          A2(r3) ? (w2 || (o2.lineStart(), o2.point(r3.a.x, r3.a.y)), o2.point(r3.b.x, r3.b.y), e3 || o2.lineEnd(), k2 = false) : e3 && (o2.lineStart(), o2.point(n3, t3), k2 = false);
        }
        b2 = n3, _6 = t3, w2 = e3;
      }
      var v2, d2, m2, y2, M2, x2, b2, _6, w2, S2, k2, N2 = o2, E2 = Pt(), A2 = Yt(n2, t2, e2, r2), C2 = { point: f2, lineStart: h2, lineEnd: g2, polygonStart: function() {
        o2 = E2, v2 = [], d2 = [], k2 = true;
      }, polygonEnd: function() {
        o2 = N2, v2 = oa.merge(v2);
        var t3 = l2([n2, r2]), e3 = k2 && t3, u3 = v2.length;
        (e3 || u3) && (o2.polygonStart(), e3 && (o2.lineStart(), c2(null, null, 1, o2), o2.lineEnd()), u3 && Lt(v2, i2, t3, c2, o2), o2.polygonEnd()), v2 = d2 = m2 = null;
      } };
      return C2;
    };
  }
  function Vt(n2) {
    var t2 = 0, e2 = ja / 3, r2 = oe(n2), u2 = r2(t2, e2);
    return u2.parallels = function(n3) {
      return arguments.length ? r2(t2 = n3[0] * ja / 180, e2 = n3[1] * ja / 180) : [t2 / ja * 180, e2 / ja * 180];
    }, u2;
  }
  function Xt(n2, t2) {
    function e2(n3, t3) {
      var e3 = Math.sqrt(i2 - 2 * u2 * Math.sin(t3)) / u2;
      return [e3 * Math.sin(n3 *= u2), a2 - e3 * Math.cos(n3)];
    }
    var r2 = Math.sin(n2), u2 = (r2 + Math.sin(t2)) / 2, i2 = 1 + r2 * (2 * u2 - r2), a2 = Math.sqrt(i2) / u2;
    return e2.invert = function(n3, t3) {
      var e3 = a2 - t3;
      return [Math.atan2(n3, e3) / u2, tn((i2 - (n3 * n3 + e3 * e3) * u2 * u2) / (2 * u2))];
    }, e2;
  }
  function $t() {
    function n2(n3, t3) {
      Oo += u2 * n3 - r2 * t3, r2 = n3, u2 = t3;
    }
    var t2, e2, r2, u2;
    Xo.point = function(i2, a2) {
      Xo.point = n2, t2 = r2 = i2, e2 = u2 = a2;
    }, Xo.lineEnd = function() {
      n2(t2, e2);
    };
  }
  function Bt(n2, t2) {
    Io > n2 && (Io = n2), n2 > Zo && (Zo = n2), Yo > t2 && (Yo = t2), t2 > Vo && (Vo = t2);
  }
  function Wt() {
    function n2(n3, t3) {
      a2.push("M", n3, ",", t3, i2);
    }
    function t2(n3, t3) {
      a2.push("M", n3, ",", t3), o2.point = e2;
    }
    function e2(n3, t3) {
      a2.push("L", n3, ",", t3);
    }
    function r2() {
      o2.point = n2;
    }
    function u2() {
      a2.push("Z");
    }
    var i2 = Jt(4.5), a2 = [], o2 = { point: n2, lineStart: function() {
      o2.point = t2;
    }, lineEnd: r2, polygonStart: function() {
      o2.lineEnd = u2;
    }, polygonEnd: function() {
      o2.lineEnd = r2, o2.point = n2;
    }, pointRadius: function(n3) {
      return i2 = Jt(n3), o2;
    }, result: function() {
      if (a2.length) {
        var n3 = a2.join("");
        return a2 = [], n3;
      }
    } };
    return o2;
  }
  function Jt(n2) {
    return "m0," + n2 + "a" + n2 + "," + n2 + " 0 1,1 0," + -2 * n2 + "a" + n2 + "," + n2 + " 0 1,1 0," + 2 * n2 + "z";
  }
  function Gt(n2, t2) {
    Ao += n2, Co += t2, ++zo;
  }
  function Kt() {
    function n2(n3, r2) {
      var u2 = n3 - t2, i2 = r2 - e2, a2 = Math.sqrt(u2 * u2 + i2 * i2);
      Lo += a2 * (t2 + n3) / 2, qo += a2 * (e2 + r2) / 2, To += a2, Gt(t2 = n3, e2 = r2);
    }
    var t2, e2;
    Bo.point = function(r2, u2) {
      Bo.point = n2, Gt(t2 = r2, e2 = u2);
    };
  }
  function Qt() {
    Bo.point = Gt;
  }
  function ne() {
    function n2(n3, t3) {
      var e3 = n3 - r2, i2 = t3 - u2, a2 = Math.sqrt(e3 * e3 + i2 * i2);
      Lo += a2 * (r2 + n3) / 2, qo += a2 * (u2 + t3) / 2, To += a2, a2 = u2 * n3 - r2 * t3, Ro += a2 * (r2 + n3), Do += a2 * (u2 + t3), Po += 3 * a2, Gt(r2 = n3, u2 = t3);
    }
    var t2, e2, r2, u2;
    Bo.point = function(i2, a2) {
      Bo.point = n2, Gt(t2 = r2 = i2, e2 = u2 = a2);
    }, Bo.lineEnd = function() {
      n2(t2, e2);
    };
  }
  function te(n2) {
    function t2(t3, e3) {
      n2.moveTo(t3 + a2, e3), n2.arc(t3, e3, a2, 0, Ua);
    }
    function e2(t3, e3) {
      n2.moveTo(t3, e3), o2.point = r2;
    }
    function r2(t3, e3) {
      n2.lineTo(t3, e3);
    }
    function u2() {
      o2.point = t2;
    }
    function i2() {
      n2.closePath();
    }
    var a2 = 4.5, o2 = { point: t2, lineStart: function() {
      o2.point = e2;
    }, lineEnd: u2, polygonStart: function() {
      o2.lineEnd = i2;
    }, polygonEnd: function() {
      o2.lineEnd = u2, o2.point = t2;
    }, pointRadius: function(n3) {
      return a2 = n3, o2;
    }, result: b };
    return o2;
  }
  function ee(n2) {
    function t2(n3) {
      return (o2 ? r2 : e2)(n3);
    }
    function e2(t3) {
      return ie(t3, function(e3, r3) {
        e3 = n2(e3, r3), t3.point(e3[0], e3[1]);
      });
    }
    function r2(t3) {
      function e3(e4, r4) {
        e4 = n2(e4, r4), t3.point(e4[0], e4[1]);
      }
      function r3() {
        M2 = NaN, S2.point = i3, t3.lineStart();
      }
      function i3(e4, r4) {
        var i4 = dt([e4, r4]), a4 = n2(e4, r4);
        u2(M2, x2, y2, b2, _6, w2, M2 = a4[0], x2 = a4[1], y2 = e4, b2 = i4[0], _6 = i4[1], w2 = i4[2], o2, t3), t3.point(M2, x2);
      }
      function a3() {
        S2.point = e3, t3.lineEnd();
      }
      function l2() {
        r3(), S2.point = c2, S2.lineEnd = s2;
      }
      function c2(n3, t4) {
        i3(f2 = n3, h2 = t4), g2 = M2, p2 = x2, v2 = b2, d2 = _6, m2 = w2, S2.point = i3;
      }
      function s2() {
        u2(M2, x2, y2, b2, _6, w2, g2, p2, f2, v2, d2, m2, o2, t3), S2.lineEnd = a3, a3();
      }
      var f2, h2, g2, p2, v2, d2, m2, y2, M2, x2, b2, _6, w2, S2 = { point: e3, lineStart: r3, lineEnd: a3, polygonStart: function() {
        t3.polygonStart(), S2.lineStart = l2;
      }, polygonEnd: function() {
        t3.polygonEnd(), S2.lineStart = r3;
      } };
      return S2;
    }
    function u2(t3, e3, r3, o3, l2, c2, s2, f2, h2, g2, p2, v2, d2, m2) {
      var y2 = s2 - t3, M2 = f2 - e3, x2 = y2 * y2 + M2 * M2;
      if (x2 > 4 * i2 && d2--) {
        var b2 = o3 + g2, _6 = l2 + p2, w2 = c2 + v2, S2 = Math.sqrt(b2 * b2 + _6 * _6 + w2 * w2), k2 = Math.asin(w2 /= S2), N2 = Ma(Ma(w2) - 1) < Da || Ma(r3 - h2) < Da ? (r3 + h2) / 2 : Math.atan2(_6, b2), E2 = n2(N2, k2), A2 = E2[0], C2 = E2[1], z2 = A2 - t3, L2 = C2 - e3, q2 = M2 * z2 - y2 * L2;
        (q2 * q2 / x2 > i2 || Ma((y2 * z2 + M2 * L2) / x2 - 0.5) > 0.3 || a2 > o3 * g2 + l2 * p2 + c2 * v2) && (u2(t3, e3, r3, o3, l2, c2, A2, C2, N2, b2 /= S2, _6 /= S2, w2, d2, m2), m2.point(A2, C2), u2(A2, C2, N2, b2, _6, w2, s2, f2, h2, g2, p2, v2, d2, m2));
      }
    }
    var i2 = 0.5, a2 = Math.cos(30 * Oa), o2 = 16;
    return t2.precision = function(n3) {
      return arguments.length ? (o2 = (i2 = n3 * n3) > 0 && 16, t2) : Math.sqrt(i2);
    }, t2;
  }
  function re(n2) {
    var t2 = ee(function(t3, e2) {
      return n2([t3 * Ia, e2 * Ia]);
    });
    return function(n3) {
      return le(t2(n3));
    };
  }
  function ue(n2) {
    this.stream = n2;
  }
  function ie(n2, t2) {
    return { point: t2, sphere: function() {
      n2.sphere();
    }, lineStart: function() {
      n2.lineStart();
    }, lineEnd: function() {
      n2.lineEnd();
    }, polygonStart: function() {
      n2.polygonStart();
    }, polygonEnd: function() {
      n2.polygonEnd();
    } };
  }
  function ae(n2) {
    return oe(function() {
      return n2;
    })();
  }
  function oe(n2) {
    function t2(n3) {
      return n3 = o2(n3[0] * Oa, n3[1] * Oa), [n3[0] * h2 + l2, c2 - n3[1] * h2];
    }
    function e2(n3) {
      return n3 = o2.invert((n3[0] - l2) / h2, (c2 - n3[1]) / h2), n3 && [n3[0] * Ia, n3[1] * Ia];
    }
    function r2() {
      o2 = Ct(a2 = fe(m2, M2, x2), i2);
      var n3 = i2(v2, d2);
      return l2 = g2 - n3[0] * h2, c2 = p2 + n3[1] * h2, u2();
    }
    function u2() {
      return s2 && (s2.valid = false, s2 = null), t2;
    }
    var i2, a2, o2, l2, c2, s2, f2 = ee(function(n3, t3) {
      return n3 = i2(n3, t3), [n3[0] * h2 + l2, c2 - n3[1] * h2];
    }), h2 = 150, g2 = 480, p2 = 250, v2 = 0, d2 = 0, m2 = 0, M2 = 0, x2 = 0, b2 = Uo, _6 = y, w2 = null, S2 = null;
    return t2.stream = function(n3) {
      return s2 && (s2.valid = false), s2 = le(b2(a2, f2(_6(n3)))), s2.valid = true, s2;
    }, t2.clipAngle = function(n3) {
      return arguments.length ? (b2 = null == n3 ? (w2 = n3, Uo) : It((w2 = +n3) * Oa), u2()) : w2;
    }, t2.clipExtent = function(n3) {
      return arguments.length ? (S2 = n3, _6 = n3 ? Zt(n3[0][0], n3[0][1], n3[1][0], n3[1][1]) : y, u2()) : S2;
    }, t2.scale = function(n3) {
      return arguments.length ? (h2 = +n3, r2()) : h2;
    }, t2.translate = function(n3) {
      return arguments.length ? (g2 = +n3[0], p2 = +n3[1], r2()) : [g2, p2];
    }, t2.center = function(n3) {
      return arguments.length ? (v2 = n3[0] % 360 * Oa, d2 = n3[1] % 360 * Oa, r2()) : [v2 * Ia, d2 * Ia];
    }, t2.rotate = function(n3) {
      return arguments.length ? (m2 = n3[0] % 360 * Oa, M2 = n3[1] % 360 * Oa, x2 = n3.length > 2 ? n3[2] % 360 * Oa : 0, r2()) : [m2 * Ia, M2 * Ia, x2 * Ia];
    }, oa.rebind(t2, f2, "precision"), function() {
      return i2 = n2.apply(this, arguments), t2.invert = i2.invert && e2, r2();
    };
  }
  function le(n2) {
    return ie(n2, function(t2, e2) {
      n2.point(t2 * Oa, e2 * Oa);
    });
  }
  function ce(n2, t2) {
    return [n2, t2];
  }
  function se(n2, t2) {
    return [n2 > ja ? n2 - Ua : -ja > n2 ? n2 + Ua : n2, t2];
  }
  function fe(n2, t2, e2) {
    return n2 ? t2 || e2 ? Ct(ge(n2), pe(t2, e2)) : ge(n2) : t2 || e2 ? pe(t2, e2) : se;
  }
  function he(n2) {
    return function(t2, e2) {
      return t2 += n2, [t2 > ja ? t2 - Ua : -ja > t2 ? t2 + Ua : t2, e2];
    };
  }
  function ge(n2) {
    var t2 = he(n2);
    return t2.invert = he(-n2), t2;
  }
  function pe(n2, t2) {
    function e2(n3, t3) {
      var e3 = Math.cos(t3), o2 = Math.cos(n3) * e3, l2 = Math.sin(n3) * e3, c2 = Math.sin(t3), s2 = c2 * r2 + o2 * u2;
      return [Math.atan2(l2 * i2 - s2 * a2, o2 * r2 - c2 * u2), tn(s2 * i2 + l2 * a2)];
    }
    var r2 = Math.cos(n2), u2 = Math.sin(n2), i2 = Math.cos(t2), a2 = Math.sin(t2);
    return e2.invert = function(n3, t3) {
      var e3 = Math.cos(t3), o2 = Math.cos(n3) * e3, l2 = Math.sin(n3) * e3, c2 = Math.sin(t3), s2 = c2 * i2 - l2 * a2;
      return [Math.atan2(l2 * i2 + c2 * a2, o2 * r2 + s2 * u2), tn(s2 * r2 - o2 * u2)];
    }, e2;
  }
  function ve(n2, t2) {
    var e2 = Math.cos(n2), r2 = Math.sin(n2);
    return function(u2, i2, a2, o2) {
      var l2 = a2 * t2;
      null != u2 ? (u2 = de(e2, u2), i2 = de(e2, i2), (a2 > 0 ? i2 > u2 : u2 > i2) && (u2 += a2 * Ua)) : (u2 = n2 + a2 * Ua, i2 = n2 - 0.5 * l2);
      for (var c2, s2 = u2; a2 > 0 ? s2 > i2 : i2 > s2; s2 -= l2) o2.point((c2 = _t([e2, -r2 * Math.cos(s2), -r2 * Math.sin(s2)]))[0], c2[1]);
    };
  }
  function de(n2, t2) {
    var e2 = dt(t2);
    e2[0] -= n2, bt(e2);
    var r2 = nn(-e2[1]);
    return ((-e2[2] < 0 ? -r2 : r2) + 2 * Math.PI - Da) % (2 * Math.PI);
  }
  function me(n2, t2, e2) {
    var r2 = oa.range(n2, t2 - Da, e2).concat(t2);
    return function(n3) {
      return r2.map(function(t3) {
        return [n3, t3];
      });
    };
  }
  function ye(n2, t2, e2) {
    var r2 = oa.range(n2, t2 - Da, e2).concat(t2);
    return function(n3) {
      return r2.map(function(t3) {
        return [t3, n3];
      });
    };
  }
  function Me(n2) {
    return n2.source;
  }
  function xe(n2) {
    return n2.target;
  }
  function be(n2, t2, e2, r2) {
    var u2 = Math.cos(t2), i2 = Math.sin(t2), a2 = Math.cos(r2), o2 = Math.sin(r2), l2 = u2 * Math.cos(n2), c2 = u2 * Math.sin(n2), s2 = a2 * Math.cos(e2), f2 = a2 * Math.sin(e2), h2 = 2 * Math.asin(Math.sqrt(an(r2 - t2) + u2 * a2 * an(e2 - n2))), g2 = 1 / Math.sin(h2), p2 = h2 ? function(n3) {
      var t3 = Math.sin(n3 *= h2) * g2, e3 = Math.sin(h2 - n3) * g2, r3 = e3 * l2 + t3 * s2, u3 = e3 * c2 + t3 * f2, a3 = e3 * i2 + t3 * o2;
      return [Math.atan2(u3, r3) * Ia, Math.atan2(a3, Math.sqrt(r3 * r3 + u3 * u3)) * Ia];
    } : function() {
      return [n2 * Ia, t2 * Ia];
    };
    return p2.distance = h2, p2;
  }
  function _e() {
    function n2(n3, u2) {
      var i2 = Math.sin(u2 *= Oa), a2 = Math.cos(u2), o2 = Ma((n3 *= Oa) - t2), l2 = Math.cos(o2);
      Wo += Math.atan2(Math.sqrt((o2 = a2 * Math.sin(o2)) * o2 + (o2 = r2 * i2 - e2 * a2 * l2) * o2), e2 * i2 + r2 * a2 * l2), t2 = n3, e2 = i2, r2 = a2;
    }
    var t2, e2, r2;
    Jo.point = function(u2, i2) {
      t2 = u2 * Oa, e2 = Math.sin(i2 *= Oa), r2 = Math.cos(i2), Jo.point = n2;
    }, Jo.lineEnd = function() {
      Jo.point = Jo.lineEnd = b;
    };
  }
  function we(n2, t2) {
    function e2(t3, e3) {
      var r2 = Math.cos(t3), u2 = Math.cos(e3), i2 = n2(r2 * u2);
      return [i2 * u2 * Math.sin(t3), i2 * Math.sin(e3)];
    }
    return e2.invert = function(n3, e3) {
      var r2 = Math.sqrt(n3 * n3 + e3 * e3), u2 = t2(r2), i2 = Math.sin(u2), a2 = Math.cos(u2);
      return [Math.atan2(n3 * i2, r2 * a2), Math.asin(r2 && e3 * i2 / r2)];
    }, e2;
  }
  function Se(n2, t2) {
    function e2(n3, t3) {
      a2 > 0 ? -Ha + Da > t3 && (t3 = -Ha + Da) : t3 > Ha - Da && (t3 = Ha - Da);
      var e3 = a2 / Math.pow(u2(t3), i2);
      return [e3 * Math.sin(i2 * n3), a2 - e3 * Math.cos(i2 * n3)];
    }
    var r2 = Math.cos(n2), u2 = function(n3) {
      return Math.tan(ja / 4 + n3 / 2);
    }, i2 = n2 === t2 ? Math.sin(n2) : Math.log(r2 / Math.cos(t2)) / Math.log(u2(t2) / u2(n2)), a2 = r2 * Math.pow(u2(n2), i2) / i2;
    return i2 ? (e2.invert = function(n3, t3) {
      var e3 = a2 - t3, r3 = K(i2) * Math.sqrt(n3 * n3 + e3 * e3);
      return [Math.atan2(n3, e3) / i2, 2 * Math.atan(Math.pow(a2 / r3, 1 / i2)) - Ha];
    }, e2) : Ne;
  }
  function ke(n2, t2) {
    function e2(n3, t3) {
      var e3 = i2 - t3;
      return [e3 * Math.sin(u2 * n3), i2 - e3 * Math.cos(u2 * n3)];
    }
    var r2 = Math.cos(n2), u2 = n2 === t2 ? Math.sin(n2) : (r2 - Math.cos(t2)) / (t2 - n2), i2 = r2 / u2 + n2;
    return Ma(u2) < Da ? ce : (e2.invert = function(n3, t3) {
      var e3 = i2 - t3;
      return [Math.atan2(n3, e3) / u2, i2 - K(u2) * Math.sqrt(n3 * n3 + e3 * e3)];
    }, e2);
  }
  function Ne(n2, t2) {
    return [n2, Math.log(Math.tan(ja / 4 + t2 / 2))];
  }
  function Ee(n2) {
    var t2, e2 = ae(n2), r2 = e2.scale, u2 = e2.translate, i2 = e2.clipExtent;
    return e2.scale = function() {
      var n3 = r2.apply(e2, arguments);
      return n3 === e2 ? t2 ? e2.clipExtent(null) : e2 : n3;
    }, e2.translate = function() {
      var n3 = u2.apply(e2, arguments);
      return n3 === e2 ? t2 ? e2.clipExtent(null) : e2 : n3;
    }, e2.clipExtent = function(n3) {
      var a2 = i2.apply(e2, arguments);
      if (a2 === e2) {
        if (t2 = null == n3) {
          var o2 = ja * r2(), l2 = u2();
          i2([[l2[0] - o2, l2[1] - o2], [l2[0] + o2, l2[1] + o2]]);
        }
      } else t2 && (a2 = null);
      return a2;
    }, e2.clipExtent(null);
  }
  function Ae(n2, t2) {
    return [Math.log(Math.tan(ja / 4 + t2 / 2)), -n2];
  }
  function Ce(n2) {
    return n2[0];
  }
  function ze(n2) {
    return n2[1];
  }
  function Le(n2) {
    for (var t2 = n2.length, e2 = [0, 1], r2 = 2, u2 = 2; t2 > u2; u2++) {
      for (; r2 > 1 && Q(n2[e2[r2 - 2]], n2[e2[r2 - 1]], n2[u2]) <= 0; ) --r2;
      e2[r2++] = u2;
    }
    return e2.slice(0, r2);
  }
  function qe(n2, t2) {
    return n2[0] - t2[0] || n2[1] - t2[1];
  }
  function Te(n2, t2, e2) {
    return (e2[0] - t2[0]) * (n2[1] - t2[1]) < (e2[1] - t2[1]) * (n2[0] - t2[0]);
  }
  function Re(n2, t2, e2, r2) {
    var u2 = n2[0], i2 = e2[0], a2 = t2[0] - u2, o2 = r2[0] - i2, l2 = n2[1], c2 = e2[1], s2 = t2[1] - l2, f2 = r2[1] - c2, h2 = (o2 * (l2 - c2) - f2 * (u2 - i2)) / (f2 * a2 - o2 * s2);
    return [u2 + h2 * a2, l2 + h2 * s2];
  }
  function De(n2) {
    var t2 = n2[0], e2 = n2[n2.length - 1];
    return !(t2[0] - e2[0] || t2[1] - e2[1]);
  }
  function Pe() {
    rr(this), this.edge = this.site = this.circle = null;
  }
  function je(n2) {
    var t2 = ll.pop() || new Pe();
    return t2.site = n2, t2;
  }
  function Ue(n2) {
    Be(n2), il.remove(n2), ll.push(n2), rr(n2);
  }
  function Fe(n2) {
    var t2 = n2.circle, e2 = t2.x, r2 = t2.cy, u2 = { x: e2, y: r2 }, i2 = n2.P, a2 = n2.N, o2 = [n2];
    Ue(n2);
    for (var l2 = i2; l2.circle && Ma(e2 - l2.circle.x) < Da && Ma(r2 - l2.circle.cy) < Da; ) i2 = l2.P, o2.unshift(l2), Ue(l2), l2 = i2;
    o2.unshift(l2), Be(l2);
    for (var c2 = a2; c2.circle && Ma(e2 - c2.circle.x) < Da && Ma(r2 - c2.circle.cy) < Da; ) a2 = c2.N, o2.push(c2), Ue(c2), c2 = a2;
    o2.push(c2), Be(c2);
    var s2, f2 = o2.length;
    for (s2 = 1; f2 > s2; ++s2) c2 = o2[s2], l2 = o2[s2 - 1], nr(c2.edge, l2.site, c2.site, u2);
    l2 = o2[0], c2 = o2[f2 - 1], c2.edge = Ke(l2.site, c2.site, null, u2), $e(l2), $e(c2);
  }
  function He(n2) {
    for (var t2, e2, r2, u2, i2 = n2.x, a2 = n2.y, o2 = il._; o2; ) if (r2 = Oe(o2, a2) - i2, r2 > Da) o2 = o2.L;
    else {
      if (u2 = i2 - Ie(o2, a2), !(u2 > Da)) {
        r2 > -Da ? (t2 = o2.P, e2 = o2) : u2 > -Da ? (t2 = o2, e2 = o2.N) : t2 = e2 = o2;
        break;
      }
      if (!o2.R) {
        t2 = o2;
        break;
      }
      o2 = o2.R;
    }
    var l2 = je(n2);
    if (il.insert(t2, l2), t2 || e2) {
      if (t2 === e2) return Be(t2), e2 = je(t2.site), il.insert(l2, e2), l2.edge = e2.edge = Ke(t2.site, l2.site), $e(t2), void $e(e2);
      if (!e2) return void (l2.edge = Ke(t2.site, l2.site));
      Be(t2), Be(e2);
      var c2 = t2.site, s2 = c2.x, f2 = c2.y, h2 = n2.x - s2, g2 = n2.y - f2, p2 = e2.site, v2 = p2.x - s2, d2 = p2.y - f2, m2 = 2 * (h2 * d2 - g2 * v2), y2 = h2 * h2 + g2 * g2, M2 = v2 * v2 + d2 * d2, x2 = { x: (d2 * y2 - g2 * M2) / m2 + s2, y: (h2 * M2 - v2 * y2) / m2 + f2 };
      nr(e2.edge, c2, p2, x2), l2.edge = Ke(c2, n2, null, x2), e2.edge = Ke(n2, p2, null, x2), $e(t2), $e(e2);
    }
  }
  function Oe(n2, t2) {
    var e2 = n2.site, r2 = e2.x, u2 = e2.y, i2 = u2 - t2;
    if (!i2) return r2;
    var a2 = n2.P;
    if (!a2) return -(1 / 0);
    e2 = a2.site;
    var o2 = e2.x, l2 = e2.y, c2 = l2 - t2;
    if (!c2) return o2;
    var s2 = o2 - r2, f2 = 1 / i2 - 1 / c2, h2 = s2 / c2;
    return f2 ? (-h2 + Math.sqrt(h2 * h2 - 2 * f2 * (s2 * s2 / (-2 * c2) - l2 + c2 / 2 + u2 - i2 / 2))) / f2 + r2 : (r2 + o2) / 2;
  }
  function Ie(n2, t2) {
    var e2 = n2.N;
    if (e2) return Oe(e2, t2);
    var r2 = n2.site;
    return r2.y === t2 ? r2.x : 1 / 0;
  }
  function Ye(n2) {
    this.site = n2, this.edges = [];
  }
  function Ze(n2) {
    for (var t2, e2, r2, u2, i2, a2, o2, l2, c2, s2, f2 = n2[0][0], h2 = n2[1][0], g2 = n2[0][1], p2 = n2[1][1], v2 = ul, d2 = v2.length; d2--; ) if (i2 = v2[d2], i2 && i2.prepare()) for (o2 = i2.edges, l2 = o2.length, a2 = 0; l2 > a2; ) s2 = o2[a2].end(), r2 = s2.x, u2 = s2.y, c2 = o2[++a2 % l2].start(), t2 = c2.x, e2 = c2.y, (Ma(r2 - t2) > Da || Ma(u2 - e2) > Da) && (o2.splice(a2, 0, new tr(Qe(i2.site, s2, Ma(r2 - f2) < Da && p2 - u2 > Da ? { x: f2, y: Ma(t2 - f2) < Da ? e2 : p2 } : Ma(u2 - p2) < Da && h2 - r2 > Da ? { x: Ma(e2 - p2) < Da ? t2 : h2, y: p2 } : Ma(r2 - h2) < Da && u2 - g2 > Da ? { x: h2, y: Ma(t2 - h2) < Da ? e2 : g2 } : Ma(u2 - g2) < Da && r2 - f2 > Da ? { x: Ma(e2 - g2) < Da ? t2 : f2, y: g2 } : null), i2.site, null)), ++l2);
  }
  function Ve(n2, t2) {
    return t2.angle - n2.angle;
  }
  function Xe() {
    rr(this), this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function $e(n2) {
    var t2 = n2.P, e2 = n2.N;
    if (t2 && e2) {
      var r2 = t2.site, u2 = n2.site, i2 = e2.site;
      if (r2 !== i2) {
        var a2 = u2.x, o2 = u2.y, l2 = r2.x - a2, c2 = r2.y - o2, s2 = i2.x - a2, f2 = i2.y - o2, h2 = 2 * (l2 * f2 - c2 * s2);
        if (!(h2 >= -Pa)) {
          var g2 = l2 * l2 + c2 * c2, p2 = s2 * s2 + f2 * f2, v2 = (f2 * g2 - c2 * p2) / h2, d2 = (l2 * p2 - s2 * g2) / h2, f2 = d2 + o2, m2 = cl.pop() || new Xe();
          m2.arc = n2, m2.site = u2, m2.x = v2 + a2, m2.y = f2 + Math.sqrt(v2 * v2 + d2 * d2), m2.cy = f2, n2.circle = m2;
          for (var y2 = null, M2 = ol._; M2; ) if (m2.y < M2.y || m2.y === M2.y && m2.x <= M2.x) {
            if (!M2.L) {
              y2 = M2.P;
              break;
            }
            M2 = M2.L;
          } else {
            if (!M2.R) {
              y2 = M2;
              break;
            }
            M2 = M2.R;
          }
          ol.insert(y2, m2), y2 || (al = m2);
        }
      }
    }
  }
  function Be(n2) {
    var t2 = n2.circle;
    t2 && (t2.P || (al = t2.N), ol.remove(t2), cl.push(t2), rr(t2), n2.circle = null);
  }
  function We(n2) {
    for (var t2, e2 = rl, r2 = Yt(n2[0][0], n2[0][1], n2[1][0], n2[1][1]), u2 = e2.length; u2--; ) t2 = e2[u2], (!Je(t2, n2) || !r2(t2) || Ma(t2.a.x - t2.b.x) < Da && Ma(t2.a.y - t2.b.y) < Da) && (t2.a = t2.b = null, e2.splice(u2, 1));
  }
  function Je(n2, t2) {
    var e2 = n2.b;
    if (e2) return true;
    var r2, u2, i2 = n2.a, a2 = t2[0][0], o2 = t2[1][0], l2 = t2[0][1], c2 = t2[1][1], s2 = n2.l, f2 = n2.r, h2 = s2.x, g2 = s2.y, p2 = f2.x, v2 = f2.y, d2 = (h2 + p2) / 2, m2 = (g2 + v2) / 2;
    if (v2 === g2) {
      if (a2 > d2 || d2 >= o2) return;
      if (h2 > p2) {
        if (i2) {
          if (i2.y >= c2) return;
        } else i2 = { x: d2, y: l2 };
        e2 = { x: d2, y: c2 };
      } else {
        if (i2) {
          if (i2.y < l2) return;
        } else i2 = { x: d2, y: c2 };
        e2 = { x: d2, y: l2 };
      }
    } else if (r2 = (h2 - p2) / (v2 - g2), u2 = m2 - r2 * d2, -1 > r2 || r2 > 1) if (h2 > p2) {
      if (i2) {
        if (i2.y >= c2) return;
      } else i2 = { x: (l2 - u2) / r2, y: l2 };
      e2 = { x: (c2 - u2) / r2, y: c2 };
    } else {
      if (i2) {
        if (i2.y < l2) return;
      } else i2 = { x: (c2 - u2) / r2, y: c2 };
      e2 = { x: (l2 - u2) / r2, y: l2 };
    }
    else if (v2 > g2) {
      if (i2) {
        if (i2.x >= o2) return;
      } else i2 = { x: a2, y: r2 * a2 + u2 };
      e2 = { x: o2, y: r2 * o2 + u2 };
    } else {
      if (i2) {
        if (i2.x < a2) return;
      } else i2 = { x: o2, y: r2 * o2 + u2 };
      e2 = { x: a2, y: r2 * a2 + u2 };
    }
    return n2.a = i2, n2.b = e2, true;
  }
  function Ge(n2, t2) {
    this.l = n2, this.r = t2, this.a = this.b = null;
  }
  function Ke(n2, t2, e2, r2) {
    var u2 = new Ge(n2, t2);
    return rl.push(u2), e2 && nr(u2, n2, t2, e2), r2 && nr(u2, t2, n2, r2), ul[n2.i].edges.push(new tr(u2, n2, t2)), ul[t2.i].edges.push(new tr(u2, t2, n2)), u2;
  }
  function Qe(n2, t2, e2) {
    var r2 = new Ge(n2, null);
    return r2.a = t2, r2.b = e2, rl.push(r2), r2;
  }
  function nr(n2, t2, e2, r2) {
    n2.a || n2.b ? n2.l === e2 ? n2.b = r2 : n2.a = r2 : (n2.a = r2, n2.l = t2, n2.r = e2);
  }
  function tr(n2, t2, e2) {
    var r2 = n2.a, u2 = n2.b;
    this.edge = n2, this.site = t2, this.angle = e2 ? Math.atan2(e2.y - t2.y, e2.x - t2.x) : n2.l === t2 ? Math.atan2(u2.x - r2.x, r2.y - u2.y) : Math.atan2(r2.x - u2.x, u2.y - r2.y);
  }
  function er() {
    this._ = null;
  }
  function rr(n2) {
    n2.U = n2.C = n2.L = n2.R = n2.P = n2.N = null;
  }
  function ur(n2, t2) {
    var e2 = t2, r2 = t2.R, u2 = e2.U;
    u2 ? u2.L === e2 ? u2.L = r2 : u2.R = r2 : n2._ = r2, r2.U = u2, e2.U = r2, e2.R = r2.L, e2.R && (e2.R.U = e2), r2.L = e2;
  }
  function ir(n2, t2) {
    var e2 = t2, r2 = t2.L, u2 = e2.U;
    u2 ? u2.L === e2 ? u2.L = r2 : u2.R = r2 : n2._ = r2, r2.U = u2, e2.U = r2, e2.L = r2.R, e2.L && (e2.L.U = e2), r2.R = e2;
  }
  function ar(n2) {
    for (; n2.L; ) n2 = n2.L;
    return n2;
  }
  function or(n2, t2) {
    var e2, r2, u2, i2 = n2.sort(lr).pop();
    for (rl = [], ul = new Array(n2.length), il = new er(), ol = new er(); ; ) if (u2 = al, i2 && (!u2 || i2.y < u2.y || i2.y === u2.y && i2.x < u2.x)) (i2.x !== e2 || i2.y !== r2) && (ul[i2.i] = new Ye(i2), He(i2), e2 = i2.x, r2 = i2.y), i2 = n2.pop();
    else {
      if (!u2) break;
      Fe(u2.arc);
    }
    t2 && (We(t2), Ze(t2));
    var a2 = { cells: ul, edges: rl };
    return il = ol = rl = ul = null, a2;
  }
  function lr(n2, t2) {
    return t2.y - n2.y || t2.x - n2.x;
  }
  function cr(n2, t2, e2) {
    return (n2.x - e2.x) * (t2.y - n2.y) - (n2.x - t2.x) * (e2.y - n2.y);
  }
  function sr(n2) {
    return n2.x;
  }
  function fr(n2) {
    return n2.y;
  }
  function hr() {
    return { leaf: true, nodes: [], point: null, x: null, y: null };
  }
  function gr(n2, t2, e2, r2, u2, i2) {
    if (!n2(t2, e2, r2, u2, i2)) {
      var a2 = 0.5 * (e2 + u2), o2 = 0.5 * (r2 + i2), l2 = t2.nodes;
      l2[0] && gr(n2, l2[0], e2, r2, a2, o2), l2[1] && gr(n2, l2[1], a2, r2, u2, o2), l2[2] && gr(n2, l2[2], e2, o2, a2, i2), l2[3] && gr(n2, l2[3], a2, o2, u2, i2);
    }
  }
  function pr(n2, t2, e2, r2, u2, i2, a2) {
    var o2, l2 = 1 / 0;
    return function c2(n3, s2, f2, h2, g2) {
      if (!(s2 > i2 || f2 > a2 || r2 > h2 || u2 > g2)) {
        if (p2 = n3.point) {
          var p2, v2 = t2 - n3.x, d2 = e2 - n3.y, m2 = v2 * v2 + d2 * d2;
          if (l2 > m2) {
            var y2 = Math.sqrt(l2 = m2);
            r2 = t2 - y2, u2 = e2 - y2, i2 = t2 + y2, a2 = e2 + y2, o2 = p2;
          }
        }
        for (var M2 = n3.nodes, x2 = 0.5 * (s2 + h2), b2 = 0.5 * (f2 + g2), _6 = t2 >= x2, w2 = e2 >= b2, S2 = w2 << 1 | _6, k2 = S2 + 4; k2 > S2; ++S2) if (n3 = M2[3 & S2]) switch (3 & S2) {
          case 0:
            c2(n3, s2, f2, x2, b2);
            break;
          case 1:
            c2(n3, x2, f2, h2, b2);
            break;
          case 2:
            c2(n3, s2, b2, x2, g2);
            break;
          case 3:
            c2(n3, x2, b2, h2, g2);
        }
      }
    }(n2, r2, u2, i2, a2), o2;
  }
  function vr(n2, t2) {
    n2 = oa.rgb(n2), t2 = oa.rgb(t2);
    var e2 = n2.r, r2 = n2.g, u2 = n2.b, i2 = t2.r - e2, a2 = t2.g - r2, o2 = t2.b - u2;
    return function(n3) {
      return "#" + bn(Math.round(e2 + i2 * n3)) + bn(Math.round(r2 + a2 * n3)) + bn(Math.round(u2 + o2 * n3));
    };
  }
  function dr(n2, t2) {
    var e2, r2 = {}, u2 = {};
    for (e2 in n2) e2 in t2 ? r2[e2] = Mr(n2[e2], t2[e2]) : u2[e2] = n2[e2];
    for (e2 in t2) e2 in n2 || (u2[e2] = t2[e2]);
    return function(n3) {
      for (e2 in r2) u2[e2] = r2[e2](n3);
      return u2;
    };
  }
  function mr(n2, t2) {
    return n2 = +n2, t2 = +t2, function(e2) {
      return n2 * (1 - e2) + t2 * e2;
    };
  }
  function yr(n2, t2) {
    var e2, r2, u2, i2 = fl.lastIndex = hl.lastIndex = 0, a2 = -1, o2 = [], l2 = [];
    for (n2 += "", t2 += ""; (e2 = fl.exec(n2)) && (r2 = hl.exec(t2)); ) (u2 = r2.index) > i2 && (u2 = t2.slice(i2, u2), o2[a2] ? o2[a2] += u2 : o2[++a2] = u2), (e2 = e2[0]) === (r2 = r2[0]) ? o2[a2] ? o2[a2] += r2 : o2[++a2] = r2 : (o2[++a2] = null, l2.push({ i: a2, x: mr(e2, r2) })), i2 = hl.lastIndex;
    return i2 < t2.length && (u2 = t2.slice(i2), o2[a2] ? o2[a2] += u2 : o2[++a2] = u2), o2.length < 2 ? l2[0] ? (t2 = l2[0].x, function(n3) {
      return t2(n3) + "";
    }) : function() {
      return t2;
    } : (t2 = l2.length, function(n3) {
      for (var e3, r3 = 0; t2 > r3; ++r3) o2[(e3 = l2[r3]).i] = e3.x(n3);
      return o2.join("");
    });
  }
  function Mr(n2, t2) {
    for (var e2, r2 = oa.interpolators.length; --r2 >= 0 && !(e2 = oa.interpolators[r2](n2, t2)); ) ;
    return e2;
  }
  function xr(n2, t2) {
    var e2, r2 = [], u2 = [], i2 = n2.length, a2 = t2.length, o2 = Math.min(n2.length, t2.length);
    for (e2 = 0; o2 > e2; ++e2) r2.push(Mr(n2[e2], t2[e2]));
    for (; i2 > e2; ++e2) u2[e2] = n2[e2];
    for (; a2 > e2; ++e2) u2[e2] = t2[e2];
    return function(n3) {
      for (e2 = 0; o2 > e2; ++e2) u2[e2] = r2[e2](n3);
      return u2;
    };
  }
  function br(n2) {
    return function(t2) {
      return 0 >= t2 ? 0 : t2 >= 1 ? 1 : n2(t2);
    };
  }
  function _r(n2) {
    return function(t2) {
      return 1 - n2(1 - t2);
    };
  }
  function wr(n2) {
    return function(t2) {
      return 0.5 * (0.5 > t2 ? n2(2 * t2) : 2 - n2(2 - 2 * t2));
    };
  }
  function Sr(n2) {
    return n2 * n2;
  }
  function kr(n2) {
    return n2 * n2 * n2;
  }
  function Nr(n2) {
    if (0 >= n2) return 0;
    if (n2 >= 1) return 1;
    var t2 = n2 * n2, e2 = t2 * n2;
    return 4 * (0.5 > n2 ? e2 : 3 * (n2 - t2) + e2 - 0.75);
  }
  function Er(n2) {
    return function(t2) {
      return Math.pow(t2, n2);
    };
  }
  function Ar(n2) {
    return 1 - Math.cos(n2 * Ha);
  }
  function Cr(n2) {
    return Math.pow(2, 10 * (n2 - 1));
  }
  function zr(n2) {
    return 1 - Math.sqrt(1 - n2 * n2);
  }
  function Lr(n2, t2) {
    var e2;
    return arguments.length < 2 && (t2 = 0.45), arguments.length ? e2 = t2 / Ua * Math.asin(1 / n2) : (n2 = 1, e2 = t2 / 4), function(r2) {
      return 1 + n2 * Math.pow(2, -10 * r2) * Math.sin((r2 - e2) * Ua / t2);
    };
  }
  function qr(n2) {
    return n2 || (n2 = 1.70158), function(t2) {
      return t2 * t2 * ((n2 + 1) * t2 - n2);
    };
  }
  function Tr(n2) {
    return 1 / 2.75 > n2 ? 7.5625 * n2 * n2 : 2 / 2.75 > n2 ? 7.5625 * (n2 -= 1.5 / 2.75) * n2 + 0.75 : 2.5 / 2.75 > n2 ? 7.5625 * (n2 -= 2.25 / 2.75) * n2 + 0.9375 : 7.5625 * (n2 -= 2.625 / 2.75) * n2 + 0.984375;
  }
  function Rr(n2, t2) {
    n2 = oa.hcl(n2), t2 = oa.hcl(t2);
    var e2 = n2.h, r2 = n2.c, u2 = n2.l, i2 = t2.h - e2, a2 = t2.c - r2, o2 = t2.l - u2;
    return isNaN(a2) && (a2 = 0, r2 = isNaN(r2) ? t2.c : r2), isNaN(i2) ? (i2 = 0, e2 = isNaN(e2) ? t2.h : e2) : i2 > 180 ? i2 -= 360 : -180 > i2 && (i2 += 360), function(n3) {
      return fn(e2 + i2 * n3, r2 + a2 * n3, u2 + o2 * n3) + "";
    };
  }
  function Dr(n2, t2) {
    n2 = oa.hsl(n2), t2 = oa.hsl(t2);
    var e2 = n2.h, r2 = n2.s, u2 = n2.l, i2 = t2.h - e2, a2 = t2.s - r2, o2 = t2.l - u2;
    return isNaN(a2) && (a2 = 0, r2 = isNaN(r2) ? t2.s : r2), isNaN(i2) ? (i2 = 0, e2 = isNaN(e2) ? t2.h : e2) : i2 > 180 ? i2 -= 360 : -180 > i2 && (i2 += 360), function(n3) {
      return cn(e2 + i2 * n3, r2 + a2 * n3, u2 + o2 * n3) + "";
    };
  }
  function Pr(n2, t2) {
    n2 = oa.lab(n2), t2 = oa.lab(t2);
    var e2 = n2.l, r2 = n2.a, u2 = n2.b, i2 = t2.l - e2, a2 = t2.a - r2, o2 = t2.b - u2;
    return function(n3) {
      return gn(e2 + i2 * n3, r2 + a2 * n3, u2 + o2 * n3) + "";
    };
  }
  function jr(n2, t2) {
    return t2 -= n2, function(e2) {
      return Math.round(n2 + t2 * e2);
    };
  }
  function Ur(n2) {
    var t2 = [n2.a, n2.b], e2 = [n2.c, n2.d], r2 = Hr(t2), u2 = Fr(t2, e2), i2 = Hr(Or(e2, t2, -u2)) || 0;
    t2[0] * e2[1] < e2[0] * t2[1] && (t2[0] *= -1, t2[1] *= -1, r2 *= -1, u2 *= -1), this.rotate = (r2 ? Math.atan2(t2[1], t2[0]) : Math.atan2(-e2[0], e2[1])) * Ia, this.translate = [n2.e, n2.f], this.scale = [r2, i2], this.skew = i2 ? Math.atan2(u2, i2) * Ia : 0;
  }
  function Fr(n2, t2) {
    return n2[0] * t2[0] + n2[1] * t2[1];
  }
  function Hr(n2) {
    var t2 = Math.sqrt(Fr(n2, n2));
    return t2 && (n2[0] /= t2, n2[1] /= t2), t2;
  }
  function Or(n2, t2, e2) {
    return n2[0] += e2 * t2[0], n2[1] += e2 * t2[1], n2;
  }
  function Ir(n2) {
    return n2.length ? n2.pop() + "," : "";
  }
  function Yr(n2, t2, e2, r2) {
    if (n2[0] !== t2[0] || n2[1] !== t2[1]) {
      var u2 = e2.push("translate(", null, ",", null, ")");
      r2.push({ i: u2 - 4, x: mr(n2[0], t2[0]) }, { i: u2 - 2, x: mr(n2[1], t2[1]) });
    } else (t2[0] || t2[1]) && e2.push("translate(" + t2 + ")");
  }
  function Zr(n2, t2, e2, r2) {
    n2 !== t2 ? (n2 - t2 > 180 ? t2 += 360 : t2 - n2 > 180 && (n2 += 360), r2.push({ i: e2.push(Ir(e2) + "rotate(", null, ")") - 2, x: mr(n2, t2) })) : t2 && e2.push(Ir(e2) + "rotate(" + t2 + ")");
  }
  function Vr(n2, t2, e2, r2) {
    n2 !== t2 ? r2.push({ i: e2.push(Ir(e2) + "skewX(", null, ")") - 2, x: mr(n2, t2) }) : t2 && e2.push(Ir(e2) + "skewX(" + t2 + ")");
  }
  function Xr(n2, t2, e2, r2) {
    if (n2[0] !== t2[0] || n2[1] !== t2[1]) {
      var u2 = e2.push(Ir(e2) + "scale(", null, ",", null, ")");
      r2.push({ i: u2 - 4, x: mr(n2[0], t2[0]) }, { i: u2 - 2, x: mr(n2[1], t2[1]) });
    } else (1 !== t2[0] || 1 !== t2[1]) && e2.push(Ir(e2) + "scale(" + t2 + ")");
  }
  function $r(n2, t2) {
    var e2 = [], r2 = [];
    return n2 = oa.transform(n2), t2 = oa.transform(t2), Yr(n2.translate, t2.translate, e2, r2), Zr(n2.rotate, t2.rotate, e2, r2), Vr(n2.skew, t2.skew, e2, r2), Xr(n2.scale, t2.scale, e2, r2), n2 = t2 = null, function(n3) {
      for (var t3, u2 = -1, i2 = r2.length; ++u2 < i2; ) e2[(t3 = r2[u2]).i] = t3.x(n3);
      return e2.join("");
    };
  }
  function Br(n2, t2) {
    return t2 = (t2 -= n2 = +n2) || 1 / t2, function(e2) {
      return (e2 - n2) / t2;
    };
  }
  function Wr(n2, t2) {
    return t2 = (t2 -= n2 = +n2) || 1 / t2, function(e2) {
      return Math.max(0, Math.min(1, (e2 - n2) / t2));
    };
  }
  function Jr(n2) {
    for (var t2 = n2.source, e2 = n2.target, r2 = Kr(t2, e2), u2 = [t2]; t2 !== r2; ) t2 = t2.parent, u2.push(t2);
    for (var i2 = u2.length; e2 !== r2; ) u2.splice(i2, 0, e2), e2 = e2.parent;
    return u2;
  }
  function Gr(n2) {
    for (var t2 = [], e2 = n2.parent; null != e2; ) t2.push(n2), n2 = e2, e2 = e2.parent;
    return t2.push(n2), t2;
  }
  function Kr(n2, t2) {
    if (n2 === t2) return n2;
    for (var e2 = Gr(n2), r2 = Gr(t2), u2 = e2.pop(), i2 = r2.pop(), a2 = null; u2 === i2; ) a2 = u2, u2 = e2.pop(), i2 = r2.pop();
    return a2;
  }
  function Qr(n2) {
    n2.fixed |= 2;
  }
  function nu(n2) {
    n2.fixed &= -7;
  }
  function tu(n2) {
    n2.fixed |= 4, n2.px = n2.x, n2.py = n2.y;
  }
  function eu(n2) {
    n2.fixed &= -5;
  }
  function ru(n2, t2, e2) {
    var r2 = 0, u2 = 0;
    if (n2.charge = 0, !n2.leaf) for (var i2, a2 = n2.nodes, o2 = a2.length, l2 = -1; ++l2 < o2; ) i2 = a2[l2], null != i2 && (ru(i2, t2, e2), n2.charge += i2.charge, r2 += i2.charge * i2.cx, u2 += i2.charge * i2.cy);
    if (n2.point) {
      n2.leaf || (n2.point.x += Math.random() - 0.5, n2.point.y += Math.random() - 0.5);
      var c2 = t2 * e2[n2.point.index];
      n2.charge += n2.pointCharge = c2, r2 += c2 * n2.point.x, u2 += c2 * n2.point.y;
    }
    n2.cx = r2 / n2.charge, n2.cy = u2 / n2.charge;
  }
  function uu(n2, t2) {
    return oa.rebind(n2, t2, "sort", "children", "value"), n2.nodes = n2, n2.links = su, n2;
  }
  function iu(n2, t2) {
    for (var e2 = [n2]; null != (n2 = e2.pop()); ) if (t2(n2), (u2 = n2.children) && (r2 = u2.length)) for (var r2, u2; --r2 >= 0; ) e2.push(u2[r2]);
  }
  function au(n2, t2) {
    for (var e2 = [n2], r2 = []; null != (n2 = e2.pop()); ) if (r2.push(n2), (i2 = n2.children) && (u2 = i2.length)) for (var u2, i2, a2 = -1; ++a2 < u2; ) e2.push(i2[a2]);
    for (; null != (n2 = r2.pop()); ) t2(n2);
  }
  function ou(n2) {
    return n2.children;
  }
  function lu(n2) {
    return n2.value;
  }
  function cu(n2, t2) {
    return t2.value - n2.value;
  }
  function su(n2) {
    return oa.merge(n2.map(function(n3) {
      return (n3.children || []).map(function(t2) {
        return { source: n3, target: t2 };
      });
    }));
  }
  function fu(n2) {
    return n2.x;
  }
  function hu(n2) {
    return n2.y;
  }
  function gu(n2, t2, e2) {
    n2.y0 = t2, n2.y = e2;
  }
  function pu(n2) {
    return oa.range(n2.length);
  }
  function vu(n2) {
    for (var t2 = -1, e2 = n2[0].length, r2 = []; ++t2 < e2; ) r2[t2] = 0;
    return r2;
  }
  function du(n2) {
    for (var t2, e2 = 1, r2 = 0, u2 = n2[0][1], i2 = n2.length; i2 > e2; ++e2) (t2 = n2[e2][1]) > u2 && (r2 = e2, u2 = t2);
    return r2;
  }
  function mu(n2) {
    return n2.reduce(yu, 0);
  }
  function yu(n2, t2) {
    return n2 + t2[1];
  }
  function Mu(n2, t2) {
    return xu(n2, Math.ceil(Math.log(t2.length) / Math.LN2 + 1));
  }
  function xu(n2, t2) {
    for (var e2 = -1, r2 = +n2[0], u2 = (n2[1] - r2) / t2, i2 = []; ++e2 <= t2; ) i2[e2] = u2 * e2 + r2;
    return i2;
  }
  function bu(n2) {
    return [oa.min(n2), oa.max(n2)];
  }
  function _u(n2, t2) {
    return n2.value - t2.value;
  }
  function wu(n2, t2) {
    var e2 = n2._pack_next;
    n2._pack_next = t2, t2._pack_prev = n2, t2._pack_next = e2, e2._pack_prev = t2;
  }
  function Su(n2, t2) {
    n2._pack_next = t2, t2._pack_prev = n2;
  }
  function ku(n2, t2) {
    var e2 = t2.x - n2.x, r2 = t2.y - n2.y, u2 = n2.r + t2.r;
    return 0.999 * u2 * u2 > e2 * e2 + r2 * r2;
  }
  function Nu(n2) {
    function t2(n3) {
      s2 = Math.min(n3.x - n3.r, s2), f2 = Math.max(n3.x + n3.r, f2), h2 = Math.min(n3.y - n3.r, h2), g2 = Math.max(n3.y + n3.r, g2);
    }
    if ((e2 = n2.children) && (c2 = e2.length)) {
      var e2, r2, u2, i2, a2, o2, l2, c2, s2 = 1 / 0, f2 = -(1 / 0), h2 = 1 / 0, g2 = -(1 / 0);
      if (e2.forEach(Eu), r2 = e2[0], r2.x = -r2.r, r2.y = 0, t2(r2), c2 > 1 && (u2 = e2[1], u2.x = u2.r, u2.y = 0, t2(u2), c2 > 2)) for (i2 = e2[2], zu(r2, u2, i2), t2(i2), wu(r2, i2), r2._pack_prev = i2, wu(i2, u2), u2 = r2._pack_next, a2 = 3; c2 > a2; a2++) {
        zu(r2, u2, i2 = e2[a2]);
        var p2 = 0, v2 = 1, d2 = 1;
        for (o2 = u2._pack_next; o2 !== u2; o2 = o2._pack_next, v2++) if (ku(o2, i2)) {
          p2 = 1;
          break;
        }
        if (1 == p2) for (l2 = r2._pack_prev; l2 !== o2._pack_prev && !ku(l2, i2); l2 = l2._pack_prev, d2++) ;
        p2 ? (d2 > v2 || v2 == d2 && u2.r < r2.r ? Su(r2, u2 = o2) : Su(r2 = l2, u2), a2--) : (wu(r2, i2), u2 = i2, t2(i2));
      }
      var m2 = (s2 + f2) / 2, y2 = (h2 + g2) / 2, M2 = 0;
      for (a2 = 0; c2 > a2; a2++) i2 = e2[a2], i2.x -= m2, i2.y -= y2, M2 = Math.max(M2, i2.r + Math.sqrt(i2.x * i2.x + i2.y * i2.y));
      n2.r = M2, e2.forEach(Au);
    }
  }
  function Eu(n2) {
    n2._pack_next = n2._pack_prev = n2;
  }
  function Au(n2) {
    delete n2._pack_next, delete n2._pack_prev;
  }
  function Cu(n2, t2, e2, r2) {
    var u2 = n2.children;
    if (n2.x = t2 += r2 * n2.x, n2.y = e2 += r2 * n2.y, n2.r *= r2, u2) for (var i2 = -1, a2 = u2.length; ++i2 < a2; ) Cu(u2[i2], t2, e2, r2);
  }
  function zu(n2, t2, e2) {
    var r2 = n2.r + e2.r, u2 = t2.x - n2.x, i2 = t2.y - n2.y;
    if (r2 && (u2 || i2)) {
      var a2 = t2.r + e2.r, o2 = u2 * u2 + i2 * i2;
      a2 *= a2, r2 *= r2;
      var l2 = 0.5 + (r2 - a2) / (2 * o2), c2 = Math.sqrt(Math.max(0, 2 * a2 * (r2 + o2) - (r2 -= o2) * r2 - a2 * a2)) / (2 * o2);
      e2.x = n2.x + l2 * u2 + c2 * i2, e2.y = n2.y + l2 * i2 - c2 * u2;
    } else e2.x = n2.x + r2, e2.y = n2.y;
  }
  function Lu(n2, t2) {
    return n2.parent == t2.parent ? 1 : 2;
  }
  function qu(n2) {
    var t2 = n2.children;
    return t2.length ? t2[0] : n2.t;
  }
  function Tu(n2) {
    var t2, e2 = n2.children;
    return (t2 = e2.length) ? e2[t2 - 1] : n2.t;
  }
  function Ru(n2, t2, e2) {
    var r2 = e2 / (t2.i - n2.i);
    t2.c -= r2, t2.s += e2, n2.c += r2, t2.z += e2, t2.m += e2;
  }
  function Du(n2) {
    for (var t2, e2 = 0, r2 = 0, u2 = n2.children, i2 = u2.length; --i2 >= 0; ) t2 = u2[i2], t2.z += e2, t2.m += e2, e2 += t2.s + (r2 += t2.c);
  }
  function Pu(n2, t2, e2) {
    return n2.a.parent === t2.parent ? n2.a : e2;
  }
  function ju(n2) {
    return 1 + oa.max(n2, function(n3) {
      return n3.y;
    });
  }
  function Uu(n2) {
    return n2.reduce(function(n3, t2) {
      return n3 + t2.x;
    }, 0) / n2.length;
  }
  function Fu(n2) {
    var t2 = n2.children;
    return t2 && t2.length ? Fu(t2[0]) : n2;
  }
  function Hu(n2) {
    var t2, e2 = n2.children;
    return e2 && (t2 = e2.length) ? Hu(e2[t2 - 1]) : n2;
  }
  function Ou(n2) {
    return { x: n2.x, y: n2.y, dx: n2.dx, dy: n2.dy };
  }
  function Iu(n2, t2) {
    var e2 = n2.x + t2[3], r2 = n2.y + t2[0], u2 = n2.dx - t2[1] - t2[3], i2 = n2.dy - t2[0] - t2[2];
    return 0 > u2 && (e2 += u2 / 2, u2 = 0), 0 > i2 && (r2 += i2 / 2, i2 = 0), { x: e2, y: r2, dx: u2, dy: i2 };
  }
  function Yu(n2) {
    var t2 = n2[0], e2 = n2[n2.length - 1];
    return e2 > t2 ? [t2, e2] : [e2, t2];
  }
  function Zu(n2) {
    return n2.rangeExtent ? n2.rangeExtent() : Yu(n2.range());
  }
  function Vu(n2, t2, e2, r2) {
    var u2 = e2(n2[0], n2[1]), i2 = r2(t2[0], t2[1]);
    return function(n3) {
      return i2(u2(n3));
    };
  }
  function Xu(n2, t2) {
    var e2, r2 = 0, u2 = n2.length - 1, i2 = n2[r2], a2 = n2[u2];
    return i2 > a2 && (e2 = r2, r2 = u2, u2 = e2, e2 = i2, i2 = a2, a2 = e2), n2[r2] = t2.floor(i2), n2[u2] = t2.ceil(a2), n2;
  }
  function $u(n2) {
    return n2 ? { floor: function(t2) {
      return Math.floor(t2 / n2) * n2;
    }, ceil: function(t2) {
      return Math.ceil(t2 / n2) * n2;
    } } : wl;
  }
  function Bu(n2, t2, e2, r2) {
    var u2 = [], i2 = [], a2 = 0, o2 = Math.min(n2.length, t2.length) - 1;
    for (n2[o2] < n2[0] && (n2 = n2.slice().reverse(), t2 = t2.slice().reverse()); ++a2 <= o2; ) u2.push(e2(n2[a2 - 1], n2[a2])), i2.push(r2(t2[a2 - 1], t2[a2]));
    return function(t3) {
      var e3 = oa.bisect(n2, t3, 1, o2) - 1;
      return i2[e3](u2[e3](t3));
    };
  }
  function Wu(n2, t2, e2, r2) {
    function u2() {
      var u3 = Math.min(n2.length, t2.length) > 2 ? Bu : Vu, l2 = r2 ? Wr : Br;
      return a2 = u3(n2, t2, l2, e2), o2 = u3(t2, n2, l2, Mr), i2;
    }
    function i2(n3) {
      return a2(n3);
    }
    var a2, o2;
    return i2.invert = function(n3) {
      return o2(n3);
    }, i2.domain = function(t3) {
      return arguments.length ? (n2 = t3.map(Number), u2()) : n2;
    }, i2.range = function(n3) {
      return arguments.length ? (t2 = n3, u2()) : t2;
    }, i2.rangeRound = function(n3) {
      return i2.range(n3).interpolate(jr);
    }, i2.clamp = function(n3) {
      return arguments.length ? (r2 = n3, u2()) : r2;
    }, i2.interpolate = function(n3) {
      return arguments.length ? (e2 = n3, u2()) : e2;
    }, i2.ticks = function(t3) {
      return Qu(n2, t3);
    }, i2.tickFormat = function(t3, e3) {
      return ni(n2, t3, e3);
    }, i2.nice = function(t3) {
      return Gu(n2, t3), u2();
    }, i2.copy = function() {
      return Wu(n2, t2, e2, r2);
    }, u2();
  }
  function Ju(n2, t2) {
    return oa.rebind(n2, t2, "range", "rangeRound", "interpolate", "clamp");
  }
  function Gu(n2, t2) {
    return Xu(n2, $u(Ku(n2, t2)[2]));
  }
  function Ku(n2, t2) {
    null == t2 && (t2 = 10);
    var e2 = Yu(n2), r2 = e2[1] - e2[0], u2 = Math.pow(10, Math.floor(Math.log(r2 / t2) / Math.LN10)), i2 = t2 / r2 * u2;
    return 0.15 >= i2 ? u2 *= 10 : 0.35 >= i2 ? u2 *= 5 : 0.75 >= i2 && (u2 *= 2), e2[0] = Math.ceil(e2[0] / u2) * u2, e2[1] = Math.floor(e2[1] / u2) * u2 + 0.5 * u2, e2[2] = u2, e2;
  }
  function Qu(n2, t2) {
    return oa.range.apply(oa, Ku(n2, t2));
  }
  function ni(n2, t2, e2) {
    var r2 = Ku(n2, t2);
    if (e2) {
      var u2 = so.exec(e2);
      if (u2.shift(), "s" === u2[8]) {
        var i2 = oa.formatPrefix(Math.max(Ma(r2[0]), Ma(r2[1])));
        return u2[7] || (u2[7] = "." + ti(i2.scale(r2[2]))), u2[8] = "f", e2 = oa.format(u2.join("")), function(n3) {
          return e2(i2.scale(n3)) + i2.symbol;
        };
      }
      u2[7] || (u2[7] = "." + ei(u2[8], r2)), e2 = u2.join("");
    } else e2 = ",." + ti(r2[2]) + "f";
    return oa.format(e2);
  }
  function ti(n2) {
    return -Math.floor(Math.log(n2) / Math.LN10 + 0.01);
  }
  function ei(n2, t2) {
    var e2 = ti(t2[2]);
    return n2 in Sl ? Math.abs(e2 - ti(Math.max(Ma(t2[0]), Ma(t2[1])))) + +("e" !== n2) : e2 - 2 * ("%" === n2);
  }
  function ri(n2, t2, e2, r2) {
    function u2(n3) {
      return (e2 ? Math.log(0 > n3 ? 0 : n3) : -Math.log(n3 > 0 ? 0 : -n3)) / Math.log(t2);
    }
    function i2(n3) {
      return e2 ? Math.pow(t2, n3) : -Math.pow(t2, -n3);
    }
    function a2(t3) {
      return n2(u2(t3));
    }
    return a2.invert = function(t3) {
      return i2(n2.invert(t3));
    }, a2.domain = function(t3) {
      return arguments.length ? (e2 = t3[0] >= 0, n2.domain((r2 = t3.map(Number)).map(u2)), a2) : r2;
    }, a2.base = function(e3) {
      return arguments.length ? (t2 = +e3, n2.domain(r2.map(u2)), a2) : t2;
    }, a2.nice = function() {
      var t3 = Xu(r2.map(u2), e2 ? Math : Nl);
      return n2.domain(t3), r2 = t3.map(i2), a2;
    }, a2.ticks = function() {
      var n3 = Yu(r2), a3 = [], o2 = n3[0], l2 = n3[1], c2 = Math.floor(u2(o2)), s2 = Math.ceil(u2(l2)), f2 = t2 % 1 ? 2 : t2;
      if (isFinite(s2 - c2)) {
        if (e2) {
          for (; s2 > c2; c2++) for (var h2 = 1; f2 > h2; h2++) a3.push(i2(c2) * h2);
          a3.push(i2(c2));
        } else for (a3.push(i2(c2)); c2++ < s2; ) for (var h2 = f2 - 1; h2 > 0; h2--) a3.push(i2(c2) * h2);
        for (c2 = 0; a3[c2] < o2; c2++) ;
        for (s2 = a3.length; a3[s2 - 1] > l2; s2--) ;
        a3 = a3.slice(c2, s2);
      }
      return a3;
    }, a2.tickFormat = function(n3, t3) {
      if (!arguments.length) return kl;
      arguments.length < 2 ? t3 = kl : "function" != typeof t3 && (t3 = oa.format(t3));
      var r3, o2 = Math.max(0.1, n3 / a2.ticks().length), l2 = e2 ? (r3 = 1e-12, Math.ceil) : (r3 = -1e-12, Math.floor);
      return function(n4) {
        return n4 / i2(l2(u2(n4) + r3)) <= o2 ? t3(n4) : "";
      };
    }, a2.copy = function() {
      return ri(n2.copy(), t2, e2, r2);
    }, Ju(a2, n2);
  }
  function ui(n2, t2, e2) {
    function r2(t3) {
      return n2(u2(t3));
    }
    var u2 = ii(t2), i2 = ii(1 / t2);
    return r2.invert = function(t3) {
      return i2(n2.invert(t3));
    }, r2.domain = function(t3) {
      return arguments.length ? (n2.domain((e2 = t3.map(Number)).map(u2)), r2) : e2;
    }, r2.ticks = function(n3) {
      return Qu(e2, n3);
    }, r2.tickFormat = function(n3, t3) {
      return ni(e2, n3, t3);
    }, r2.nice = function(n3) {
      return r2.domain(Gu(e2, n3));
    }, r2.exponent = function(a2) {
      return arguments.length ? (u2 = ii(t2 = a2), i2 = ii(1 / t2), n2.domain(e2.map(u2)), r2) : t2;
    }, r2.copy = function() {
      return ui(n2.copy(), t2, e2);
    }, Ju(r2, n2);
  }
  function ii(n2) {
    return function(t2) {
      return 0 > t2 ? -Math.pow(-t2, n2) : Math.pow(t2, n2);
    };
  }
  function ai(n2, t2) {
    function e2(e3) {
      return i2[((u2.get(e3) || ("range" === t2.t ? u2.set(e3, n2.push(e3)) : NaN)) - 1) % i2.length];
    }
    function r2(t3, e3) {
      return oa.range(n2.length).map(function(n3) {
        return t3 + e3 * n3;
      });
    }
    var u2, i2, a2;
    return e2.domain = function(r3) {
      if (!arguments.length) return n2;
      n2 = [], u2 = new c();
      for (var i3, a3 = -1, o2 = r3.length; ++a3 < o2; ) u2.has(i3 = r3[a3]) || u2.set(i3, n2.push(i3));
      return e2[t2.t].apply(e2, t2.a);
    }, e2.range = function(n3) {
      return arguments.length ? (i2 = n3, a2 = 0, t2 = { t: "range", a: arguments }, e2) : i2;
    }, e2.rangePoints = function(u3, o2) {
      arguments.length < 2 && (o2 = 0);
      var l2 = u3[0], c2 = u3[1], s2 = n2.length < 2 ? (l2 = (l2 + c2) / 2, 0) : (c2 - l2) / (n2.length - 1 + o2);
      return i2 = r2(l2 + s2 * o2 / 2, s2), a2 = 0, t2 = { t: "rangePoints", a: arguments }, e2;
    }, e2.rangeRoundPoints = function(u3, o2) {
      arguments.length < 2 && (o2 = 0);
      var l2 = u3[0], c2 = u3[1], s2 = n2.length < 2 ? (l2 = c2 = Math.round((l2 + c2) / 2), 0) : (c2 - l2) / (n2.length - 1 + o2) | 0;
      return i2 = r2(l2 + Math.round(s2 * o2 / 2 + (c2 - l2 - (n2.length - 1 + o2) * s2) / 2), s2), a2 = 0, t2 = { t: "rangeRoundPoints", a: arguments }, e2;
    }, e2.rangeBands = function(u3, o2, l2) {
      arguments.length < 2 && (o2 = 0), arguments.length < 3 && (l2 = o2);
      var c2 = u3[1] < u3[0], s2 = u3[c2 - 0], f2 = u3[1 - c2], h2 = (f2 - s2) / (n2.length - o2 + 2 * l2);
      return i2 = r2(s2 + h2 * l2, h2), c2 && i2.reverse(), a2 = h2 * (1 - o2), t2 = { t: "rangeBands", a: arguments }, e2;
    }, e2.rangeRoundBands = function(u3, o2, l2) {
      arguments.length < 2 && (o2 = 0), arguments.length < 3 && (l2 = o2);
      var c2 = u3[1] < u3[0], s2 = u3[c2 - 0], f2 = u3[1 - c2], h2 = Math.floor((f2 - s2) / (n2.length - o2 + 2 * l2));
      return i2 = r2(s2 + Math.round((f2 - s2 - (n2.length - o2) * h2) / 2), h2), c2 && i2.reverse(), a2 = Math.round(h2 * (1 - o2)), t2 = { t: "rangeRoundBands", a: arguments }, e2;
    }, e2.rangeBand = function() {
      return a2;
    }, e2.rangeExtent = function() {
      return Yu(t2.a[0]);
    }, e2.copy = function() {
      return ai(n2, t2);
    }, e2.domain(n2);
  }
  function oi(n2, t2) {
    function i2() {
      var e2 = 0, r2 = t2.length;
      for (o2 = []; ++e2 < r2; ) o2[e2 - 1] = oa.quantile(n2, e2 / r2);
      return a2;
    }
    function a2(n3) {
      return isNaN(n3 = +n3) ? void 0 : t2[oa.bisect(o2, n3)];
    }
    var o2;
    return a2.domain = function(t3) {
      return arguments.length ? (n2 = t3.map(r).filter(u).sort(e), i2()) : n2;
    }, a2.range = function(n3) {
      return arguments.length ? (t2 = n3, i2()) : t2;
    }, a2.quantiles = function() {
      return o2;
    }, a2.invertExtent = function(e2) {
      return e2 = t2.indexOf(e2), 0 > e2 ? [NaN, NaN] : [e2 > 0 ? o2[e2 - 1] : n2[0], e2 < o2.length ? o2[e2] : n2[n2.length - 1]];
    }, a2.copy = function() {
      return oi(n2, t2);
    }, i2();
  }
  function li(n2, t2, e2) {
    function r2(t3) {
      return e2[Math.max(0, Math.min(a2, Math.floor(i2 * (t3 - n2))))];
    }
    function u2() {
      return i2 = e2.length / (t2 - n2), a2 = e2.length - 1, r2;
    }
    var i2, a2;
    return r2.domain = function(e3) {
      return arguments.length ? (n2 = +e3[0], t2 = +e3[e3.length - 1], u2()) : [n2, t2];
    }, r2.range = function(n3) {
      return arguments.length ? (e2 = n3, u2()) : e2;
    }, r2.invertExtent = function(t3) {
      return t3 = e2.indexOf(t3), t3 = 0 > t3 ? NaN : t3 / i2 + n2, [t3, t3 + 1 / i2];
    }, r2.copy = function() {
      return li(n2, t2, e2);
    }, u2();
  }
  function ci(n2, t2) {
    function e2(e3) {
      return e3 >= e3 ? t2[oa.bisect(n2, e3)] : void 0;
    }
    return e2.domain = function(t3) {
      return arguments.length ? (n2 = t3, e2) : n2;
    }, e2.range = function(n3) {
      return arguments.length ? (t2 = n3, e2) : t2;
    }, e2.invertExtent = function(e3) {
      return e3 = t2.indexOf(e3), [n2[e3 - 1], n2[e3]];
    }, e2.copy = function() {
      return ci(n2, t2);
    }, e2;
  }
  function si(n2) {
    function t2(n3) {
      return +n3;
    }
    return t2.invert = t2, t2.domain = t2.range = function(e2) {
      return arguments.length ? (n2 = e2.map(t2), t2) : n2;
    }, t2.ticks = function(t3) {
      return Qu(n2, t3);
    }, t2.tickFormat = function(t3, e2) {
      return ni(n2, t3, e2);
    }, t2.copy = function() {
      return si(n2);
    }, t2;
  }
  function fi() {
    return 0;
  }
  function hi(n2) {
    return n2.innerRadius;
  }
  function gi(n2) {
    return n2.outerRadius;
  }
  function pi(n2) {
    return n2.startAngle;
  }
  function vi(n2) {
    return n2.endAngle;
  }
  function di(n2) {
    return n2 && n2.padAngle;
  }
  function mi(n2, t2, e2, r2) {
    return (n2 - e2) * t2 - (t2 - r2) * n2 > 0 ? 0 : 1;
  }
  function yi(n2, t2, e2, r2, u2) {
    var i2 = n2[0] - t2[0], a2 = n2[1] - t2[1], o2 = (u2 ? r2 : -r2) / Math.sqrt(i2 * i2 + a2 * a2), l2 = o2 * a2, c2 = -o2 * i2, s2 = n2[0] + l2, f2 = n2[1] + c2, h2 = t2[0] + l2, g2 = t2[1] + c2, p2 = (s2 + h2) / 2, v2 = (f2 + g2) / 2, d2 = h2 - s2, m2 = g2 - f2, y2 = d2 * d2 + m2 * m2, M2 = e2 - r2, x2 = s2 * g2 - h2 * f2, b2 = (0 > m2 ? -1 : 1) * Math.sqrt(Math.max(0, M2 * M2 * y2 - x2 * x2)), _6 = (x2 * m2 - d2 * b2) / y2, w2 = (-x2 * d2 - m2 * b2) / y2, S2 = (x2 * m2 + d2 * b2) / y2, k2 = (-x2 * d2 + m2 * b2) / y2, N2 = _6 - p2, E2 = w2 - v2, A2 = S2 - p2, C2 = k2 - v2;
    return N2 * N2 + E2 * E2 > A2 * A2 + C2 * C2 && (_6 = S2, w2 = k2), [[_6 - l2, w2 - c2], [_6 * e2 / M2, w2 * e2 / M2]];
  }
  function Mi(n2) {
    function t2(t3) {
      function a3() {
        c2.push("M", i2(n2(s2), o2));
      }
      for (var l2, c2 = [], s2 = [], f2 = -1, h2 = t3.length, g2 = En(e2), p2 = En(r2); ++f2 < h2; ) u2.call(this, l2 = t3[f2], f2) ? s2.push([+g2.call(this, l2, f2), +p2.call(this, l2, f2)]) : s2.length && (a3(), s2 = []);
      return s2.length && a3(), c2.length ? c2.join("") : null;
    }
    var e2 = Ce, r2 = ze, u2 = zt, i2 = xi, a2 = i2.key, o2 = 0.7;
    return t2.x = function(n3) {
      return arguments.length ? (e2 = n3, t2) : e2;
    }, t2.y = function(n3) {
      return arguments.length ? (r2 = n3, t2) : r2;
    }, t2.defined = function(n3) {
      return arguments.length ? (u2 = n3, t2) : u2;
    }, t2.interpolate = function(n3) {
      return arguments.length ? (a2 = "function" == typeof n3 ? i2 = n3 : (i2 = ql.get(n3) || xi).key, t2) : a2;
    }, t2.tension = function(n3) {
      return arguments.length ? (o2 = n3, t2) : o2;
    }, t2;
  }
  function xi(n2) {
    return n2.length > 1 ? n2.join("L") : n2 + "Z";
  }
  function bi(n2) {
    return n2.join("L") + "Z";
  }
  function _i(n2) {
    for (var t2 = 0, e2 = n2.length, r2 = n2[0], u2 = [r2[0], ",", r2[1]]; ++t2 < e2; ) u2.push("H", (r2[0] + (r2 = n2[t2])[0]) / 2, "V", r2[1]);
    return e2 > 1 && u2.push("H", r2[0]), u2.join("");
  }
  function wi(n2) {
    for (var t2 = 0, e2 = n2.length, r2 = n2[0], u2 = [r2[0], ",", r2[1]]; ++t2 < e2; ) u2.push("V", (r2 = n2[t2])[1], "H", r2[0]);
    return u2.join("");
  }
  function Si(n2) {
    for (var t2 = 0, e2 = n2.length, r2 = n2[0], u2 = [r2[0], ",", r2[1]]; ++t2 < e2; ) u2.push("H", (r2 = n2[t2])[0], "V", r2[1]);
    return u2.join("");
  }
  function ki(n2, t2) {
    return n2.length < 4 ? xi(n2) : n2[1] + Ai(n2.slice(1, -1), Ci(n2, t2));
  }
  function Ni(n2, t2) {
    return n2.length < 3 ? bi(n2) : n2[0] + Ai((n2.push(n2[0]), n2), Ci([n2[n2.length - 2]].concat(n2, [n2[1]]), t2));
  }
  function Ei(n2, t2) {
    return n2.length < 3 ? xi(n2) : n2[0] + Ai(n2, Ci(n2, t2));
  }
  function Ai(n2, t2) {
    if (t2.length < 1 || n2.length != t2.length && n2.length != t2.length + 2) return xi(n2);
    var e2 = n2.length != t2.length, r2 = "", u2 = n2[0], i2 = n2[1], a2 = t2[0], o2 = a2, l2 = 1;
    if (e2 && (r2 += "Q" + (i2[0] - 2 * a2[0] / 3) + "," + (i2[1] - 2 * a2[1] / 3) + "," + i2[0] + "," + i2[1], u2 = n2[1], l2 = 2), t2.length > 1) {
      o2 = t2[1], i2 = n2[l2], l2++, r2 += "C" + (u2[0] + a2[0]) + "," + (u2[1] + a2[1]) + "," + (i2[0] - o2[0]) + "," + (i2[1] - o2[1]) + "," + i2[0] + "," + i2[1];
      for (var c2 = 2; c2 < t2.length; c2++, l2++) i2 = n2[l2], o2 = t2[c2], r2 += "S" + (i2[0] - o2[0]) + "," + (i2[1] - o2[1]) + "," + i2[0] + "," + i2[1];
    }
    if (e2) {
      var s2 = n2[l2];
      r2 += "Q" + (i2[0] + 2 * o2[0] / 3) + "," + (i2[1] + 2 * o2[1] / 3) + "," + s2[0] + "," + s2[1];
    }
    return r2;
  }
  function Ci(n2, t2) {
    for (var e2, r2 = [], u2 = (1 - t2) / 2, i2 = n2[0], a2 = n2[1], o2 = 1, l2 = n2.length; ++o2 < l2; ) e2 = i2, i2 = a2, a2 = n2[o2], r2.push([u2 * (a2[0] - e2[0]), u2 * (a2[1] - e2[1])]);
    return r2;
  }
  function zi(n2) {
    if (n2.length < 3) return xi(n2);
    var t2 = 1, e2 = n2.length, r2 = n2[0], u2 = r2[0], i2 = r2[1], a2 = [u2, u2, u2, (r2 = n2[1])[0]], o2 = [i2, i2, i2, r2[1]], l2 = [u2, ",", i2, "L", Ri(Dl, a2), ",", Ri(Dl, o2)];
    for (n2.push(n2[e2 - 1]); ++t2 <= e2; ) r2 = n2[t2], a2.shift(), a2.push(r2[0]), o2.shift(), o2.push(r2[1]), Di(l2, a2, o2);
    return n2.pop(), l2.push("L", r2), l2.join("");
  }
  function Li(n2) {
    if (n2.length < 4) return xi(n2);
    for (var t2, e2 = [], r2 = -1, u2 = n2.length, i2 = [0], a2 = [0]; ++r2 < 3; ) t2 = n2[r2], i2.push(t2[0]), a2.push(t2[1]);
    for (e2.push(Ri(Dl, i2) + "," + Ri(Dl, a2)), --r2; ++r2 < u2; ) t2 = n2[r2], i2.shift(), i2.push(t2[0]), a2.shift(), a2.push(t2[1]), Di(e2, i2, a2);
    return e2.join("");
  }
  function qi(n2) {
    for (var t2, e2, r2 = -1, u2 = n2.length, i2 = u2 + 4, a2 = [], o2 = []; ++r2 < 4; ) e2 = n2[r2 % u2], a2.push(e2[0]), o2.push(e2[1]);
    for (t2 = [Ri(Dl, a2), ",", Ri(Dl, o2)], --r2; ++r2 < i2; ) e2 = n2[r2 % u2], a2.shift(), a2.push(e2[0]), o2.shift(), o2.push(e2[1]), Di(t2, a2, o2);
    return t2.join("");
  }
  function Ti(n2, t2) {
    var e2 = n2.length - 1;
    if (e2) for (var r2, u2, i2 = n2[0][0], a2 = n2[0][1], o2 = n2[e2][0] - i2, l2 = n2[e2][1] - a2, c2 = -1; ++c2 <= e2; ) r2 = n2[c2], u2 = c2 / e2, r2[0] = t2 * r2[0] + (1 - t2) * (i2 + u2 * o2), r2[1] = t2 * r2[1] + (1 - t2) * (a2 + u2 * l2);
    return zi(n2);
  }
  function Ri(n2, t2) {
    return n2[0] * t2[0] + n2[1] * t2[1] + n2[2] * t2[2] + n2[3] * t2[3];
  }
  function Di(n2, t2, e2) {
    n2.push("C", Ri(Tl, t2), ",", Ri(Tl, e2), ",", Ri(Rl, t2), ",", Ri(Rl, e2), ",", Ri(Dl, t2), ",", Ri(Dl, e2));
  }
  function Pi(n2, t2) {
    return (t2[1] - n2[1]) / (t2[0] - n2[0]);
  }
  function ji(n2) {
    for (var t2 = 0, e2 = n2.length - 1, r2 = [], u2 = n2[0], i2 = n2[1], a2 = r2[0] = Pi(u2, i2); ++t2 < e2; ) r2[t2] = (a2 + (a2 = Pi(u2 = i2, i2 = n2[t2 + 1]))) / 2;
    return r2[t2] = a2, r2;
  }
  function Ui(n2) {
    for (var t2, e2, r2, u2, i2 = [], a2 = ji(n2), o2 = -1, l2 = n2.length - 1; ++o2 < l2; ) t2 = Pi(n2[o2], n2[o2 + 1]), Ma(t2) < Da ? a2[o2] = a2[o2 + 1] = 0 : (e2 = a2[o2] / t2, r2 = a2[o2 + 1] / t2, u2 = e2 * e2 + r2 * r2, u2 > 9 && (u2 = 3 * t2 / Math.sqrt(u2), a2[o2] = u2 * e2, a2[o2 + 1] = u2 * r2));
    for (o2 = -1; ++o2 <= l2; ) u2 = (n2[Math.min(l2, o2 + 1)][0] - n2[Math.max(0, o2 - 1)][0]) / (6 * (1 + a2[o2] * a2[o2])), i2.push([u2 || 0, a2[o2] * u2 || 0]);
    return i2;
  }
  function Fi(n2) {
    return n2.length < 3 ? xi(n2) : n2[0] + Ai(n2, Ui(n2));
  }
  function Hi(n2) {
    for (var t2, e2, r2, u2 = -1, i2 = n2.length; ++u2 < i2; ) t2 = n2[u2], e2 = t2[0], r2 = t2[1] - Ha, t2[0] = e2 * Math.cos(r2), t2[1] = e2 * Math.sin(r2);
    return n2;
  }
  function Oi(n2) {
    function t2(t3) {
      function l3() {
        v2.push("M", o2(n2(m2), f2), s2, c2(n2(d2.reverse()), f2), "Z");
      }
      for (var h2, g2, p2, v2 = [], d2 = [], m2 = [], y2 = -1, M2 = t3.length, x2 = En(e2), b2 = En(u2), _6 = e2 === r2 ? function() {
        return g2;
      } : En(r2), w2 = u2 === i2 ? function() {
        return p2;
      } : En(i2); ++y2 < M2; ) a2.call(this, h2 = t3[y2], y2) ? (d2.push([g2 = +x2.call(this, h2, y2), p2 = +b2.call(this, h2, y2)]), m2.push([+_6.call(this, h2, y2), +w2.call(this, h2, y2)])) : d2.length && (l3(), d2 = [], m2 = []);
      return d2.length && l3(), v2.length ? v2.join("") : null;
    }
    var e2 = Ce, r2 = Ce, u2 = 0, i2 = ze, a2 = zt, o2 = xi, l2 = o2.key, c2 = o2, s2 = "L", f2 = 0.7;
    return t2.x = function(n3) {
      return arguments.length ? (e2 = r2 = n3, t2) : r2;
    }, t2.x0 = function(n3) {
      return arguments.length ? (e2 = n3, t2) : e2;
    }, t2.x1 = function(n3) {
      return arguments.length ? (r2 = n3, t2) : r2;
    }, t2.y = function(n3) {
      return arguments.length ? (u2 = i2 = n3, t2) : i2;
    }, t2.y0 = function(n3) {
      return arguments.length ? (u2 = n3, t2) : u2;
    }, t2.y1 = function(n3) {
      return arguments.length ? (i2 = n3, t2) : i2;
    }, t2.defined = function(n3) {
      return arguments.length ? (a2 = n3, t2) : a2;
    }, t2.interpolate = function(n3) {
      return arguments.length ? (l2 = "function" == typeof n3 ? o2 = n3 : (o2 = ql.get(n3) || xi).key, c2 = o2.reverse || o2, s2 = o2.closed ? "M" : "L", t2) : l2;
    }, t2.tension = function(n3) {
      return arguments.length ? (f2 = n3, t2) : f2;
    }, t2;
  }
  function Ii(n2) {
    return n2.radius;
  }
  function Yi(n2) {
    return [n2.x, n2.y];
  }
  function Zi(n2) {
    return function() {
      var t2 = n2.apply(this, arguments), e2 = t2[0], r2 = t2[1] - Ha;
      return [e2 * Math.cos(r2), e2 * Math.sin(r2)];
    };
  }
  function Vi() {
    return 64;
  }
  function Xi() {
    return "circle";
  }
  function $i(n2) {
    var t2 = Math.sqrt(n2 / ja);
    return "M0," + t2 + "A" + t2 + "," + t2 + " 0 1,1 0," + -t2 + "A" + t2 + "," + t2 + " 0 1,1 0," + t2 + "Z";
  }
  function Bi(n2) {
    return function() {
      var t2, e2, r2;
      (t2 = this[n2]) && (r2 = t2[e2 = t2.active]) && (r2.timer.c = null, r2.timer.t = NaN, --t2.count ? delete t2[e2] : delete this[n2], t2.active += 0.5, r2.event && r2.event.interrupt.call(this, this.__data__, r2.index));
    };
  }
  function Wi(n2, t2, e2) {
    return Sa(n2, Il), n2.namespace = t2, n2.id = e2, n2;
  }
  function Ji(n2, t2, e2, r2) {
    var u2 = n2.id, i2 = n2.namespace;
    return Y(n2, "function" == typeof e2 ? function(n3, a2, o2) {
      n3[i2][u2].tween.set(t2, r2(e2.call(n3, n3.__data__, a2, o2)));
    } : (e2 = r2(e2), function(n3) {
      n3[i2][u2].tween.set(t2, e2);
    }));
  }
  function Gi(n2) {
    return null == n2 && (n2 = ""), function() {
      this.textContent = n2;
    };
  }
  function Ki(n2) {
    return null == n2 ? "__transition__" : "__transition_" + n2 + "__";
  }
  function Qi(n2, t2, e2, r2, u2) {
    function i2(n3) {
      var t3 = v2.delay;
      return s2.t = t3 + l2, n3 >= t3 ? a2(n3 - t3) : void (s2.c = a2);
    }
    function a2(e3) {
      var u3 = p2.active, i3 = p2[u3];
      i3 && (i3.timer.c = null, i3.timer.t = NaN, --p2.count, delete p2[u3], i3.event && i3.event.interrupt.call(n2, n2.__data__, i3.index));
      for (var a3 in p2) if (r2 > +a3) {
        var c2 = p2[a3];
        c2.timer.c = null, c2.timer.t = NaN, --p2.count, delete p2[a3];
      }
      s2.c = o2, qn(function() {
        return s2.c && o2(e3 || 1) && (s2.c = null, s2.t = NaN), 1;
      }, 0, l2), p2.active = r2, v2.event && v2.event.start.call(n2, n2.__data__, t2), g2 = [], v2.tween.forEach(function(e4, r3) {
        (r3 = r3.call(n2, n2.__data__, t2)) && g2.push(r3);
      }), h2 = v2.ease, f2 = v2.duration;
    }
    function o2(u3) {
      for (var i3 = u3 / f2, a3 = h2(i3), o3 = g2.length; o3 > 0; ) g2[--o3].call(n2, a3);
      return i3 >= 1 ? (v2.event && v2.event.end.call(n2, n2.__data__, t2), --p2.count ? delete p2[r2] : delete n2[e2], 1) : void 0;
    }
    var l2, s2, f2, h2, g2, p2 = n2[e2] || (n2[e2] = { active: 0, count: 0 }), v2 = p2[r2];
    v2 || (l2 = u2.time, s2 = qn(i2, 0, l2), v2 = p2[r2] = { tween: new c(), time: l2, timer: s2, delay: u2.delay, duration: u2.duration, ease: u2.ease, index: t2 }, u2 = null, ++p2.count);
  }
  function na(n2, t2, e2) {
    n2.attr("transform", function(n3) {
      var r2 = t2(n3);
      return "translate(" + (isFinite(r2) ? r2 : e2(n3)) + ",0)";
    });
  }
  function ta(n2, t2, e2) {
    n2.attr("transform", function(n3) {
      var r2 = t2(n3);
      return "translate(0," + (isFinite(r2) ? r2 : e2(n3)) + ")";
    });
  }
  function ea(n2) {
    return n2.toISOString();
  }
  function ra(n2, t2, e2) {
    function r2(t3) {
      return n2(t3);
    }
    function u2(n3, e3) {
      var r3 = n3[1] - n3[0], u3 = r3 / e3, i2 = oa.bisect(Gl, u3);
      return i2 == Gl.length ? [t2.year, Ku(n3.map(function(n4) {
        return n4 / 31536e6;
      }), e3)[2]] : i2 ? t2[u3 / Gl[i2 - 1] < Gl[i2] / u3 ? i2 - 1 : i2] : [nc, Ku(n3, e3)[2]];
    }
    return r2.invert = function(t3) {
      return ua(n2.invert(t3));
    }, r2.domain = function(t3) {
      return arguments.length ? (n2.domain(t3), r2) : n2.domain().map(ua);
    }, r2.nice = function(n3, t3) {
      function e3(e4) {
        return !isNaN(e4) && !n3.range(e4, ua(+e4 + 1), t3).length;
      }
      var i2 = r2.domain(), a2 = Yu(i2), o2 = null == n3 ? u2(a2, 10) : "number" == typeof n3 && u2(a2, n3);
      return o2 && (n3 = o2[0], t3 = o2[1]), r2.domain(Xu(i2, t3 > 1 ? { floor: function(t4) {
        for (; e3(t4 = n3.floor(t4)); ) t4 = ua(t4 - 1);
        return t4;
      }, ceil: function(t4) {
        for (; e3(t4 = n3.ceil(t4)); ) t4 = ua(+t4 + 1);
        return t4;
      } } : n3));
    }, r2.ticks = function(n3, t3) {
      var e3 = Yu(r2.domain()), i2 = null == n3 ? u2(e3, 10) : "number" == typeof n3 ? u2(e3, n3) : !n3.range && [{ range: n3 }, t3];
      return i2 && (n3 = i2[0], t3 = i2[1]), n3.range(e3[0], ua(+e3[1] + 1), 1 > t3 ? 1 : t3);
    }, r2.tickFormat = function() {
      return e2;
    }, r2.copy = function() {
      return ra(n2.copy(), t2, e2);
    }, Ju(r2, n2);
  }
  function ua(n2) {
    return new Date(n2);
  }
  function ia(n2) {
    return JSON.parse(n2.responseText);
  }
  function aa(n2) {
    var t2 = sa.createRange();
    return t2.selectNode(sa.body), t2.createContextualFragment(n2.responseText);
  }
  var oa = { version: "3.5.10" }, la = [].slice, ca = function(n2) {
    return la.call(n2);
  }, sa = this.document;
  if (sa) try {
    ca(sa.documentElement.childNodes)[0].nodeType;
  } catch (fa) {
    ca = function(n2) {
      for (var t2 = n2.length, e2 = new Array(t2); t2--; ) e2[t2] = n2[t2];
      return e2;
    };
  }
  if (Date.now || (Date.now = function() {
    return +/* @__PURE__ */ new Date();
  }), sa) try {
    sa.createElement("DIV").style.setProperty("opacity", 0, "");
  } catch (ha) {
    var ga = this.Element.prototype, pa = ga.setAttribute, va = ga.setAttributeNS, da = this.CSSStyleDeclaration.prototype, ma = da.setProperty;
    ga.setAttribute = function(n2, t2) {
      pa.call(this, n2, t2 + "");
    }, ga.setAttributeNS = function(n2, t2, e2) {
      va.call(this, n2, t2, e2 + "");
    }, da.setProperty = function(n2, t2, e2) {
      ma.call(this, n2, t2 + "", e2);
    };
  }
  oa.ascending = e, oa.descending = function(n2, t2) {
    return n2 > t2 ? -1 : t2 > n2 ? 1 : t2 >= n2 ? 0 : NaN;
  }, oa.min = function(n2, t2) {
    var e2, r2, u2 = -1, i2 = n2.length;
    if (1 === arguments.length) {
      for (; ++u2 < i2; ) if (null != (r2 = n2[u2]) && r2 >= r2) {
        e2 = r2;
        break;
      }
      for (; ++u2 < i2; ) null != (r2 = n2[u2]) && e2 > r2 && (e2 = r2);
    } else {
      for (; ++u2 < i2; ) if (null != (r2 = t2.call(n2, n2[u2], u2)) && r2 >= r2) {
        e2 = r2;
        break;
      }
      for (; ++u2 < i2; ) null != (r2 = t2.call(n2, n2[u2], u2)) && e2 > r2 && (e2 = r2);
    }
    return e2;
  }, oa.max = function(n2, t2) {
    var e2, r2, u2 = -1, i2 = n2.length;
    if (1 === arguments.length) {
      for (; ++u2 < i2; ) if (null != (r2 = n2[u2]) && r2 >= r2) {
        e2 = r2;
        break;
      }
      for (; ++u2 < i2; ) null != (r2 = n2[u2]) && r2 > e2 && (e2 = r2);
    } else {
      for (; ++u2 < i2; ) if (null != (r2 = t2.call(n2, n2[u2], u2)) && r2 >= r2) {
        e2 = r2;
        break;
      }
      for (; ++u2 < i2; ) null != (r2 = t2.call(n2, n2[u2], u2)) && r2 > e2 && (e2 = r2);
    }
    return e2;
  }, oa.extent = function(n2, t2) {
    var e2, r2, u2, i2 = -1, a2 = n2.length;
    if (1 === arguments.length) {
      for (; ++i2 < a2; ) if (null != (r2 = n2[i2]) && r2 >= r2) {
        e2 = u2 = r2;
        break;
      }
      for (; ++i2 < a2; ) null != (r2 = n2[i2]) && (e2 > r2 && (e2 = r2), r2 > u2 && (u2 = r2));
    } else {
      for (; ++i2 < a2; ) if (null != (r2 = t2.call(n2, n2[i2], i2)) && r2 >= r2) {
        e2 = u2 = r2;
        break;
      }
      for (; ++i2 < a2; ) null != (r2 = t2.call(n2, n2[i2], i2)) && (e2 > r2 && (e2 = r2), r2 > u2 && (u2 = r2));
    }
    return [e2, u2];
  }, oa.sum = function(n2, t2) {
    var e2, r2 = 0, i2 = n2.length, a2 = -1;
    if (1 === arguments.length) for (; ++a2 < i2; ) u(e2 = +n2[a2]) && (r2 += e2);
    else for (; ++a2 < i2; ) u(e2 = +t2.call(n2, n2[a2], a2)) && (r2 += e2);
    return r2;
  }, oa.mean = function(n2, t2) {
    var e2, i2 = 0, a2 = n2.length, o2 = -1, l2 = a2;
    if (1 === arguments.length) for (; ++o2 < a2; ) u(e2 = r(n2[o2])) ? i2 += e2 : --l2;
    else for (; ++o2 < a2; ) u(e2 = r(t2.call(n2, n2[o2], o2))) ? i2 += e2 : --l2;
    return l2 ? i2 / l2 : void 0;
  }, oa.quantile = function(n2, t2) {
    var e2 = (n2.length - 1) * t2 + 1, r2 = Math.floor(e2), u2 = +n2[r2 - 1], i2 = e2 - r2;
    return i2 ? u2 + i2 * (n2[r2] - u2) : u2;
  }, oa.median = function(n2, t2) {
    var i2, a2 = [], o2 = n2.length, l2 = -1;
    if (1 === arguments.length) for (; ++l2 < o2; ) u(i2 = r(n2[l2])) && a2.push(i2);
    else for (; ++l2 < o2; ) u(i2 = r(t2.call(n2, n2[l2], l2))) && a2.push(i2);
    return a2.length ? oa.quantile(a2.sort(e), 0.5) : void 0;
  }, oa.variance = function(n2, t2) {
    var e2, i2, a2 = n2.length, o2 = 0, l2 = 0, c2 = -1, s2 = 0;
    if (1 === arguments.length) for (; ++c2 < a2; ) u(e2 = r(n2[c2])) && (i2 = e2 - o2, o2 += i2 / ++s2, l2 += i2 * (e2 - o2));
    else for (; ++c2 < a2; ) u(e2 = r(t2.call(n2, n2[c2], c2))) && (i2 = e2 - o2, o2 += i2 / ++s2, l2 += i2 * (e2 - o2));
    return s2 > 1 ? l2 / (s2 - 1) : void 0;
  }, oa.deviation = function() {
    var n2 = oa.variance.apply(this, arguments);
    return n2 ? Math.sqrt(n2) : n2;
  };
  var ya = i(e);
  oa.bisectLeft = ya.left, oa.bisect = oa.bisectRight = ya.right, oa.bisector = function(n2) {
    return i(1 === n2.length ? function(t2, r2) {
      return e(n2(t2), r2);
    } : n2);
  }, oa.shuffle = function(n2, t2, e2) {
    (i2 = arguments.length) < 3 && (e2 = n2.length, 2 > i2 && (t2 = 0));
    for (var r2, u2, i2 = e2 - t2; i2; ) u2 = Math.random() * i2-- | 0, r2 = n2[i2 + t2], n2[i2 + t2] = n2[u2 + t2], n2[u2 + t2] = r2;
    return n2;
  }, oa.permute = function(n2, t2) {
    for (var e2 = t2.length, r2 = new Array(e2); e2--; ) r2[e2] = n2[t2[e2]];
    return r2;
  }, oa.pairs = function(n2) {
    for (var t2, e2 = 0, r2 = n2.length - 1, u2 = n2[0], i2 = new Array(0 > r2 ? 0 : r2); r2 > e2; ) i2[e2] = [t2 = u2, u2 = n2[++e2]];
    return i2;
  }, oa.zip = function() {
    if (!(r2 = arguments.length)) return [];
    for (var n2 = -1, t2 = oa.min(arguments, a), e2 = new Array(t2); ++n2 < t2; ) for (var r2, u2 = -1, i2 = e2[n2] = new Array(r2); ++u2 < r2; ) i2[u2] = arguments[u2][n2];
    return e2;
  }, oa.transpose = function(n2) {
    return oa.zip.apply(oa, n2);
  }, oa.keys = function(n2) {
    var t2 = [];
    for (var e2 in n2) t2.push(e2);
    return t2;
  }, oa.values = function(n2) {
    var t2 = [];
    for (var e2 in n2) t2.push(n2[e2]);
    return t2;
  }, oa.entries = function(n2) {
    var t2 = [];
    for (var e2 in n2) t2.push({ key: e2, value: n2[e2] });
    return t2;
  }, oa.merge = function(n2) {
    for (var t2, e2, r2, u2 = n2.length, i2 = -1, a2 = 0; ++i2 < u2; ) a2 += n2[i2].length;
    for (e2 = new Array(a2); --u2 >= 0; ) for (r2 = n2[u2], t2 = r2.length; --t2 >= 0; ) e2[--a2] = r2[t2];
    return e2;
  };
  var Ma = Math.abs;
  oa.range = function(n2, t2, e2) {
    if (arguments.length < 3 && (e2 = 1, arguments.length < 2 && (t2 = n2, n2 = 0)), (t2 - n2) / e2 === 1 / 0) throw new Error("infinite range");
    var r2, u2 = [], i2 = o(Ma(e2)), a2 = -1;
    if (n2 *= i2, t2 *= i2, e2 *= i2, 0 > e2) for (; (r2 = n2 + e2 * ++a2) > t2; ) u2.push(r2 / i2);
    else for (; (r2 = n2 + e2 * ++a2) < t2; ) u2.push(r2 / i2);
    return u2;
  }, oa.map = function(n2, t2) {
    var e2 = new c();
    if (n2 instanceof c) n2.forEach(function(n3, t3) {
      e2.set(n3, t3);
    });
    else if (Array.isArray(n2)) {
      var r2, u2 = -1, i2 = n2.length;
      if (1 === arguments.length) for (; ++u2 < i2; ) e2.set(u2, n2[u2]);
      else for (; ++u2 < i2; ) e2.set(t2.call(n2, r2 = n2[u2], u2), r2);
    } else for (var a2 in n2) e2.set(a2, n2[a2]);
    return e2;
  };
  var xa = "__proto__", ba = "\0";
  l(c, { has: h, get: function(n2) {
    return this._[s(n2)];
  }, set: function(n2, t2) {
    return this._[s(n2)] = t2;
  }, remove: g, keys: p, values: function() {
    var n2 = [];
    for (var t2 in this._) n2.push(this._[t2]);
    return n2;
  }, entries: function() {
    var n2 = [];
    for (var t2 in this._) n2.push({ key: f(t2), value: this._[t2] });
    return n2;
  }, size: v, empty: d, forEach: function(n2) {
    for (var t2 in this._) n2.call(this, f(t2), this._[t2]);
  } }), oa.nest = function() {
    function n2(t3, a3, o2) {
      if (o2 >= i2.length) return r2 ? r2.call(u2, a3) : e2 ? a3.sort(e2) : a3;
      for (var l2, s2, f2, h2, g2 = -1, p2 = a3.length, v2 = i2[o2++], d2 = new c(); ++g2 < p2; ) (h2 = d2.get(l2 = v2(s2 = a3[g2]))) ? h2.push(s2) : d2.set(l2, [s2]);
      return t3 ? (s2 = t3(), f2 = function(e3, r3) {
        s2.set(e3, n2(t3, r3, o2));
      }) : (s2 = {}, f2 = function(e3, r3) {
        s2[e3] = n2(t3, r3, o2);
      }), d2.forEach(f2), s2;
    }
    function t2(n3, e3) {
      if (e3 >= i2.length) return n3;
      var r3 = [], u3 = a2[e3++];
      return n3.forEach(function(n4, u4) {
        r3.push({ key: n4, values: t2(u4, e3) });
      }), u3 ? r3.sort(function(n4, t3) {
        return u3(n4.key, t3.key);
      }) : r3;
    }
    var e2, r2, u2 = {}, i2 = [], a2 = [];
    return u2.map = function(t3, e3) {
      return n2(e3, t3, 0);
    }, u2.entries = function(e3) {
      return t2(n2(oa.map, e3, 0), 0);
    }, u2.key = function(n3) {
      return i2.push(n3), u2;
    }, u2.sortKeys = function(n3) {
      return a2[i2.length - 1] = n3, u2;
    }, u2.sortValues = function(n3) {
      return e2 = n3, u2;
    }, u2.rollup = function(n3) {
      return r2 = n3, u2;
    }, u2;
  }, oa.set = function(n2) {
    var t2 = new m();
    if (n2) for (var e2 = 0, r2 = n2.length; r2 > e2; ++e2) t2.add(n2[e2]);
    return t2;
  }, l(m, { has: h, add: function(n2) {
    return this._[s(n2 += "")] = true, n2;
  }, remove: g, values: p, size: v, empty: d, forEach: function(n2) {
    for (var t2 in this._) n2.call(this, f(t2));
  } }), oa.behavior = {}, oa.rebind = function(n2, t2) {
    for (var e2, r2 = 1, u2 = arguments.length; ++r2 < u2; ) n2[e2 = arguments[r2]] = M(n2, t2, t2[e2]);
    return n2;
  };
  var _a = ["webkit", "ms", "moz", "Moz", "o", "O"];
  oa.dispatch = function() {
    for (var n2 = new _5(), t2 = -1, e2 = arguments.length; ++t2 < e2; ) n2[arguments[t2]] = w(n2);
    return n2;
  }, _5.prototype.on = function(n2, t2) {
    var e2 = n2.indexOf("."), r2 = "";
    if (e2 >= 0 && (r2 = n2.slice(e2 + 1), n2 = n2.slice(0, e2)), n2) return arguments.length < 2 ? this[n2].on(r2) : this[n2].on(r2, t2);
    if (2 === arguments.length) {
      if (null == t2) for (n2 in this) this.hasOwnProperty(n2) && this[n2].on(r2, null);
      return this;
    }
  }, oa.event = null, oa.requote = function(n2) {
    return n2.replace(wa, "\\$&");
  };
  var wa = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, Sa = {}.__proto__ ? function(n2, t2) {
    n2.__proto__ = t2;
  } : function(n2, t2) {
    for (var e2 in t2) n2[e2] = t2[e2];
  }, ka = function(n2, t2) {
    return t2.querySelector(n2);
  }, Na = function(n2, t2) {
    return t2.querySelectorAll(n2);
  }, Ea = function(n2, t2) {
    var e2 = n2.matches || n2[x(n2, "matchesSelector")];
    return (Ea = function(n3, t3) {
      return e2.call(n3, t3);
    })(n2, t2);
  };
  "function" == typeof Sizzle && (ka = function(n2, t2) {
    return Sizzle(n2, t2)[0] || null;
  }, Na = Sizzle, Ea = Sizzle.matchesSelector), oa.selection = function() {
    return oa.select(sa.documentElement);
  };
  var Aa = oa.selection.prototype = [];
  Aa.select = function(n2) {
    var t2, e2, r2, u2, i2 = [];
    n2 = A(n2);
    for (var a2 = -1, o2 = this.length; ++a2 < o2; ) {
      i2.push(t2 = []), t2.parentNode = (r2 = this[a2]).parentNode;
      for (var l2 = -1, c2 = r2.length; ++l2 < c2; ) (u2 = r2[l2]) ? (t2.push(e2 = n2.call(u2, u2.__data__, l2, a2)), e2 && "__data__" in u2 && (e2.__data__ = u2.__data__)) : t2.push(null);
    }
    return E(i2);
  }, Aa.selectAll = function(n2) {
    var t2, e2, r2 = [];
    n2 = C(n2);
    for (var u2 = -1, i2 = this.length; ++u2 < i2; ) for (var a2 = this[u2], o2 = -1, l2 = a2.length; ++o2 < l2; ) (e2 = a2[o2]) && (r2.push(t2 = ca(n2.call(e2, e2.__data__, o2, u2))), t2.parentNode = e2);
    return E(r2);
  };
  var Ca = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" };
  oa.ns = { prefix: Ca, qualify: function(n2) {
    var t2 = n2.indexOf(":"), e2 = n2;
    return t2 >= 0 && "xmlns" !== (e2 = n2.slice(0, t2)) && (n2 = n2.slice(t2 + 1)), Ca.hasOwnProperty(e2) ? { space: Ca[e2], local: n2 } : n2;
  } }, Aa.attr = function(n2, t2) {
    if (arguments.length < 2) {
      if ("string" == typeof n2) {
        var e2 = this.node();
        return n2 = oa.ns.qualify(n2), n2.local ? e2.getAttributeNS(n2.space, n2.local) : e2.getAttribute(n2);
      }
      for (t2 in n2) this.each(z(t2, n2[t2]));
      return this;
    }
    return this.each(z(n2, t2));
  }, Aa.classed = function(n2, t2) {
    if (arguments.length < 2) {
      if ("string" == typeof n2) {
        var e2 = this.node(), r2 = (n2 = T(n2)).length, u2 = -1;
        if (t2 = e2.classList) {
          for (; ++u2 < r2; ) if (!t2.contains(n2[u2])) return false;
        } else for (t2 = e2.getAttribute("class"); ++u2 < r2; ) if (!q(n2[u2]).test(t2)) return false;
        return true;
      }
      for (t2 in n2) this.each(R(t2, n2[t2]));
      return this;
    }
    return this.each(R(n2, t2));
  }, Aa.style = function(n2, e2, r2) {
    var u2 = arguments.length;
    if (3 > u2) {
      if ("string" != typeof n2) {
        2 > u2 && (e2 = "");
        for (r2 in n2) this.each(P(r2, n2[r2], e2));
        return this;
      }
      if (2 > u2) {
        var i2 = this.node();
        return t(i2).getComputedStyle(i2, null).getPropertyValue(n2);
      }
      r2 = "";
    }
    return this.each(P(n2, e2, r2));
  }, Aa.property = function(n2, t2) {
    if (arguments.length < 2) {
      if ("string" == typeof n2) return this.node()[n2];
      for (t2 in n2) this.each(j(t2, n2[t2]));
      return this;
    }
    return this.each(j(n2, t2));
  }, Aa.text = function(n2) {
    return arguments.length ? this.each("function" == typeof n2 ? function() {
      var t2 = n2.apply(this, arguments);
      this.textContent = null == t2 ? "" : t2;
    } : null == n2 ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = n2;
    }) : this.node().textContent;
  }, Aa.html = function(n2) {
    return arguments.length ? this.each("function" == typeof n2 ? function() {
      var t2 = n2.apply(this, arguments);
      this.innerHTML = null == t2 ? "" : t2;
    } : null == n2 ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = n2;
    }) : this.node().innerHTML;
  }, Aa.append = function(n2) {
    return n2 = U(n2), this.select(function() {
      return this.appendChild(n2.apply(this, arguments));
    });
  }, Aa.insert = function(n2, t2) {
    return n2 = U(n2), t2 = A(t2), this.select(function() {
      return this.insertBefore(n2.apply(this, arguments), t2.apply(this, arguments) || null);
    });
  }, Aa.remove = function() {
    return this.each(F);
  }, Aa.data = function(n2, t2) {
    function e2(n3, e3) {
      var r3, u3, i3, a3 = n3.length, f2 = e3.length, h2 = Math.min(a3, f2), g2 = new Array(f2), p2 = new Array(f2), v2 = new Array(a3);
      if (t2) {
        var d2, m2 = new c(), y2 = new Array(a3);
        for (r3 = -1; ++r3 < a3; ) (u3 = n3[r3]) && (m2.has(d2 = t2.call(u3, u3.__data__, r3)) ? v2[r3] = u3 : m2.set(d2, u3), y2[r3] = d2);
        for (r3 = -1; ++r3 < f2; ) (u3 = m2.get(d2 = t2.call(e3, i3 = e3[r3], r3))) ? u3 !== true && (g2[r3] = u3, u3.__data__ = i3) : p2[r3] = H(i3), m2.set(d2, true);
        for (r3 = -1; ++r3 < a3; ) r3 in y2 && m2.get(y2[r3]) !== true && (v2[r3] = n3[r3]);
      } else {
        for (r3 = -1; ++r3 < h2; ) u3 = n3[r3], i3 = e3[r3], u3 ? (u3.__data__ = i3, g2[r3] = u3) : p2[r3] = H(i3);
        for (; f2 > r3; ++r3) p2[r3] = H(e3[r3]);
        for (; a3 > r3; ++r3) v2[r3] = n3[r3];
      }
      p2.update = g2, p2.parentNode = g2.parentNode = v2.parentNode = n3.parentNode, o2.push(p2), l2.push(g2), s2.push(v2);
    }
    var r2, u2, i2 = -1, a2 = this.length;
    if (!arguments.length) {
      for (n2 = new Array(a2 = (r2 = this[0]).length); ++i2 < a2; ) (u2 = r2[i2]) && (n2[i2] = u2.__data__);
      return n2;
    }
    var o2 = Z([]), l2 = E([]), s2 = E([]);
    if ("function" == typeof n2) for (; ++i2 < a2; ) e2(r2 = this[i2], n2.call(r2, r2.parentNode.__data__, i2));
    else for (; ++i2 < a2; ) e2(r2 = this[i2], n2);
    return l2.enter = function() {
      return o2;
    }, l2.exit = function() {
      return s2;
    }, l2;
  }, Aa.datum = function(n2) {
    return arguments.length ? this.property("__data__", n2) : this.property("__data__");
  }, Aa.filter = function(n2) {
    var t2, e2, r2, u2 = [];
    "function" != typeof n2 && (n2 = O(n2));
    for (var i2 = 0, a2 = this.length; a2 > i2; i2++) {
      u2.push(t2 = []), t2.parentNode = (e2 = this[i2]).parentNode;
      for (var o2 = 0, l2 = e2.length; l2 > o2; o2++) (r2 = e2[o2]) && n2.call(r2, r2.__data__, o2, i2) && t2.push(r2);
    }
    return E(u2);
  }, Aa.order = function() {
    for (var n2 = -1, t2 = this.length; ++n2 < t2; ) for (var e2, r2 = this[n2], u2 = r2.length - 1, i2 = r2[u2]; --u2 >= 0; ) (e2 = r2[u2]) && (i2 && i2 !== e2.nextSibling && i2.parentNode.insertBefore(e2, i2), i2 = e2);
    return this;
  }, Aa.sort = function(n2) {
    n2 = I.apply(this, arguments);
    for (var t2 = -1, e2 = this.length; ++t2 < e2; ) this[t2].sort(n2);
    return this.order();
  }, Aa.each = function(n2) {
    return Y(this, function(t2, e2, r2) {
      n2.call(t2, t2.__data__, e2, r2);
    });
  }, Aa.call = function(n2) {
    var t2 = ca(arguments);
    return n2.apply(t2[0] = this, t2), this;
  }, Aa.empty = function() {
    return !this.node();
  }, Aa.node = function() {
    for (var n2 = 0, t2 = this.length; t2 > n2; n2++) for (var e2 = this[n2], r2 = 0, u2 = e2.length; u2 > r2; r2++) {
      var i2 = e2[r2];
      if (i2) return i2;
    }
    return null;
  }, Aa.size = function() {
    var n2 = 0;
    return Y(this, function() {
      ++n2;
    }), n2;
  };
  var za = [];
  oa.selection.enter = Z, oa.selection.enter.prototype = za, za.append = Aa.append, za.empty = Aa.empty, za.node = Aa.node, za.call = Aa.call, za.size = Aa.size, za.select = function(n2) {
    for (var t2, e2, r2, u2, i2, a2 = [], o2 = -1, l2 = this.length; ++o2 < l2; ) {
      r2 = (u2 = this[o2]).update, a2.push(t2 = []), t2.parentNode = u2.parentNode;
      for (var c2 = -1, s2 = u2.length; ++c2 < s2; ) (i2 = u2[c2]) ? (t2.push(r2[c2] = e2 = n2.call(u2.parentNode, i2.__data__, c2, o2)), e2.__data__ = i2.__data__) : t2.push(null);
    }
    return E(a2);
  }, za.insert = function(n2, t2) {
    return arguments.length < 2 && (t2 = V(this)), Aa.insert.call(this, n2, t2);
  }, oa.select = function(t2) {
    var e2;
    return "string" == typeof t2 ? (e2 = [ka(t2, sa)], e2.parentNode = sa.documentElement) : (e2 = [t2], e2.parentNode = n(t2)), E([e2]);
  }, oa.selectAll = function(n2) {
    var t2;
    return "string" == typeof n2 ? (t2 = ca(Na(n2, sa)), t2.parentNode = sa.documentElement) : (t2 = ca(n2), t2.parentNode = null), E([t2]);
  }, Aa.on = function(n2, t2, e2) {
    var r2 = arguments.length;
    if (3 > r2) {
      if ("string" != typeof n2) {
        2 > r2 && (t2 = false);
        for (e2 in n2) this.each(X(e2, n2[e2], t2));
        return this;
      }
      if (2 > r2) return (r2 = this.node()["__on" + n2]) && r2._;
      e2 = false;
    }
    return this.each(X(n2, t2, e2));
  };
  var La = oa.map({ mouseenter: "mouseover", mouseleave: "mouseout" });
  sa && La.forEach(function(n2) {
    "on" + n2 in sa && La.remove(n2);
  });
  var qa, Ta = 0;
  oa.mouse = function(n2) {
    return J(n2, k());
  };
  var Ra = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  oa.touch = function(n2, t2, e2) {
    if (arguments.length < 3 && (e2 = t2, t2 = k().changedTouches), t2) {
      for (var r2, u2 = 0, i2 = t2.length; i2 > u2; ++u2) if ((r2 = t2[u2]).identifier === e2) return J(n2, r2);
    }
  }, oa.behavior.drag = function() {
    function n2() {
      this.on("mousedown.drag", i2).on("touchstart.drag", a2);
    }
    function e2(n3, t2, e3, i3, a3) {
      return function() {
        function o2() {
          var n4, e4, r3 = t2(h2, v2);
          r3 && (n4 = r3[0] - M2[0], e4 = r3[1] - M2[1], p2 |= n4 | e4, M2 = r3, g2({ type: "drag", x: r3[0] + c2[0], y: r3[1] + c2[1], dx: n4, dy: e4 }));
        }
        function l2() {
          t2(h2, v2) && (m2.on(i3 + d2, null).on(a3 + d2, null), y2(p2), g2({ type: "dragend" }));
        }
        var c2, s2 = this, f2 = oa.event.target, h2 = s2.parentNode, g2 = r2.of(s2, arguments), p2 = 0, v2 = n3(), d2 = ".drag" + (null == v2 ? "" : "-" + v2), m2 = oa.select(e3(f2)).on(i3 + d2, o2).on(a3 + d2, l2), y2 = W(f2), M2 = t2(h2, v2);
        u2 ? (c2 = u2.apply(s2, arguments), c2 = [c2.x - M2[0], c2.y - M2[1]]) : c2 = [0, 0], g2({ type: "dragstart" });
      };
    }
    var r2 = N(n2, "drag", "dragstart", "dragend"), u2 = null, i2 = e2(b, oa.mouse, t, "mousemove", "mouseup"), a2 = e2(G, oa.touch, y, "touchmove", "touchend");
    return n2.origin = function(t2) {
      return arguments.length ? (u2 = t2, n2) : u2;
    }, oa.rebind(n2, r2, "on");
  }, oa.touches = function(n2, t2) {
    return arguments.length < 2 && (t2 = k().touches), t2 ? ca(t2).map(function(t3) {
      var e2 = J(n2, t3);
      return e2.identifier = t3.identifier, e2;
    }) : [];
  };
  var Da = 1e-6, Pa = Da * Da, ja = Math.PI, Ua = 2 * ja, Fa = Ua - Da, Ha = ja / 2, Oa = ja / 180, Ia = 180 / ja, Ya = Math.SQRT2, Za = 2, Va = 4;
  oa.interpolateZoom = function(n2, t2) {
    var e2, r2, u2 = n2[0], i2 = n2[1], a2 = n2[2], o2 = t2[0], l2 = t2[1], c2 = t2[2], s2 = o2 - u2, f2 = l2 - i2, h2 = s2 * s2 + f2 * f2;
    if (Pa > h2) r2 = Math.log(c2 / a2) / Ya, e2 = function(n3) {
      return [u2 + n3 * s2, i2 + n3 * f2, a2 * Math.exp(Ya * n3 * r2)];
    };
    else {
      var g2 = Math.sqrt(h2), p2 = (c2 * c2 - a2 * a2 + Va * h2) / (2 * a2 * Za * g2), v2 = (c2 * c2 - a2 * a2 - Va * h2) / (2 * c2 * Za * g2), d2 = Math.log(Math.sqrt(p2 * p2 + 1) - p2), m2 = Math.log(Math.sqrt(v2 * v2 + 1) - v2);
      r2 = (m2 - d2) / Ya, e2 = function(n3) {
        var t3 = n3 * r2, e3 = rn(d2), o3 = a2 / (Za * g2) * (e3 * un(Ya * t3 + d2) - en(d2));
        return [u2 + o3 * s2, i2 + o3 * f2, a2 * e3 / rn(Ya * t3 + d2)];
      };
    }
    return e2.duration = 1e3 * r2, e2;
  }, oa.behavior.zoom = function() {
    function n2(n3) {
      n3.on(L2, f2).on($a + ".zoom", g2).on("dblclick.zoom", p2).on(R2, h2);
    }
    function e2(n3) {
      return [(n3[0] - k2.x) / k2.k, (n3[1] - k2.y) / k2.k];
    }
    function r2(n3) {
      return [n3[0] * k2.k + k2.x, n3[1] * k2.k + k2.y];
    }
    function u2(n3) {
      k2.k = Math.max(A2[0], Math.min(A2[1], n3));
    }
    function i2(n3, t2) {
      t2 = r2(t2), k2.x += n3[0] - t2[0], k2.y += n3[1] - t2[1];
    }
    function a2(t2, e3, r3, a3) {
      t2.__chart__ = { x: k2.x, y: k2.y, k: k2.k }, u2(Math.pow(2, a3)), i2(d2 = e3, r3), t2 = oa.select(t2), C2 > 0 && (t2 = t2.transition().duration(C2)), t2.call(n2.event);
    }
    function o2() {
      b2 && b2.domain(x2.range().map(function(n3) {
        return (n3 - k2.x) / k2.k;
      }).map(x2.invert)), w2 && w2.domain(_6.range().map(function(n3) {
        return (n3 - k2.y) / k2.k;
      }).map(_6.invert));
    }
    function l2(n3) {
      z2++ || n3({ type: "zoomstart" });
    }
    function c2(n3) {
      o2(), n3({ type: "zoom", scale: k2.k, translate: [k2.x, k2.y] });
    }
    function s2(n3) {
      --z2 || (n3({ type: "zoomend" }), d2 = null);
    }
    function f2() {
      function n3() {
        o3 = 1, i2(oa.mouse(u3), h3), c2(a3);
      }
      function r3() {
        f3.on(q2, null).on(T2, null), g3(o3), s2(a3);
      }
      var u3 = this, a3 = D2.of(u3, arguments), o3 = 0, f3 = oa.select(t(u3)).on(q2, n3).on(T2, r3), h3 = e2(oa.mouse(u3)), g3 = W(u3);
      Ol.call(u3), l2(a3);
    }
    function h2() {
      function n3() {
        var n4 = oa.touches(p3);
        return g3 = k2.k, n4.forEach(function(n5) {
          n5.identifier in d4 && (d4[n5.identifier] = e2(n5));
        }), n4;
      }
      function t2() {
        var t3 = oa.event.target;
        oa.select(t3).on(x3, r3).on(b3, o3), _7.push(t3);
        for (var e3 = oa.event.changedTouches, u3 = 0, i3 = e3.length; i3 > u3; ++u3) d4[e3[u3].identifier] = null;
        var l3 = n3(), c3 = Date.now();
        if (1 === l3.length) {
          if (500 > c3 - M2) {
            var s3 = l3[0];
            a2(p3, s3, d4[s3.identifier], Math.floor(Math.log(k2.k) / Math.LN2) + 1), S();
          }
          M2 = c3;
        } else if (l3.length > 1) {
          var s3 = l3[0], f3 = l3[1], h3 = s3[0] - f3[0], g4 = s3[1] - f3[1];
          m3 = h3 * h3 + g4 * g4;
        }
      }
      function r3() {
        var n4, t3, e3, r4, a3 = oa.touches(p3);
        Ol.call(p3);
        for (var o4 = 0, l3 = a3.length; l3 > o4; ++o4, r4 = null) if (e3 = a3[o4], r4 = d4[e3.identifier]) {
          if (t3) break;
          n4 = e3, t3 = r4;
        }
        if (r4) {
          var s3 = (s3 = e3[0] - n4[0]) * s3 + (s3 = e3[1] - n4[1]) * s3, f3 = m3 && Math.sqrt(s3 / m3);
          n4 = [(n4[0] + e3[0]) / 2, (n4[1] + e3[1]) / 2], t3 = [(t3[0] + r4[0]) / 2, (t3[1] + r4[1]) / 2], u2(f3 * g3);
        }
        M2 = null, i2(n4, t3), c2(v3);
      }
      function o3() {
        if (oa.event.touches.length) {
          for (var t3 = oa.event.changedTouches, e3 = 0, r4 = t3.length; r4 > e3; ++e3) delete d4[t3[e3].identifier];
          for (var u3 in d4) return void n3();
        }
        oa.selectAll(_7).on(y3, null), w3.on(L2, f2).on(R2, h2), N2(), s2(v3);
      }
      var g3, p3 = this, v3 = D2.of(p3, arguments), d4 = {}, m3 = 0, y3 = ".zoom-" + oa.event.changedTouches[0].identifier, x3 = "touchmove" + y3, b3 = "touchend" + y3, _7 = [], w3 = oa.select(p3), N2 = W(p3);
      t2(), l2(v3), w3.on(L2, null).on(R2, t2);
    }
    function g2() {
      var n3 = D2.of(this, arguments);
      y2 ? clearTimeout(y2) : (Ol.call(this), v2 = e2(d2 = m2 || oa.mouse(this)), l2(n3)), y2 = setTimeout(function() {
        y2 = null, s2(n3);
      }, 50), S(), u2(Math.pow(2, 2e-3 * Xa()) * k2.k), i2(d2, v2), c2(n3);
    }
    function p2() {
      var n3 = oa.mouse(this), t2 = Math.log(k2.k) / Math.LN2;
      a2(this, n3, e2(n3), oa.event.shiftKey ? Math.ceil(t2) - 1 : Math.floor(t2) + 1);
    }
    var v2, d2, m2, y2, M2, x2, b2, _6, w2, k2 = { x: 0, y: 0, k: 1 }, E2 = [960, 500], A2 = Ba, C2 = 250, z2 = 0, L2 = "mousedown.zoom", q2 = "mousemove.zoom", T2 = "mouseup.zoom", R2 = "touchstart.zoom", D2 = N(n2, "zoomstart", "zoom", "zoomend");
    return $a || ($a = "onwheel" in sa ? (Xa = function() {
      return -oa.event.deltaY * (oa.event.deltaMode ? 120 : 1);
    }, "wheel") : "onmousewheel" in sa ? (Xa = function() {
      return oa.event.wheelDelta;
    }, "mousewheel") : (Xa = function() {
      return -oa.event.detail;
    }, "MozMousePixelScroll")), n2.event = function(n3) {
      n3.each(function() {
        var n4 = D2.of(this, arguments), t2 = k2;
        Fl ? oa.select(this).transition().each("start.zoom", function() {
          k2 = this.__chart__ || { x: 0, y: 0, k: 1 }, l2(n4);
        }).tween("zoom:zoom", function() {
          var e3 = E2[0], r3 = E2[1], u3 = d2 ? d2[0] : e3 / 2, i3 = d2 ? d2[1] : r3 / 2, a3 = oa.interpolateZoom([(u3 - k2.x) / k2.k, (i3 - k2.y) / k2.k, e3 / k2.k], [(u3 - t2.x) / t2.k, (i3 - t2.y) / t2.k, e3 / t2.k]);
          return function(t3) {
            var r4 = a3(t3), o3 = e3 / r4[2];
            this.__chart__ = k2 = { x: u3 - r4[0] * o3, y: i3 - r4[1] * o3, k: o3 }, c2(n4);
          };
        }).each("interrupt.zoom", function() {
          s2(n4);
        }).each("end.zoom", function() {
          s2(n4);
        }) : (this.__chart__ = k2, l2(n4), c2(n4), s2(n4));
      });
    }, n2.translate = function(t2) {
      return arguments.length ? (k2 = { x: +t2[0], y: +t2[1], k: k2.k }, o2(), n2) : [k2.x, k2.y];
    }, n2.scale = function(t2) {
      return arguments.length ? (k2 = { x: k2.x, y: k2.y, k: null }, u2(+t2), o2(), n2) : k2.k;
    }, n2.scaleExtent = function(t2) {
      return arguments.length ? (A2 = null == t2 ? Ba : [+t2[0], +t2[1]], n2) : A2;
    }, n2.center = function(t2) {
      return arguments.length ? (m2 = t2 && [+t2[0], +t2[1]], n2) : m2;
    }, n2.size = function(t2) {
      return arguments.length ? (E2 = t2 && [+t2[0], +t2[1]], n2) : E2;
    }, n2.duration = function(t2) {
      return arguments.length ? (C2 = +t2, n2) : C2;
    }, n2.x = function(t2) {
      return arguments.length ? (b2 = t2, x2 = t2.copy(), k2 = { x: 0, y: 0, k: 1 }, n2) : b2;
    }, n2.y = function(t2) {
      return arguments.length ? (w2 = t2, _6 = t2.copy(), k2 = { x: 0, y: 0, k: 1 }, n2) : w2;
    }, oa.rebind(n2, D2, "on");
  };
  var Xa, $a, Ba = [0, 1 / 0];
  oa.color = on, on.prototype.toString = function() {
    return this.rgb() + "";
  }, oa.hsl = ln;
  var Wa = ln.prototype = new on();
  Wa.brighter = function(n2) {
    return n2 = Math.pow(0.7, arguments.length ? n2 : 1), new ln(this.h, this.s, this.l / n2);
  }, Wa.darker = function(n2) {
    return n2 = Math.pow(0.7, arguments.length ? n2 : 1), new ln(this.h, this.s, n2 * this.l);
  }, Wa.rgb = function() {
    return cn(this.h, this.s, this.l);
  }, oa.hcl = sn;
  var Ja = sn.prototype = new on();
  Ja.brighter = function(n2) {
    return new sn(this.h, this.c, Math.min(100, this.l + Ga * (arguments.length ? n2 : 1)));
  }, Ja.darker = function(n2) {
    return new sn(this.h, this.c, Math.max(0, this.l - Ga * (arguments.length ? n2 : 1)));
  }, Ja.rgb = function() {
    return fn(this.h, this.c, this.l).rgb();
  }, oa.lab = hn;
  var Ga = 18, Ka = 0.95047, Qa = 1, no = 1.08883, to = hn.prototype = new on();
  to.brighter = function(n2) {
    return new hn(Math.min(100, this.l + Ga * (arguments.length ? n2 : 1)), this.a, this.b);
  }, to.darker = function(n2) {
    return new hn(Math.max(0, this.l - Ga * (arguments.length ? n2 : 1)), this.a, this.b);
  }, to.rgb = function() {
    return gn(this.l, this.a, this.b);
  }, oa.rgb = yn;
  var eo = yn.prototype = new on();
  eo.brighter = function(n2) {
    n2 = Math.pow(0.7, arguments.length ? n2 : 1);
    var t2 = this.r, e2 = this.g, r2 = this.b, u2 = 30;
    return t2 || e2 || r2 ? (t2 && u2 > t2 && (t2 = u2), e2 && u2 > e2 && (e2 = u2), r2 && u2 > r2 && (r2 = u2), new yn(Math.min(255, t2 / n2), Math.min(255, e2 / n2), Math.min(255, r2 / n2))) : new yn(u2, u2, u2);
  }, eo.darker = function(n2) {
    return n2 = Math.pow(0.7, arguments.length ? n2 : 1), new yn(n2 * this.r, n2 * this.g, n2 * this.b);
  }, eo.hsl = function() {
    return wn(this.r, this.g, this.b);
  }, eo.toString = function() {
    return "#" + bn(this.r) + bn(this.g) + bn(this.b);
  };
  var ro = oa.map({ aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 });
  ro.forEach(function(n2, t2) {
    ro.set(n2, Mn(t2));
  }), oa.functor = En, oa.xhr = An(y), oa.dsv = function(n2, t2) {
    function e2(n3, e3, i3) {
      arguments.length < 3 && (i3 = e3, e3 = null);
      var a3 = Cn(n3, t2, null == e3 ? r2 : u2(e3), i3);
      return a3.row = function(n4) {
        return arguments.length ? a3.response(null == (e3 = n4) ? r2 : u2(n4)) : e3;
      }, a3;
    }
    function r2(n3) {
      return e2.parse(n3.responseText);
    }
    function u2(n3) {
      return function(t3) {
        return e2.parse(t3.responseText, n3);
      };
    }
    function i2(t3) {
      return t3.map(a2).join(n2);
    }
    function a2(n3) {
      return o2.test(n3) ? '"' + n3.replace(/\"/g, '""') + '"' : n3;
    }
    var o2 = new RegExp('["' + n2 + "\n]"), l2 = n2.charCodeAt(0);
    return e2.parse = function(n3, t3) {
      var r3;
      return e2.parseRows(n3, function(n4, e3) {
        if (r3) return r3(n4, e3 - 1);
        var u3 = new Function("d", "return {" + n4.map(function(n5, t4) {
          return JSON.stringify(n5) + ": d[" + t4 + "]";
        }).join(",") + "}");
        r3 = t3 ? function(n5, e4) {
          return t3(u3(n5), e4);
        } : u3;
      });
    }, e2.parseRows = function(n3, t3) {
      function e3() {
        if (s2 >= c2) return a3;
        if (u3) return u3 = false, i3;
        var t4 = s2;
        if (34 === n3.charCodeAt(t4)) {
          for (var e4 = t4; e4++ < c2; ) if (34 === n3.charCodeAt(e4)) {
            if (34 !== n3.charCodeAt(e4 + 1)) break;
            ++e4;
          }
          s2 = e4 + 2;
          var r4 = n3.charCodeAt(e4 + 1);
          return 13 === r4 ? (u3 = true, 10 === n3.charCodeAt(e4 + 2) && ++s2) : 10 === r4 && (u3 = true), n3.slice(t4 + 1, e4).replace(/""/g, '"');
        }
        for (; c2 > s2; ) {
          var r4 = n3.charCodeAt(s2++), o4 = 1;
          if (10 === r4) u3 = true;
          else if (13 === r4) u3 = true, 10 === n3.charCodeAt(s2) && (++s2, ++o4);
          else if (r4 !== l2) continue;
          return n3.slice(t4, s2 - o4);
        }
        return n3.slice(t4);
      }
      for (var r3, u3, i3 = {}, a3 = {}, o3 = [], c2 = n3.length, s2 = 0, f2 = 0; (r3 = e3()) !== a3; ) {
        for (var h2 = []; r3 !== i3 && r3 !== a3; ) h2.push(r3), r3 = e3();
        t3 && null == (h2 = t3(h2, f2++)) || o3.push(h2);
      }
      return o3;
    }, e2.format = function(t3) {
      if (Array.isArray(t3[0])) return e2.formatRows(t3);
      var r3 = new m(), u3 = [];
      return t3.forEach(function(n3) {
        for (var t4 in n3) r3.has(t4) || u3.push(r3.add(t4));
      }), [u3.map(a2).join(n2)].concat(t3.map(function(t4) {
        return u3.map(function(n3) {
          return a2(t4[n3]);
        }).join(n2);
      })).join("\n");
    }, e2.formatRows = function(n3) {
      return n3.map(i2).join("\n");
    }, e2;
  }, oa.csv = oa.dsv(",", "text/csv"), oa.tsv = oa.dsv("	", "text/tab-separated-values");
  var uo, io, ao, oo, lo = this[x(this, "requestAnimationFrame")] || function(n2) {
    setTimeout(n2, 17);
  };
  oa.timer = function() {
    qn.apply(this, arguments);
  }, oa.timer.flush = function() {
    Rn(), Dn();
  }, oa.round = function(n2, t2) {
    return t2 ? Math.round(n2 * (t2 = Math.pow(10, t2))) / t2 : Math.round(n2);
  };
  var co = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(jn);
  oa.formatPrefix = function(n2, t2) {
    var e2 = 0;
    return (n2 = +n2) && (0 > n2 && (n2 *= -1), t2 && (n2 = oa.round(n2, Pn(n2, t2))), e2 = 1 + Math.floor(1e-12 + Math.log(n2) / Math.LN10), e2 = Math.max(-24, Math.min(24, 3 * Math.floor((e2 - 1) / 3)))), co[8 + e2 / 3];
  };
  var so = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, fo = oa.map({ b: function(n2) {
    return n2.toString(2);
  }, c: function(n2) {
    return String.fromCharCode(n2);
  }, o: function(n2) {
    return n2.toString(8);
  }, x: function(n2) {
    return n2.toString(16);
  }, X: function(n2) {
    return n2.toString(16).toUpperCase();
  }, g: function(n2, t2) {
    return n2.toPrecision(t2);
  }, e: function(n2, t2) {
    return n2.toExponential(t2);
  }, f: function(n2, t2) {
    return n2.toFixed(t2);
  }, r: function(n2, t2) {
    return (n2 = oa.round(n2, Pn(n2, t2))).toFixed(Math.max(0, Math.min(20, Pn(n2 * (1 + 1e-15), t2))));
  } }), ho = oa.time = {}, go = Date;
  Hn.prototype = { getDate: function() {
    return this._.getUTCDate();
  }, getDay: function() {
    return this._.getUTCDay();
  }, getFullYear: function() {
    return this._.getUTCFullYear();
  }, getHours: function() {
    return this._.getUTCHours();
  }, getMilliseconds: function() {
    return this._.getUTCMilliseconds();
  }, getMinutes: function() {
    return this._.getUTCMinutes();
  }, getMonth: function() {
    return this._.getUTCMonth();
  }, getSeconds: function() {
    return this._.getUTCSeconds();
  }, getTime: function() {
    return this._.getTime();
  }, getTimezoneOffset: function() {
    return 0;
  }, valueOf: function() {
    return this._.valueOf();
  }, setDate: function() {
    po.setUTCDate.apply(this._, arguments);
  }, setDay: function() {
    po.setUTCDay.apply(this._, arguments);
  }, setFullYear: function() {
    po.setUTCFullYear.apply(this._, arguments);
  }, setHours: function() {
    po.setUTCHours.apply(this._, arguments);
  }, setMilliseconds: function() {
    po.setUTCMilliseconds.apply(this._, arguments);
  }, setMinutes: function() {
    po.setUTCMinutes.apply(this._, arguments);
  }, setMonth: function() {
    po.setUTCMonth.apply(this._, arguments);
  }, setSeconds: function() {
    po.setUTCSeconds.apply(this._, arguments);
  }, setTime: function() {
    po.setTime.apply(this._, arguments);
  } };
  var po = Date.prototype;
  ho.year = On(function(n2) {
    return n2 = ho.day(n2), n2.setMonth(0, 1), n2;
  }, function(n2, t2) {
    n2.setFullYear(n2.getFullYear() + t2);
  }, function(n2) {
    return n2.getFullYear();
  }), ho.years = ho.year.range, ho.years.utc = ho.year.utc.range, ho.day = On(function(n2) {
    var t2 = new go(2e3, 0);
    return t2.setFullYear(n2.getFullYear(), n2.getMonth(), n2.getDate()), t2;
  }, function(n2, t2) {
    n2.setDate(n2.getDate() + t2);
  }, function(n2) {
    return n2.getDate() - 1;
  }), ho.days = ho.day.range, ho.days.utc = ho.day.utc.range, ho.dayOfYear = function(n2) {
    var t2 = ho.year(n2);
    return Math.floor((n2 - t2 - 6e4 * (n2.getTimezoneOffset() - t2.getTimezoneOffset())) / 864e5);
  }, ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(n2, t2) {
    t2 = 7 - t2;
    var e2 = ho[n2] = On(function(n3) {
      return (n3 = ho.day(n3)).setDate(n3.getDate() - (n3.getDay() + t2) % 7), n3;
    }, function(n3, t3) {
      n3.setDate(n3.getDate() + 7 * Math.floor(t3));
    }, function(n3) {
      var e3 = ho.year(n3).getDay();
      return Math.floor((ho.dayOfYear(n3) + (e3 + t2) % 7) / 7) - (e3 !== t2);
    });
    ho[n2 + "s"] = e2.range, ho[n2 + "s"].utc = e2.utc.range, ho[n2 + "OfYear"] = function(n3) {
      var e3 = ho.year(n3).getDay();
      return Math.floor((ho.dayOfYear(n3) + (e3 + t2) % 7) / 7);
    };
  }), ho.week = ho.sunday, ho.weeks = ho.sunday.range, ho.weeks.utc = ho.sunday.utc.range, ho.weekOfYear = ho.sundayOfYear;
  var vo = { "-": "", _: " ", 0: "0" }, mo = /^\s*\d+/, yo = /^%/;
  oa.locale = function(n2) {
    return { numberFormat: Un(n2), timeFormat: Yn(n2) };
  };
  var Mo = oa.locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  oa.format = Mo.numberFormat, oa.geo = {}, st.prototype = { s: 0, t: 0, add: function(n2) {
    ft(n2, this.t, xo), ft(xo.s, this.s, this), this.s ? this.t += xo.t : this.s = xo.t;
  }, reset: function() {
    this.s = this.t = 0;
  }, valueOf: function() {
    return this.s;
  } };
  var xo = new st();
  oa.geo.stream = function(n2, t2) {
    n2 && bo.hasOwnProperty(n2.type) ? bo[n2.type](n2, t2) : ht(n2, t2);
  };
  var bo = { Feature: function(n2, t2) {
    ht(n2.geometry, t2);
  }, FeatureCollection: function(n2, t2) {
    for (var e2 = n2.features, r2 = -1, u2 = e2.length; ++r2 < u2; ) ht(e2[r2].geometry, t2);
  } }, _o = { Sphere: function(n2, t2) {
    t2.sphere();
  }, Point: function(n2, t2) {
    n2 = n2.coordinates, t2.point(n2[0], n2[1], n2[2]);
  }, MultiPoint: function(n2, t2) {
    for (var e2 = n2.coordinates, r2 = -1, u2 = e2.length; ++r2 < u2; ) n2 = e2[r2], t2.point(n2[0], n2[1], n2[2]);
  }, LineString: function(n2, t2) {
    gt(n2.coordinates, t2, 0);
  }, MultiLineString: function(n2, t2) {
    for (var e2 = n2.coordinates, r2 = -1, u2 = e2.length; ++r2 < u2; ) gt(e2[r2], t2, 0);
  }, Polygon: function(n2, t2) {
    pt(n2.coordinates, t2);
  }, MultiPolygon: function(n2, t2) {
    for (var e2 = n2.coordinates, r2 = -1, u2 = e2.length; ++r2 < u2; ) pt(e2[r2], t2);
  }, GeometryCollection: function(n2, t2) {
    for (var e2 = n2.geometries, r2 = -1, u2 = e2.length; ++r2 < u2; ) ht(e2[r2], t2);
  } };
  oa.geo.area = function(n2) {
    return wo = 0, oa.geo.stream(n2, ko), wo;
  };
  var wo, So = new st(), ko = { sphere: function() {
    wo += 4 * ja;
  }, point: b, lineStart: b, lineEnd: b, polygonStart: function() {
    So.reset(), ko.lineStart = vt;
  }, polygonEnd: function() {
    var n2 = 2 * So;
    wo += 0 > n2 ? 4 * ja + n2 : n2, ko.lineStart = ko.lineEnd = ko.point = b;
  } };
  oa.geo.bounds = /* @__PURE__ */ function() {
    function n2(n3, t3) {
      M2.push(x2 = [s2 = n3, h2 = n3]), f2 > t3 && (f2 = t3), t3 > g2 && (g2 = t3);
    }
    function t2(t3, e3) {
      var r3 = dt([t3 * Oa, e3 * Oa]);
      if (m2) {
        var u3 = yt(m2, r3), i3 = [u3[1], -u3[0], 0], a3 = yt(i3, u3);
        bt(a3), a3 = _t(a3);
        var l3 = t3 - p2, c3 = l3 > 0 ? 1 : -1, v3 = a3[0] * Ia * c3, d4 = Ma(l3) > 180;
        if (d4 ^ (v3 > c3 * p2 && c3 * t3 > v3)) {
          var y3 = a3[1] * Ia;
          y3 > g2 && (g2 = y3);
        } else if (v3 = (v3 + 360) % 360 - 180, d4 ^ (v3 > c3 * p2 && c3 * t3 > v3)) {
          var y3 = -a3[1] * Ia;
          f2 > y3 && (f2 = y3);
        } else f2 > e3 && (f2 = e3), e3 > g2 && (g2 = e3);
        d4 ? p2 > t3 ? o2(s2, t3) > o2(s2, h2) && (h2 = t3) : o2(t3, h2) > o2(s2, h2) && (s2 = t3) : h2 >= s2 ? (s2 > t3 && (s2 = t3), t3 > h2 && (h2 = t3)) : t3 > p2 ? o2(s2, t3) > o2(s2, h2) && (h2 = t3) : o2(t3, h2) > o2(s2, h2) && (s2 = t3);
      } else n2(t3, e3);
      m2 = r3, p2 = t3;
    }
    function e2() {
      b2.point = t2;
    }
    function r2() {
      x2[0] = s2, x2[1] = h2, b2.point = n2, m2 = null;
    }
    function u2(n3, e3) {
      if (m2) {
        var r3 = n3 - p2;
        y2 += Ma(r3) > 180 ? r3 + (r3 > 0 ? 360 : -360) : r3;
      } else v2 = n3, d2 = e3;
      ko.point(n3, e3), t2(n3, e3);
    }
    function i2() {
      ko.lineStart();
    }
    function a2() {
      u2(v2, d2), ko.lineEnd(), Ma(y2) > Da && (s2 = -(h2 = 180)), x2[0] = s2, x2[1] = h2, m2 = null;
    }
    function o2(n3, t3) {
      return (t3 -= n3) < 0 ? t3 + 360 : t3;
    }
    function l2(n3, t3) {
      return n3[0] - t3[0];
    }
    function c2(n3, t3) {
      return t3[0] <= t3[1] ? t3[0] <= n3 && n3 <= t3[1] : n3 < t3[0] || t3[1] < n3;
    }
    var s2, f2, h2, g2, p2, v2, d2, m2, y2, M2, x2, b2 = { point: n2, lineStart: e2, lineEnd: r2, polygonStart: function() {
      b2.point = u2, b2.lineStart = i2, b2.lineEnd = a2, y2 = 0, ko.polygonStart();
    }, polygonEnd: function() {
      ko.polygonEnd(), b2.point = n2, b2.lineStart = e2, b2.lineEnd = r2, 0 > So ? (s2 = -(h2 = 180), f2 = -(g2 = 90)) : y2 > Da ? g2 = 90 : -Da > y2 && (f2 = -90), x2[0] = s2, x2[1] = h2;
    } };
    return function(n3) {
      g2 = h2 = -(s2 = f2 = 1 / 0), M2 = [], oa.geo.stream(n3, b2);
      var t3 = M2.length;
      if (t3) {
        M2.sort(l2);
        for (var e3, r3 = 1, u3 = M2[0], i3 = [u3]; t3 > r3; ++r3) e3 = M2[r3], c2(e3[0], u3) || c2(e3[1], u3) ? (o2(u3[0], e3[1]) > o2(u3[0], u3[1]) && (u3[1] = e3[1]), o2(e3[0], u3[1]) > o2(u3[0], u3[1]) && (u3[0] = e3[0])) : i3.push(u3 = e3);
        for (var a3, e3, p3 = -(1 / 0), t3 = i3.length - 1, r3 = 0, u3 = i3[t3]; t3 >= r3; u3 = e3, ++r3) e3 = i3[r3], (a3 = o2(u3[1], e3[0])) > p3 && (p3 = a3, s2 = e3[0], h2 = u3[1]);
      }
      return M2 = x2 = null, s2 === 1 / 0 || f2 === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[s2, f2], [h2, g2]];
    };
  }(), oa.geo.centroid = function(n2) {
    No = Eo = Ao = Co = zo = Lo = qo = To = Ro = Do = Po = 0, oa.geo.stream(n2, jo);
    var t2 = Ro, e2 = Do, r2 = Po, u2 = t2 * t2 + e2 * e2 + r2 * r2;
    return Pa > u2 && (t2 = Lo, e2 = qo, r2 = To, Da > Eo && (t2 = Ao, e2 = Co, r2 = zo), u2 = t2 * t2 + e2 * e2 + r2 * r2, Pa > u2) ? [NaN, NaN] : [Math.atan2(e2, t2) * Ia, tn(r2 / Math.sqrt(u2)) * Ia];
  };
  var No, Eo, Ao, Co, zo, Lo, qo, To, Ro, Do, Po, jo = { sphere: b, point: St, lineStart: Nt, lineEnd: Et, polygonStart: function() {
    jo.lineStart = At;
  }, polygonEnd: function() {
    jo.lineStart = Nt;
  } }, Uo = Rt(zt, Ut, Ht, [-ja, -ja / 2]), Fo = 1e9;
  oa.geo.clipExtent = function() {
    var n2, t2, e2, r2, u2, i2, a2 = { stream: function(n3) {
      return u2 && (u2.valid = false), u2 = i2(n3), u2.valid = true, u2;
    }, extent: function(o2) {
      return arguments.length ? (i2 = Zt(n2 = +o2[0][0], t2 = +o2[0][1], e2 = +o2[1][0], r2 = +o2[1][1]), u2 && (u2.valid = false, u2 = null), a2) : [[n2, t2], [e2, r2]];
    } };
    return a2.extent([[0, 0], [960, 500]]);
  }, (oa.geo.conicEqualArea = function() {
    return Vt(Xt);
  }).raw = Xt, oa.geo.albers = function() {
    return oa.geo.conicEqualArea().rotate([96, 0]).center([-0.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
  }, oa.geo.albersUsa = function() {
    function n2(n3) {
      var i3 = n3[0], a3 = n3[1];
      return t2 = null, e2(i3, a3), t2 || (r2(i3, a3), t2) || u2(i3, a3), t2;
    }
    var t2, e2, r2, u2, i2 = oa.geo.albers(), a2 = oa.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), o2 = oa.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), l2 = { point: function(n3, e3) {
      t2 = [n3, e3];
    } };
    return n2.invert = function(n3) {
      var t3 = i2.scale(), e3 = i2.translate(), r3 = (n3[0] - e3[0]) / t3, u3 = (n3[1] - e3[1]) / t3;
      return (u3 >= 0.12 && 0.234 > u3 && r3 >= -0.425 && -0.214 > r3 ? a2 : u3 >= 0.166 && 0.234 > u3 && r3 >= -0.214 && -0.115 > r3 ? o2 : i2).invert(n3);
    }, n2.stream = function(n3) {
      var t3 = i2.stream(n3), e3 = a2.stream(n3), r3 = o2.stream(n3);
      return { point: function(n4, u3) {
        t3.point(n4, u3), e3.point(n4, u3), r3.point(n4, u3);
      }, sphere: function() {
        t3.sphere(), e3.sphere(), r3.sphere();
      }, lineStart: function() {
        t3.lineStart(), e3.lineStart(), r3.lineStart();
      }, lineEnd: function() {
        t3.lineEnd(), e3.lineEnd(), r3.lineEnd();
      }, polygonStart: function() {
        t3.polygonStart(), e3.polygonStart(), r3.polygonStart();
      }, polygonEnd: function() {
        t3.polygonEnd(), e3.polygonEnd(), r3.polygonEnd();
      } };
    }, n2.precision = function(t3) {
      return arguments.length ? (i2.precision(t3), a2.precision(t3), o2.precision(t3), n2) : i2.precision();
    }, n2.scale = function(t3) {
      return arguments.length ? (i2.scale(t3), a2.scale(0.35 * t3), o2.scale(t3), n2.translate(i2.translate())) : i2.scale();
    }, n2.translate = function(t3) {
      if (!arguments.length) return i2.translate();
      var c2 = i2.scale(), s2 = +t3[0], f2 = +t3[1];
      return e2 = i2.translate(t3).clipExtent([[s2 - 0.455 * c2, f2 - 0.238 * c2], [s2 + 0.455 * c2, f2 + 0.238 * c2]]).stream(l2).point, r2 = a2.translate([s2 - 0.307 * c2, f2 + 0.201 * c2]).clipExtent([[s2 - 0.425 * c2 + Da, f2 + 0.12 * c2 + Da], [s2 - 0.214 * c2 - Da, f2 + 0.234 * c2 - Da]]).stream(l2).point, u2 = o2.translate([s2 - 0.205 * c2, f2 + 0.212 * c2]).clipExtent([[s2 - 0.214 * c2 + Da, f2 + 0.166 * c2 + Da], [s2 - 0.115 * c2 - Da, f2 + 0.234 * c2 - Da]]).stream(l2).point, n2;
    }, n2.scale(1070);
  };
  var Ho, Oo, Io, Yo, Zo, Vo, Xo = { point: b, lineStart: b, lineEnd: b, polygonStart: function() {
    Oo = 0, Xo.lineStart = $t;
  }, polygonEnd: function() {
    Xo.lineStart = Xo.lineEnd = Xo.point = b, Ho += Ma(Oo / 2);
  } }, $o = { point: Bt, lineStart: b, lineEnd: b, polygonStart: b, polygonEnd: b }, Bo = { point: Gt, lineStart: Kt, lineEnd: Qt, polygonStart: function() {
    Bo.lineStart = ne;
  }, polygonEnd: function() {
    Bo.point = Gt, Bo.lineStart = Kt, Bo.lineEnd = Qt;
  } };
  oa.geo.path = function() {
    function n2(n3) {
      return n3 && ("function" == typeof o2 && i2.pointRadius(+o2.apply(this, arguments)), a2 && a2.valid || (a2 = u2(i2)), oa.geo.stream(n3, a2)), i2.result();
    }
    function t2() {
      return a2 = null, n2;
    }
    var e2, r2, u2, i2, a2, o2 = 4.5;
    return n2.area = function(n3) {
      return Ho = 0, oa.geo.stream(n3, u2(Xo)), Ho;
    }, n2.centroid = function(n3) {
      return Ao = Co = zo = Lo = qo = To = Ro = Do = Po = 0, oa.geo.stream(n3, u2(Bo)), Po ? [Ro / Po, Do / Po] : To ? [Lo / To, qo / To] : zo ? [Ao / zo, Co / zo] : [NaN, NaN];
    }, n2.bounds = function(n3) {
      return Zo = Vo = -(Io = Yo = 1 / 0), oa.geo.stream(n3, u2($o)), [[Io, Yo], [Zo, Vo]];
    }, n2.projection = function(n3) {
      return arguments.length ? (u2 = (e2 = n3) ? n3.stream || re(n3) : y, t2()) : e2;
    }, n2.context = function(n3) {
      return arguments.length ? (i2 = null == (r2 = n3) ? new Wt() : new te(n3), "function" != typeof o2 && i2.pointRadius(o2), t2()) : r2;
    }, n2.pointRadius = function(t3) {
      return arguments.length ? (o2 = "function" == typeof t3 ? t3 : (i2.pointRadius(+t3), +t3), n2) : o2;
    }, n2.projection(oa.geo.albersUsa()).context(null);
  }, oa.geo.transform = function(n2) {
    return { stream: function(t2) {
      var e2 = new ue(t2);
      for (var r2 in n2) e2[r2] = n2[r2];
      return e2;
    } };
  }, ue.prototype = { point: function(n2, t2) {
    this.stream.point(n2, t2);
  }, sphere: function() {
    this.stream.sphere();
  }, lineStart: function() {
    this.stream.lineStart();
  }, lineEnd: function() {
    this.stream.lineEnd();
  }, polygonStart: function() {
    this.stream.polygonStart();
  }, polygonEnd: function() {
    this.stream.polygonEnd();
  } }, oa.geo.projection = ae, oa.geo.projectionMutator = oe, (oa.geo.equirectangular = function() {
    return ae(ce);
  }).raw = ce.invert = ce, oa.geo.rotation = function(n2) {
    function t2(t3) {
      return t3 = n2(t3[0] * Oa, t3[1] * Oa), t3[0] *= Ia, t3[1] *= Ia, t3;
    }
    return n2 = fe(n2[0] % 360 * Oa, n2[1] * Oa, n2.length > 2 ? n2[2] * Oa : 0), t2.invert = function(t3) {
      return t3 = n2.invert(t3[0] * Oa, t3[1] * Oa), t3[0] *= Ia, t3[1] *= Ia, t3;
    }, t2;
  }, se.invert = ce, oa.geo.circle = function() {
    function n2() {
      var n3 = "function" == typeof r2 ? r2.apply(this, arguments) : r2, t3 = fe(-n3[0] * Oa, -n3[1] * Oa, 0).invert, u3 = [];
      return e2(null, null, 1, { point: function(n4, e3) {
        u3.push(n4 = t3(n4, e3)), n4[0] *= Ia, n4[1] *= Ia;
      } }), { type: "Polygon", coordinates: [u3] };
    }
    var t2, e2, r2 = [0, 0], u2 = 6;
    return n2.origin = function(t3) {
      return arguments.length ? (r2 = t3, n2) : r2;
    }, n2.angle = function(r3) {
      return arguments.length ? (e2 = ve((t2 = +r3) * Oa, u2 * Oa), n2) : t2;
    }, n2.precision = function(r3) {
      return arguments.length ? (e2 = ve(t2 * Oa, (u2 = +r3) * Oa), n2) : u2;
    }, n2.angle(90);
  }, oa.geo.distance = function(n2, t2) {
    var e2, r2 = (t2[0] - n2[0]) * Oa, u2 = n2[1] * Oa, i2 = t2[1] * Oa, a2 = Math.sin(r2), o2 = Math.cos(r2), l2 = Math.sin(u2), c2 = Math.cos(u2), s2 = Math.sin(i2), f2 = Math.cos(i2);
    return Math.atan2(Math.sqrt((e2 = f2 * a2) * e2 + (e2 = c2 * s2 - l2 * f2 * o2) * e2), l2 * s2 + c2 * f2 * o2);
  }, oa.geo.graticule = function() {
    function n2() {
      return { type: "MultiLineString", coordinates: t2() };
    }
    function t2() {
      return oa.range(Math.ceil(i2 / d2) * d2, u2, d2).map(h2).concat(oa.range(Math.ceil(c2 / m2) * m2, l2, m2).map(g2)).concat(oa.range(Math.ceil(r2 / p2) * p2, e2, p2).filter(function(n3) {
        return Ma(n3 % d2) > Da;
      }).map(s2)).concat(oa.range(Math.ceil(o2 / v2) * v2, a2, v2).filter(function(n3) {
        return Ma(n3 % m2) > Da;
      }).map(f2));
    }
    var e2, r2, u2, i2, a2, o2, l2, c2, s2, f2, h2, g2, p2 = 10, v2 = p2, d2 = 90, m2 = 360, y2 = 2.5;
    return n2.lines = function() {
      return t2().map(function(n3) {
        return { type: "LineString", coordinates: n3 };
      });
    }, n2.outline = function() {
      return { type: "Polygon", coordinates: [h2(i2).concat(g2(l2).slice(1), h2(u2).reverse().slice(1), g2(c2).reverse().slice(1))] };
    }, n2.extent = function(t3) {
      return arguments.length ? n2.majorExtent(t3).minorExtent(t3) : n2.minorExtent();
    }, n2.majorExtent = function(t3) {
      return arguments.length ? (i2 = +t3[0][0], u2 = +t3[1][0], c2 = +t3[0][1], l2 = +t3[1][1], i2 > u2 && (t3 = i2, i2 = u2, u2 = t3), c2 > l2 && (t3 = c2, c2 = l2, l2 = t3), n2.precision(y2)) : [[i2, c2], [u2, l2]];
    }, n2.minorExtent = function(t3) {
      return arguments.length ? (r2 = +t3[0][0], e2 = +t3[1][0], o2 = +t3[0][1], a2 = +t3[1][1], r2 > e2 && (t3 = r2, r2 = e2, e2 = t3), o2 > a2 && (t3 = o2, o2 = a2, a2 = t3), n2.precision(y2)) : [[r2, o2], [e2, a2]];
    }, n2.step = function(t3) {
      return arguments.length ? n2.majorStep(t3).minorStep(t3) : n2.minorStep();
    }, n2.majorStep = function(t3) {
      return arguments.length ? (d2 = +t3[0], m2 = +t3[1], n2) : [d2, m2];
    }, n2.minorStep = function(t3) {
      return arguments.length ? (p2 = +t3[0], v2 = +t3[1], n2) : [p2, v2];
    }, n2.precision = function(t3) {
      return arguments.length ? (y2 = +t3, s2 = me(o2, a2, 90), f2 = ye(r2, e2, y2), h2 = me(c2, l2, 90), g2 = ye(i2, u2, y2), n2) : y2;
    }, n2.majorExtent([[-180, -90 + Da], [180, 90 - Da]]).minorExtent([[-180, -80 - Da], [180, 80 + Da]]);
  }, oa.geo.greatArc = function() {
    function n2() {
      return { type: "LineString", coordinates: [t2 || r2.apply(this, arguments), e2 || u2.apply(this, arguments)] };
    }
    var t2, e2, r2 = Me, u2 = xe;
    return n2.distance = function() {
      return oa.geo.distance(t2 || r2.apply(this, arguments), e2 || u2.apply(this, arguments));
    }, n2.source = function(e3) {
      return arguments.length ? (r2 = e3, t2 = "function" == typeof e3 ? null : e3, n2) : r2;
    }, n2.target = function(t3) {
      return arguments.length ? (u2 = t3, e2 = "function" == typeof t3 ? null : t3, n2) : u2;
    }, n2.precision = function() {
      return arguments.length ? n2 : 0;
    }, n2;
  }, oa.geo.interpolate = function(n2, t2) {
    return be(n2[0] * Oa, n2[1] * Oa, t2[0] * Oa, t2[1] * Oa);
  }, oa.geo.length = function(n2) {
    return Wo = 0, oa.geo.stream(n2, Jo), Wo;
  };
  var Wo, Jo = { sphere: b, point: b, lineStart: _e, lineEnd: b, polygonStart: b, polygonEnd: b }, Go = we(function(n2) {
    return Math.sqrt(2 / (1 + n2));
  }, function(n2) {
    return 2 * Math.asin(n2 / 2);
  });
  (oa.geo.azimuthalEqualArea = function() {
    return ae(Go);
  }).raw = Go;
  var Ko = we(function(n2) {
    var t2 = Math.acos(n2);
    return t2 && t2 / Math.sin(t2);
  }, y);
  (oa.geo.azimuthalEquidistant = function() {
    return ae(Ko);
  }).raw = Ko, (oa.geo.conicConformal = function() {
    return Vt(Se);
  }).raw = Se, (oa.geo.conicEquidistant = function() {
    return Vt(ke);
  }).raw = ke;
  var Qo = we(function(n2) {
    return 1 / n2;
  }, Math.atan);
  (oa.geo.gnomonic = function() {
    return ae(Qo);
  }).raw = Qo, Ne.invert = function(n2, t2) {
    return [n2, 2 * Math.atan(Math.exp(t2)) - Ha];
  }, (oa.geo.mercator = function() {
    return Ee(Ne);
  }).raw = Ne;
  var nl = we(function() {
    return 1;
  }, Math.asin);
  (oa.geo.orthographic = function() {
    return ae(nl);
  }).raw = nl;
  var tl = we(function(n2) {
    return 1 / (1 + n2);
  }, function(n2) {
    return 2 * Math.atan(n2);
  });
  (oa.geo.stereographic = function() {
    return ae(tl);
  }).raw = tl, Ae.invert = function(n2, t2) {
    return [-t2, 2 * Math.atan(Math.exp(n2)) - Ha];
  }, (oa.geo.transverseMercator = function() {
    var n2 = Ee(Ae), t2 = n2.center, e2 = n2.rotate;
    return n2.center = function(n3) {
      return n3 ? t2([-n3[1], n3[0]]) : (n3 = t2(), [n3[1], -n3[0]]);
    }, n2.rotate = function(n3) {
      return n3 ? e2([n3[0], n3[1], n3.length > 2 ? n3[2] + 90 : 90]) : (n3 = e2(), [n3[0], n3[1], n3[2] - 90]);
    }, e2([0, 0, 90]);
  }).raw = Ae, oa.geom = {}, oa.geom.hull = function(n2) {
    function t2(n3) {
      if (n3.length < 3) return [];
      var t3, u2 = En(e2), i2 = En(r2), a2 = n3.length, o2 = [], l2 = [];
      for (t3 = 0; a2 > t3; t3++) o2.push([+u2.call(this, n3[t3], t3), +i2.call(this, n3[t3], t3), t3]);
      for (o2.sort(qe), t3 = 0; a2 > t3; t3++) l2.push([o2[t3][0], -o2[t3][1]]);
      var c2 = Le(o2), s2 = Le(l2), f2 = s2[0] === c2[0], h2 = s2[s2.length - 1] === c2[c2.length - 1], g2 = [];
      for (t3 = c2.length - 1; t3 >= 0; --t3) g2.push(n3[o2[c2[t3]][2]]);
      for (t3 = +f2; t3 < s2.length - h2; ++t3) g2.push(n3[o2[s2[t3]][2]]);
      return g2;
    }
    var e2 = Ce, r2 = ze;
    return arguments.length ? t2(n2) : (t2.x = function(n3) {
      return arguments.length ? (e2 = n3, t2) : e2;
    }, t2.y = function(n3) {
      return arguments.length ? (r2 = n3, t2) : r2;
    }, t2);
  }, oa.geom.polygon = function(n2) {
    return Sa(n2, el), n2;
  };
  var el = oa.geom.polygon.prototype = [];
  el.area = function() {
    for (var n2, t2 = -1, e2 = this.length, r2 = this[e2 - 1], u2 = 0; ++t2 < e2; ) n2 = r2, r2 = this[t2], u2 += n2[1] * r2[0] - n2[0] * r2[1];
    return 0.5 * u2;
  }, el.centroid = function(n2) {
    var t2, e2, r2 = -1, u2 = this.length, i2 = 0, a2 = 0, o2 = this[u2 - 1];
    for (arguments.length || (n2 = -1 / (6 * this.area())); ++r2 < u2; ) t2 = o2, o2 = this[r2], e2 = t2[0] * o2[1] - o2[0] * t2[1], i2 += (t2[0] + o2[0]) * e2, a2 += (t2[1] + o2[1]) * e2;
    return [i2 * n2, a2 * n2];
  }, el.clip = function(n2) {
    for (var t2, e2, r2, u2, i2, a2, o2 = De(n2), l2 = -1, c2 = this.length - De(this), s2 = this[c2 - 1]; ++l2 < c2; ) {
      for (t2 = n2.slice(), n2.length = 0, u2 = this[l2], i2 = t2[(r2 = t2.length - o2) - 1], e2 = -1; ++e2 < r2; ) a2 = t2[e2], Te(a2, s2, u2) ? (Te(i2, s2, u2) || n2.push(Re(i2, a2, s2, u2)), n2.push(a2)) : Te(i2, s2, u2) && n2.push(Re(i2, a2, s2, u2)), i2 = a2;
      o2 && n2.push(n2[0]), s2 = u2;
    }
    return n2;
  };
  var rl, ul, il, al, ol, ll = [], cl = [];
  Ye.prototype.prepare = function() {
    for (var n2, t2 = this.edges, e2 = t2.length; e2--; ) n2 = t2[e2].edge, n2.b && n2.a || t2.splice(e2, 1);
    return t2.sort(Ve), t2.length;
  }, tr.prototype = { start: function() {
    return this.edge.l === this.site ? this.edge.a : this.edge.b;
  }, end: function() {
    return this.edge.l === this.site ? this.edge.b : this.edge.a;
  } }, er.prototype = { insert: function(n2, t2) {
    var e2, r2, u2;
    if (n2) {
      if (t2.P = n2, t2.N = n2.N, n2.N && (n2.N.P = t2), n2.N = t2, n2.R) {
        for (n2 = n2.R; n2.L; ) n2 = n2.L;
        n2.L = t2;
      } else n2.R = t2;
      e2 = n2;
    } else this._ ? (n2 = ar(this._), t2.P = null, t2.N = n2, n2.P = n2.L = t2, e2 = n2) : (t2.P = t2.N = null, this._ = t2, e2 = null);
    for (t2.L = t2.R = null, t2.U = e2, t2.C = true, n2 = t2; e2 && e2.C; ) r2 = e2.U, e2 === r2.L ? (u2 = r2.R, u2 && u2.C ? (e2.C = u2.C = false, r2.C = true, n2 = r2) : (n2 === e2.R && (ur(this, e2), n2 = e2, e2 = n2.U), e2.C = false, r2.C = true, ir(this, r2))) : (u2 = r2.L, u2 && u2.C ? (e2.C = u2.C = false, r2.C = true, n2 = r2) : (n2 === e2.L && (ir(this, e2), n2 = e2, e2 = n2.U), e2.C = false, r2.C = true, ur(this, r2))), e2 = n2.U;
    this._.C = false;
  }, remove: function(n2) {
    n2.N && (n2.N.P = n2.P), n2.P && (n2.P.N = n2.N), n2.N = n2.P = null;
    var t2, e2, r2, u2 = n2.U, i2 = n2.L, a2 = n2.R;
    if (e2 = i2 ? a2 ? ar(a2) : i2 : a2, u2 ? u2.L === n2 ? u2.L = e2 : u2.R = e2 : this._ = e2, i2 && a2 ? (r2 = e2.C, e2.C = n2.C, e2.L = i2, i2.U = e2, e2 !== a2 ? (u2 = e2.U, e2.U = n2.U, n2 = e2.R, u2.L = n2, e2.R = a2, a2.U = e2) : (e2.U = u2, u2 = e2, n2 = e2.R)) : (r2 = n2.C, n2 = e2), n2 && (n2.U = u2), !r2) {
      if (n2 && n2.C) return void (n2.C = false);
      do {
        if (n2 === this._) break;
        if (n2 === u2.L) {
          if (t2 = u2.R, t2.C && (t2.C = false, u2.C = true, ur(this, u2), t2 = u2.R), t2.L && t2.L.C || t2.R && t2.R.C) {
            t2.R && t2.R.C || (t2.L.C = false, t2.C = true, ir(this, t2), t2 = u2.R), t2.C = u2.C, u2.C = t2.R.C = false, ur(this, u2), n2 = this._;
            break;
          }
        } else if (t2 = u2.L, t2.C && (t2.C = false, u2.C = true, ir(this, u2), t2 = u2.L), t2.L && t2.L.C || t2.R && t2.R.C) {
          t2.L && t2.L.C || (t2.R.C = false, t2.C = true, ur(this, t2), t2 = u2.L), t2.C = u2.C, u2.C = t2.L.C = false, ir(this, u2), n2 = this._;
          break;
        }
        t2.C = true, n2 = u2, u2 = u2.U;
      } while (!n2.C);
      n2 && (n2.C = false);
    }
  } }, oa.geom.voronoi = function(n2) {
    function t2(n3) {
      var t3 = new Array(n3.length), r3 = o2[0][0], u3 = o2[0][1], i3 = o2[1][0], a3 = o2[1][1];
      return or(e2(n3), o2).cells.forEach(function(e3, o3) {
        var l2 = e3.edges, c2 = e3.site, s2 = t3[o3] = l2.length ? l2.map(function(n4) {
          var t4 = n4.start();
          return [t4.x, t4.y];
        }) : c2.x >= r3 && c2.x <= i3 && c2.y >= u3 && c2.y <= a3 ? [[r3, a3], [i3, a3], [i3, u3], [r3, u3]] : [];
        s2.point = n3[o3];
      }), t3;
    }
    function e2(n3) {
      return n3.map(function(n4, t3) {
        return { x: Math.round(i2(n4, t3) / Da) * Da, y: Math.round(a2(n4, t3) / Da) * Da, i: t3 };
      });
    }
    var r2 = Ce, u2 = ze, i2 = r2, a2 = u2, o2 = sl;
    return n2 ? t2(n2) : (t2.links = function(n3) {
      return or(e2(n3)).edges.filter(function(n4) {
        return n4.l && n4.r;
      }).map(function(t3) {
        return { source: n3[t3.l.i], target: n3[t3.r.i] };
      });
    }, t2.triangles = function(n3) {
      var t3 = [];
      return or(e2(n3)).cells.forEach(function(e3, r3) {
        for (var u3, i3, a3 = e3.site, o3 = e3.edges.sort(Ve), l2 = -1, c2 = o3.length, s2 = o3[c2 - 1].edge, f2 = s2.l === a3 ? s2.r : s2.l; ++l2 < c2; ) u3 = s2, i3 = f2, s2 = o3[l2].edge, f2 = s2.l === a3 ? s2.r : s2.l, r3 < i3.i && r3 < f2.i && cr(a3, i3, f2) < 0 && t3.push([n3[r3], n3[i3.i], n3[f2.i]]);
      }), t3;
    }, t2.x = function(n3) {
      return arguments.length ? (i2 = En(r2 = n3), t2) : r2;
    }, t2.y = function(n3) {
      return arguments.length ? (a2 = En(u2 = n3), t2) : u2;
    }, t2.clipExtent = function(n3) {
      return arguments.length ? (o2 = null == n3 ? sl : n3, t2) : o2 === sl ? null : o2;
    }, t2.size = function(n3) {
      return arguments.length ? t2.clipExtent(n3 && [[0, 0], n3]) : o2 === sl ? null : o2 && o2[1];
    }, t2);
  };
  var sl = [[-1e6, -1e6], [1e6, 1e6]];
  oa.geom.delaunay = function(n2) {
    return oa.geom.voronoi().triangles(n2);
  }, oa.geom.quadtree = function(n2, t2, e2, r2, u2) {
    function i2(n3) {
      function i3(n4, t3, e3, r3, u3, i4, a3, o3) {
        if (!isNaN(e3) && !isNaN(r3)) if (n4.leaf) {
          var l3 = n4.x, s3 = n4.y;
          if (null != l3) if (Ma(l3 - e3) + Ma(s3 - r3) < 0.01) c2(n4, t3, e3, r3, u3, i4, a3, o3);
          else {
            var f3 = n4.point;
            n4.x = n4.y = n4.point = null, c2(n4, f3, l3, s3, u3, i4, a3, o3), c2(n4, t3, e3, r3, u3, i4, a3, o3);
          }
          else n4.x = e3, n4.y = r3, n4.point = t3;
        } else c2(n4, t3, e3, r3, u3, i4, a3, o3);
      }
      function c2(n4, t3, e3, r3, u3, a3, o3, l3) {
        var c3 = 0.5 * (u3 + o3), s3 = 0.5 * (a3 + l3), f3 = e3 >= c3, h3 = r3 >= s3, g3 = h3 << 1 | f3;
        n4.leaf = false, n4 = n4.nodes[g3] || (n4.nodes[g3] = hr()), f3 ? u3 = c3 : o3 = c3, h3 ? a3 = s3 : l3 = s3, i3(n4, t3, e3, r3, u3, a3, o3, l3);
      }
      var s2, f2, h2, g2, p2, v2, d2, m2, y2, M2 = En(o2), x2 = En(l2);
      if (null != t2) v2 = t2, d2 = e2, m2 = r2, y2 = u2;
      else if (m2 = y2 = -(v2 = d2 = 1 / 0), f2 = [], h2 = [], p2 = n3.length, a2) for (g2 = 0; p2 > g2; ++g2) s2 = n3[g2], s2.x < v2 && (v2 = s2.x), s2.y < d2 && (d2 = s2.y), s2.x > m2 && (m2 = s2.x), s2.y > y2 && (y2 = s2.y), f2.push(s2.x), h2.push(s2.y);
      else for (g2 = 0; p2 > g2; ++g2) {
        var b2 = +M2(s2 = n3[g2], g2), _6 = +x2(s2, g2);
        v2 > b2 && (v2 = b2), d2 > _6 && (d2 = _6), b2 > m2 && (m2 = b2), _6 > y2 && (y2 = _6), f2.push(b2), h2.push(_6);
      }
      var w2 = m2 - v2, S2 = y2 - d2;
      w2 > S2 ? y2 = d2 + w2 : m2 = v2 + S2;
      var k2 = hr();
      if (k2.add = function(n4) {
        i3(k2, n4, +M2(n4, ++g2), +x2(n4, g2), v2, d2, m2, y2);
      }, k2.visit = function(n4) {
        gr(n4, k2, v2, d2, m2, y2);
      }, k2.find = function(n4) {
        return pr(k2, n4[0], n4[1], v2, d2, m2, y2);
      }, g2 = -1, null == t2) {
        for (; ++g2 < p2; ) i3(k2, n3[g2], f2[g2], h2[g2], v2, d2, m2, y2);
        --g2;
      } else n3.forEach(k2.add);
      return f2 = h2 = n3 = s2 = null, k2;
    }
    var a2, o2 = Ce, l2 = ze;
    return (a2 = arguments.length) ? (o2 = sr, l2 = fr, 3 === a2 && (u2 = e2, r2 = t2, e2 = t2 = 0), i2(n2)) : (i2.x = function(n3) {
      return arguments.length ? (o2 = n3, i2) : o2;
    }, i2.y = function(n3) {
      return arguments.length ? (l2 = n3, i2) : l2;
    }, i2.extent = function(n3) {
      return arguments.length ? (null == n3 ? t2 = e2 = r2 = u2 = null : (t2 = +n3[0][0], e2 = +n3[0][1], r2 = +n3[1][0], u2 = +n3[1][1]), i2) : null == t2 ? null : [[t2, e2], [r2, u2]];
    }, i2.size = function(n3) {
      return arguments.length ? (null == n3 ? t2 = e2 = r2 = u2 = null : (t2 = e2 = 0, r2 = +n3[0], u2 = +n3[1]), i2) : null == t2 ? null : [r2 - t2, u2 - e2];
    }, i2);
  }, oa.interpolateRgb = vr, oa.interpolateObject = dr, oa.interpolateNumber = mr, oa.interpolateString = yr;
  var fl = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, hl = new RegExp(fl.source, "g");
  oa.interpolate = Mr, oa.interpolators = [function(n2, t2) {
    var e2 = typeof t2;
    return ("string" === e2 ? ro.has(t2.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(t2) ? vr : yr : t2 instanceof on ? vr : Array.isArray(t2) ? xr : "object" === e2 && isNaN(t2) ? dr : mr)(n2, t2);
  }], oa.interpolateArray = xr;
  var gl = function() {
    return y;
  }, pl = oa.map({ linear: gl, poly: Er, quad: function() {
    return Sr;
  }, cubic: function() {
    return kr;
  }, sin: function() {
    return Ar;
  }, exp: function() {
    return Cr;
  }, circle: function() {
    return zr;
  }, elastic: Lr, back: qr, bounce: function() {
    return Tr;
  } }), vl = oa.map({ "in": y, out: _r, "in-out": wr, "out-in": function(n2) {
    return wr(_r(n2));
  } });
  oa.ease = function(n2) {
    var t2 = n2.indexOf("-"), e2 = t2 >= 0 ? n2.slice(0, t2) : n2, r2 = t2 >= 0 ? n2.slice(t2 + 1) : "in";
    return e2 = pl.get(e2) || gl, r2 = vl.get(r2) || y, br(r2(e2.apply(null, la.call(arguments, 1))));
  }, oa.interpolateHcl = Rr, oa.interpolateHsl = Dr, oa.interpolateLab = Pr, oa.interpolateRound = jr, oa.transform = function(n2) {
    var t2 = sa.createElementNS(oa.ns.prefix.svg, "g");
    return (oa.transform = function(n3) {
      if (null != n3) {
        t2.setAttribute("transform", n3);
        var e2 = t2.transform.baseVal.consolidate();
      }
      return new Ur(e2 ? e2.matrix : dl);
    })(n2);
  }, Ur.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  var dl = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
  oa.interpolateTransform = $r, oa.layout = {}, oa.layout.bundle = function() {
    return function(n2) {
      for (var t2 = [], e2 = -1, r2 = n2.length; ++e2 < r2; ) t2.push(Jr(n2[e2]));
      return t2;
    };
  }, oa.layout.chord = function() {
    function n2() {
      var n3, c3, f2, h2, g2, p2 = {}, v2 = [], d2 = oa.range(i2), m2 = [];
      for (e2 = [], r2 = [], n3 = 0, h2 = -1; ++h2 < i2; ) {
        for (c3 = 0, g2 = -1; ++g2 < i2; ) c3 += u2[h2][g2];
        v2.push(c3), m2.push(oa.range(i2)), n3 += c3;
      }
      for (a2 && d2.sort(function(n4, t3) {
        return a2(v2[n4], v2[t3]);
      }), o2 && m2.forEach(function(n4, t3) {
        n4.sort(function(n5, e3) {
          return o2(u2[t3][n5], u2[t3][e3]);
        });
      }), n3 = (Ua - s2 * i2) / n3, c3 = 0, h2 = -1; ++h2 < i2; ) {
        for (f2 = c3, g2 = -1; ++g2 < i2; ) {
          var y2 = d2[h2], M2 = m2[y2][g2], x2 = u2[y2][M2], b2 = c3, _6 = c3 += x2 * n3;
          p2[y2 + "-" + M2] = { index: y2, subindex: M2, startAngle: b2, endAngle: _6, value: x2 };
        }
        r2[y2] = { index: y2, startAngle: f2, endAngle: c3, value: (c3 - f2) / n3 }, c3 += s2;
      }
      for (h2 = -1; ++h2 < i2; ) for (g2 = h2 - 1; ++g2 < i2; ) {
        var w2 = p2[h2 + "-" + g2], S2 = p2[g2 + "-" + h2];
        (w2.value || S2.value) && e2.push(w2.value < S2.value ? { source: S2, target: w2 } : { source: w2, target: S2 });
      }
      l2 && t2();
    }
    function t2() {
      e2.sort(function(n3, t3) {
        return l2((n3.source.value + n3.target.value) / 2, (t3.source.value + t3.target.value) / 2);
      });
    }
    var e2, r2, u2, i2, a2, o2, l2, c2 = {}, s2 = 0;
    return c2.matrix = function(n3) {
      return arguments.length ? (i2 = (u2 = n3) && u2.length, e2 = r2 = null, c2) : u2;
    }, c2.padding = function(n3) {
      return arguments.length ? (s2 = n3, e2 = r2 = null, c2) : s2;
    }, c2.sortGroups = function(n3) {
      return arguments.length ? (a2 = n3, e2 = r2 = null, c2) : a2;
    }, c2.sortSubgroups = function(n3) {
      return arguments.length ? (o2 = n3, e2 = null, c2) : o2;
    }, c2.sortChords = function(n3) {
      return arguments.length ? (l2 = n3, e2 && t2(), c2) : l2;
    }, c2.chords = function() {
      return e2 || n2(), e2;
    }, c2.groups = function() {
      return r2 || n2(), r2;
    }, c2;
  }, oa.layout.force = function() {
    function n2(n3) {
      return function(t3, e3, r3, u3) {
        if (t3.point !== n3) {
          var i3 = t3.cx - n3.x, a3 = t3.cy - n3.y, o3 = u3 - e3, l3 = i3 * i3 + a3 * a3;
          if (l3 > o3 * o3 / m2) {
            if (v2 > l3) {
              var c3 = t3.charge / l3;
              n3.px -= i3 * c3, n3.py -= a3 * c3;
            }
            return true;
          }
          if (t3.point && l3 && v2 > l3) {
            var c3 = t3.pointCharge / l3;
            n3.px -= i3 * c3, n3.py -= a3 * c3;
          }
        }
        return !t3.charge;
      };
    }
    function t2(n3) {
      n3.px = oa.event.x, n3.py = oa.event.y, l2.resume();
    }
    var e2, r2, u2, i2, a2, o2, l2 = {}, c2 = oa.dispatch("start", "tick", "end"), s2 = [1, 1], f2 = 0.9, h2 = ml, g2 = yl, p2 = -30, v2 = Ml, d2 = 0.1, m2 = 0.64, M2 = [], x2 = [];
    return l2.tick = function() {
      if ((u2 *= 0.99) < 5e-3) return e2 = null, c2.end({ type: "end", alpha: u2 = 0 }), true;
      var t3, r3, l3, h3, g3, v3, m3, y2, b2, _6 = M2.length, w2 = x2.length;
      for (r3 = 0; w2 > r3; ++r3) l3 = x2[r3], h3 = l3.source, g3 = l3.target, y2 = g3.x - h3.x, b2 = g3.y - h3.y, (v3 = y2 * y2 + b2 * b2) && (v3 = u2 * a2[r3] * ((v3 = Math.sqrt(v3)) - i2[r3]) / v3, y2 *= v3, b2 *= v3, g3.x -= y2 * (m3 = h3.weight + g3.weight ? h3.weight / (h3.weight + g3.weight) : 0.5), g3.y -= b2 * m3, h3.x += y2 * (m3 = 1 - m3), h3.y += b2 * m3);
      if ((m3 = u2 * d2) && (y2 = s2[0] / 2, b2 = s2[1] / 2, r3 = -1, m3)) for (; ++r3 < _6; ) l3 = M2[r3], l3.x += (y2 - l3.x) * m3, l3.y += (b2 - l3.y) * m3;
      if (p2) for (ru(t3 = oa.geom.quadtree(M2), u2, o2), r3 = -1; ++r3 < _6; ) (l3 = M2[r3]).fixed || t3.visit(n2(l3));
      for (r3 = -1; ++r3 < _6; ) l3 = M2[r3], l3.fixed ? (l3.x = l3.px, l3.y = l3.py) : (l3.x -= (l3.px - (l3.px = l3.x)) * f2, l3.y -= (l3.py - (l3.py = l3.y)) * f2);
      c2.tick({ type: "tick", alpha: u2 });
    }, l2.nodes = function(n3) {
      return arguments.length ? (M2 = n3, l2) : M2;
    }, l2.links = function(n3) {
      return arguments.length ? (x2 = n3, l2) : x2;
    }, l2.size = function(n3) {
      return arguments.length ? (s2 = n3, l2) : s2;
    }, l2.linkDistance = function(n3) {
      return arguments.length ? (h2 = "function" == typeof n3 ? n3 : +n3, l2) : h2;
    }, l2.distance = l2.linkDistance, l2.linkStrength = function(n3) {
      return arguments.length ? (g2 = "function" == typeof n3 ? n3 : +n3, l2) : g2;
    }, l2.friction = function(n3) {
      return arguments.length ? (f2 = +n3, l2) : f2;
    }, l2.charge = function(n3) {
      return arguments.length ? (p2 = "function" == typeof n3 ? n3 : +n3, l2) : p2;
    }, l2.chargeDistance = function(n3) {
      return arguments.length ? (v2 = n3 * n3, l2) : Math.sqrt(v2);
    }, l2.gravity = function(n3) {
      return arguments.length ? (d2 = +n3, l2) : d2;
    }, l2.theta = function(n3) {
      return arguments.length ? (m2 = n3 * n3, l2) : Math.sqrt(m2);
    }, l2.alpha = function(n3) {
      return arguments.length ? (n3 = +n3, u2 ? n3 > 0 ? u2 = n3 : (e2.c = null, e2.t = NaN, e2 = null, c2.end({ type: "end", alpha: u2 = 0 })) : n3 > 0 && (c2.start({ type: "start", alpha: u2 = n3 }), e2 = qn(l2.tick)), l2) : u2;
    }, l2.start = function() {
      function n3(n4, r4) {
        if (!e3) {
          for (e3 = new Array(u3), l3 = 0; u3 > l3; ++l3) e3[l3] = [];
          for (l3 = 0; c3 > l3; ++l3) {
            var i3 = x2[l3];
            e3[i3.source.index].push(i3.target), e3[i3.target.index].push(i3.source);
          }
        }
        for (var a3, o3 = e3[t3], l3 = -1, s3 = o3.length; ++l3 < s3; ) if (!isNaN(a3 = o3[l3][n4])) return a3;
        return Math.random() * r4;
      }
      var t3, e3, r3, u3 = M2.length, c3 = x2.length, f3 = s2[0], v3 = s2[1];
      for (t3 = 0; u3 > t3; ++t3) (r3 = M2[t3]).index = t3, r3.weight = 0;
      for (t3 = 0; c3 > t3; ++t3) r3 = x2[t3], "number" == typeof r3.source && (r3.source = M2[r3.source]), "number" == typeof r3.target && (r3.target = M2[r3.target]), ++r3.source.weight, ++r3.target.weight;
      for (t3 = 0; u3 > t3; ++t3) r3 = M2[t3], isNaN(r3.x) && (r3.x = n3("x", f3)), isNaN(r3.y) && (r3.y = n3("y", v3)), isNaN(r3.px) && (r3.px = r3.x), isNaN(r3.py) && (r3.py = r3.y);
      if (i2 = [], "function" == typeof h2) for (t3 = 0; c3 > t3; ++t3) i2[t3] = +h2.call(this, x2[t3], t3);
      else for (t3 = 0; c3 > t3; ++t3) i2[t3] = h2;
      if (a2 = [], "function" == typeof g2) for (t3 = 0; c3 > t3; ++t3) a2[t3] = +g2.call(this, x2[t3], t3);
      else for (t3 = 0; c3 > t3; ++t3) a2[t3] = g2;
      if (o2 = [], "function" == typeof p2) for (t3 = 0; u3 > t3; ++t3) o2[t3] = +p2.call(this, M2[t3], t3);
      else for (t3 = 0; u3 > t3; ++t3) o2[t3] = p2;
      return l2.resume();
    }, l2.resume = function() {
      return l2.alpha(0.1);
    }, l2.stop = function() {
      return l2.alpha(0);
    }, l2.drag = function() {
      return r2 || (r2 = oa.behavior.drag().origin(y).on("dragstart.force", Qr).on("drag.force", t2).on("dragend.force", nu)), arguments.length ? void this.on("mouseover.force", tu).on("mouseout.force", eu).call(r2) : r2;
    }, oa.rebind(l2, c2, "on");
  };
  var ml = 20, yl = 1, Ml = 1 / 0;
  oa.layout.hierarchy = function() {
    function n2(u2) {
      var i2, a2 = [u2], o2 = [];
      for (u2.depth = 0; null != (i2 = a2.pop()); ) if (o2.push(i2), (c2 = e2.call(n2, i2, i2.depth)) && (l2 = c2.length)) {
        for (var l2, c2, s2; --l2 >= 0; ) a2.push(s2 = c2[l2]), s2.parent = i2, s2.depth = i2.depth + 1;
        r2 && (i2.value = 0), i2.children = c2;
      } else r2 && (i2.value = +r2.call(n2, i2, i2.depth) || 0), delete i2.children;
      return au(u2, function(n3) {
        var e3, u3;
        t2 && (e3 = n3.children) && e3.sort(t2), r2 && (u3 = n3.parent) && (u3.value += n3.value);
      }), o2;
    }
    var t2 = cu, e2 = ou, r2 = lu;
    return n2.sort = function(e3) {
      return arguments.length ? (t2 = e3, n2) : t2;
    }, n2.children = function(t3) {
      return arguments.length ? (e2 = t3, n2) : e2;
    }, n2.value = function(t3) {
      return arguments.length ? (r2 = t3, n2) : r2;
    }, n2.revalue = function(t3) {
      return r2 && (iu(t3, function(n3) {
        n3.children && (n3.value = 0);
      }), au(t3, function(t4) {
        var e3;
        t4.children || (t4.value = +r2.call(n2, t4, t4.depth) || 0), (e3 = t4.parent) && (e3.value += t4.value);
      })), t3;
    }, n2;
  }, oa.layout.partition = function() {
    function n2(t3, e3, r3, u3) {
      var i2 = t3.children;
      if (t3.x = e3, t3.y = t3.depth * u3, t3.dx = r3, t3.dy = u3, i2 && (a2 = i2.length)) {
        var a2, o2, l2, c2 = -1;
        for (r3 = t3.value ? r3 / t3.value : 0; ++c2 < a2; ) n2(o2 = i2[c2], e3, l2 = o2.value * r3, u3), e3 += l2;
      }
    }
    function t2(n3) {
      var e3 = n3.children, r3 = 0;
      if (e3 && (u3 = e3.length)) for (var u3, i2 = -1; ++i2 < u3; ) r3 = Math.max(r3, t2(e3[i2]));
      return 1 + r3;
    }
    function e2(e3, i2) {
      var a2 = r2.call(this, e3, i2);
      return n2(a2[0], 0, u2[0], u2[1] / t2(a2[0])), a2;
    }
    var r2 = oa.layout.hierarchy(), u2 = [1, 1];
    return e2.size = function(n3) {
      return arguments.length ? (u2 = n3, e2) : u2;
    }, uu(e2, r2);
  }, oa.layout.pie = function() {
    function n2(a2) {
      var o2, l2 = a2.length, c2 = a2.map(function(e3, r3) {
        return +t2.call(n2, e3, r3);
      }), s2 = +("function" == typeof r2 ? r2.apply(this, arguments) : r2), f2 = ("function" == typeof u2 ? u2.apply(this, arguments) : u2) - s2, h2 = Math.min(Math.abs(f2) / l2, +("function" == typeof i2 ? i2.apply(this, arguments) : i2)), g2 = h2 * (0 > f2 ? -1 : 1), p2 = oa.sum(c2), v2 = p2 ? (f2 - l2 * g2) / p2 : 0, d2 = oa.range(l2), m2 = [];
      return null != e2 && d2.sort(e2 === xl ? function(n3, t3) {
        return c2[t3] - c2[n3];
      } : function(n3, t3) {
        return e2(a2[n3], a2[t3]);
      }), d2.forEach(function(n3) {
        m2[n3] = { data: a2[n3], value: o2 = c2[n3], startAngle: s2, endAngle: s2 += o2 * v2 + g2, padAngle: h2 };
      }), m2;
    }
    var t2 = Number, e2 = xl, r2 = 0, u2 = Ua, i2 = 0;
    return n2.value = function(e3) {
      return arguments.length ? (t2 = e3, n2) : t2;
    }, n2.sort = function(t3) {
      return arguments.length ? (e2 = t3, n2) : e2;
    }, n2.startAngle = function(t3) {
      return arguments.length ? (r2 = t3, n2) : r2;
    }, n2.endAngle = function(t3) {
      return arguments.length ? (u2 = t3, n2) : u2;
    }, n2.padAngle = function(t3) {
      return arguments.length ? (i2 = t3, n2) : i2;
    }, n2;
  };
  var xl = {};
  oa.layout.stack = function() {
    function n2(o2, l2) {
      if (!(h2 = o2.length)) return o2;
      var c2 = o2.map(function(e3, r3) {
        return t2.call(n2, e3, r3);
      }), s2 = c2.map(function(t3) {
        return t3.map(function(t4, e3) {
          return [i2.call(n2, t4, e3), a2.call(n2, t4, e3)];
        });
      }), f2 = e2.call(n2, s2, l2);
      c2 = oa.permute(c2, f2), s2 = oa.permute(s2, f2);
      var h2, g2, p2, v2, d2 = r2.call(n2, s2, l2), m2 = c2[0].length;
      for (p2 = 0; m2 > p2; ++p2) for (u2.call(n2, c2[0][p2], v2 = d2[p2], s2[0][p2][1]), g2 = 1; h2 > g2; ++g2) u2.call(n2, c2[g2][p2], v2 += s2[g2 - 1][p2][1], s2[g2][p2][1]);
      return o2;
    }
    var t2 = y, e2 = pu, r2 = vu, u2 = gu, i2 = fu, a2 = hu;
    return n2.values = function(e3) {
      return arguments.length ? (t2 = e3, n2) : t2;
    }, n2.order = function(t3) {
      return arguments.length ? (e2 = "function" == typeof t3 ? t3 : bl.get(t3) || pu, n2) : e2;
    }, n2.offset = function(t3) {
      return arguments.length ? (r2 = "function" == typeof t3 ? t3 : _l.get(t3) || vu, n2) : r2;
    }, n2.x = function(t3) {
      return arguments.length ? (i2 = t3, n2) : i2;
    }, n2.y = function(t3) {
      return arguments.length ? (a2 = t3, n2) : a2;
    }, n2.out = function(t3) {
      return arguments.length ? (u2 = t3, n2) : u2;
    }, n2;
  };
  var bl = oa.map({ "inside-out": function(n2) {
    var t2, e2, r2 = n2.length, u2 = n2.map(du), i2 = n2.map(mu), a2 = oa.range(r2).sort(function(n3, t3) {
      return u2[n3] - u2[t3];
    }), o2 = 0, l2 = 0, c2 = [], s2 = [];
    for (t2 = 0; r2 > t2; ++t2) e2 = a2[t2], l2 > o2 ? (o2 += i2[e2], c2.push(e2)) : (l2 += i2[e2], s2.push(e2));
    return s2.reverse().concat(c2);
  }, reverse: function(n2) {
    return oa.range(n2.length).reverse();
  }, "default": pu }), _l = oa.map({ silhouette: function(n2) {
    var t2, e2, r2, u2 = n2.length, i2 = n2[0].length, a2 = [], o2 = 0, l2 = [];
    for (e2 = 0; i2 > e2; ++e2) {
      for (t2 = 0, r2 = 0; u2 > t2; t2++) r2 += n2[t2][e2][1];
      r2 > o2 && (o2 = r2), a2.push(r2);
    }
    for (e2 = 0; i2 > e2; ++e2) l2[e2] = (o2 - a2[e2]) / 2;
    return l2;
  }, wiggle: function(n2) {
    var t2, e2, r2, u2, i2, a2, o2, l2, c2, s2 = n2.length, f2 = n2[0], h2 = f2.length, g2 = [];
    for (g2[0] = l2 = c2 = 0, e2 = 1; h2 > e2; ++e2) {
      for (t2 = 0, u2 = 0; s2 > t2; ++t2) u2 += n2[t2][e2][1];
      for (t2 = 0, i2 = 0, o2 = f2[e2][0] - f2[e2 - 1][0]; s2 > t2; ++t2) {
        for (r2 = 0, a2 = (n2[t2][e2][1] - n2[t2][e2 - 1][1]) / (2 * o2); t2 > r2; ++r2) a2 += (n2[r2][e2][1] - n2[r2][e2 - 1][1]) / o2;
        i2 += a2 * n2[t2][e2][1];
      }
      g2[e2] = l2 -= u2 ? i2 / u2 * o2 : 0, c2 > l2 && (c2 = l2);
    }
    for (e2 = 0; h2 > e2; ++e2) g2[e2] -= c2;
    return g2;
  }, expand: function(n2) {
    var t2, e2, r2, u2 = n2.length, i2 = n2[0].length, a2 = 1 / u2, o2 = [];
    for (e2 = 0; i2 > e2; ++e2) {
      for (t2 = 0, r2 = 0; u2 > t2; t2++) r2 += n2[t2][e2][1];
      if (r2) for (t2 = 0; u2 > t2; t2++) n2[t2][e2][1] /= r2;
      else for (t2 = 0; u2 > t2; t2++) n2[t2][e2][1] = a2;
    }
    for (e2 = 0; i2 > e2; ++e2) o2[e2] = 0;
    return o2;
  }, zero: vu });
  oa.layout.histogram = function() {
    function n2(n3, i2) {
      for (var a2, o2, l2 = [], c2 = n3.map(e2, this), s2 = r2.call(this, c2, i2), f2 = u2.call(this, s2, c2, i2), i2 = -1, h2 = c2.length, g2 = f2.length - 1, p2 = t2 ? 1 : 1 / h2; ++i2 < g2; ) a2 = l2[i2] = [], a2.dx = f2[i2 + 1] - (a2.x = f2[i2]), a2.y = 0;
      if (g2 > 0) for (i2 = -1; ++i2 < h2; ) o2 = c2[i2], o2 >= s2[0] && o2 <= s2[1] && (a2 = l2[oa.bisect(f2, o2, 1, g2) - 1], a2.y += p2, a2.push(n3[i2]));
      return l2;
    }
    var t2 = true, e2 = Number, r2 = bu, u2 = Mu;
    return n2.value = function(t3) {
      return arguments.length ? (e2 = t3, n2) : e2;
    }, n2.range = function(t3) {
      return arguments.length ? (r2 = En(t3), n2) : r2;
    }, n2.bins = function(t3) {
      return arguments.length ? (u2 = "number" == typeof t3 ? function(n3) {
        return xu(n3, t3);
      } : En(t3), n2) : u2;
    }, n2.frequency = function(e3) {
      return arguments.length ? (t2 = !!e3, n2) : t2;
    }, n2;
  }, oa.layout.pack = function() {
    function n2(n3, i2) {
      var a2 = e2.call(this, n3, i2), o2 = a2[0], l2 = u2[0], c2 = u2[1], s2 = null == t2 ? Math.sqrt : "function" == typeof t2 ? t2 : function() {
        return t2;
      };
      if (o2.x = o2.y = 0, au(o2, function(n4) {
        n4.r = +s2(n4.value);
      }), au(o2, Nu), r2) {
        var f2 = r2 * (t2 ? 1 : Math.max(2 * o2.r / l2, 2 * o2.r / c2)) / 2;
        au(o2, function(n4) {
          n4.r += f2;
        }), au(o2, Nu), au(o2, function(n4) {
          n4.r -= f2;
        });
      }
      return Cu(o2, l2 / 2, c2 / 2, t2 ? 1 : 1 / Math.max(2 * o2.r / l2, 2 * o2.r / c2)), a2;
    }
    var t2, e2 = oa.layout.hierarchy().sort(_u), r2 = 0, u2 = [1, 1];
    return n2.size = function(t3) {
      return arguments.length ? (u2 = t3, n2) : u2;
    }, n2.radius = function(e3) {
      return arguments.length ? (t2 = null == e3 || "function" == typeof e3 ? e3 : +e3, n2) : t2;
    }, n2.padding = function(t3) {
      return arguments.length ? (r2 = +t3, n2) : r2;
    }, uu(n2, e2);
  }, oa.layout.tree = function() {
    function n2(n3, u3) {
      var s2 = a2.call(this, n3, u3), f2 = s2[0], h2 = t2(f2);
      if (au(h2, e2), h2.parent.m = -h2.z, iu(h2, r2), c2) iu(f2, i2);
      else {
        var g2 = f2, p2 = f2, v2 = f2;
        iu(f2, function(n4) {
          n4.x < g2.x && (g2 = n4), n4.x > p2.x && (p2 = n4), n4.depth > v2.depth && (v2 = n4);
        });
        var d2 = o2(g2, p2) / 2 - g2.x, m2 = l2[0] / (p2.x + o2(p2, g2) / 2 + d2), y2 = l2[1] / (v2.depth || 1);
        iu(f2, function(n4) {
          n4.x = (n4.x + d2) * m2, n4.y = n4.depth * y2;
        });
      }
      return s2;
    }
    function t2(n3) {
      for (var t3, e3 = { A: null, children: [n3] }, r3 = [e3]; null != (t3 = r3.pop()); ) for (var u3, i3 = t3.children, a3 = 0, o3 = i3.length; o3 > a3; ++a3) r3.push((i3[a3] = u3 = { _: i3[a3], parent: t3, children: (u3 = i3[a3].children) && u3.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: a3 }).a = u3);
      return e3.children[0];
    }
    function e2(n3) {
      var t3 = n3.children, e3 = n3.parent.children, r3 = n3.i ? e3[n3.i - 1] : null;
      if (t3.length) {
        Du(n3);
        var i3 = (t3[0].z + t3[t3.length - 1].z) / 2;
        r3 ? (n3.z = r3.z + o2(n3._, r3._), n3.m = n3.z - i3) : n3.z = i3;
      } else r3 && (n3.z = r3.z + o2(n3._, r3._));
      n3.parent.A = u2(n3, r3, n3.parent.A || e3[0]);
    }
    function r2(n3) {
      n3._.x = n3.z + n3.parent.m, n3.m += n3.parent.m;
    }
    function u2(n3, t3, e3) {
      if (t3) {
        for (var r3, u3 = n3, i3 = n3, a3 = t3, l3 = u3.parent.children[0], c3 = u3.m, s2 = i3.m, f2 = a3.m, h2 = l3.m; a3 = Tu(a3), u3 = qu(u3), a3 && u3; ) l3 = qu(l3), i3 = Tu(i3), i3.a = n3, r3 = a3.z + f2 - u3.z - c3 + o2(a3._, u3._), r3 > 0 && (Ru(Pu(a3, n3, e3), n3, r3), c3 += r3, s2 += r3), f2 += a3.m, c3 += u3.m, h2 += l3.m, s2 += i3.m;
        a3 && !Tu(i3) && (i3.t = a3, i3.m += f2 - s2), u3 && !qu(l3) && (l3.t = u3, l3.m += c3 - h2, e3 = n3);
      }
      return e3;
    }
    function i2(n3) {
      n3.x *= l2[0], n3.y = n3.depth * l2[1];
    }
    var a2 = oa.layout.hierarchy().sort(null).value(null), o2 = Lu, l2 = [1, 1], c2 = null;
    return n2.separation = function(t3) {
      return arguments.length ? (o2 = t3, n2) : o2;
    }, n2.size = function(t3) {
      return arguments.length ? (c2 = null == (l2 = t3) ? i2 : null, n2) : c2 ? null : l2;
    }, n2.nodeSize = function(t3) {
      return arguments.length ? (c2 = null == (l2 = t3) ? null : i2, n2) : c2 ? l2 : null;
    }, uu(n2, a2);
  }, oa.layout.cluster = function() {
    function n2(n3, i2) {
      var a2, o2 = t2.call(this, n3, i2), l2 = o2[0], c2 = 0;
      au(l2, function(n4) {
        var t3 = n4.children;
        t3 && t3.length ? (n4.x = Uu(t3), n4.y = ju(t3)) : (n4.x = a2 ? c2 += e2(n4, a2) : 0, n4.y = 0, a2 = n4);
      });
      var s2 = Fu(l2), f2 = Hu(l2), h2 = s2.x - e2(s2, f2) / 2, g2 = f2.x + e2(f2, s2) / 2;
      return au(l2, u2 ? function(n4) {
        n4.x = (n4.x - l2.x) * r2[0], n4.y = (l2.y - n4.y) * r2[1];
      } : function(n4) {
        n4.x = (n4.x - h2) / (g2 - h2) * r2[0], n4.y = (1 - (l2.y ? n4.y / l2.y : 1)) * r2[1];
      }), o2;
    }
    var t2 = oa.layout.hierarchy().sort(null).value(null), e2 = Lu, r2 = [1, 1], u2 = false;
    return n2.separation = function(t3) {
      return arguments.length ? (e2 = t3, n2) : e2;
    }, n2.size = function(t3) {
      return arguments.length ? (u2 = null == (r2 = t3), n2) : u2 ? null : r2;
    }, n2.nodeSize = function(t3) {
      return arguments.length ? (u2 = null != (r2 = t3), n2) : u2 ? r2 : null;
    }, uu(n2, t2);
  }, oa.layout.treemap = function() {
    function n2(n3, t3) {
      for (var e3, r3, u3 = -1, i3 = n3.length; ++u3 < i3; ) r3 = (e3 = n3[u3]).value * (0 > t3 ? 0 : t3), e3.area = isNaN(r3) || 0 >= r3 ? 0 : r3;
    }
    function t2(e3) {
      var i3 = e3.children;
      if (i3 && i3.length) {
        var a3, o3, l3, c3 = f2(e3), s3 = [], h3 = i3.slice(), p3 = 1 / 0, v2 = "slice" === g2 ? c3.dx : "dice" === g2 ? c3.dy : "slice-dice" === g2 ? 1 & e3.depth ? c3.dy : c3.dx : Math.min(c3.dx, c3.dy);
        for (n2(h3, c3.dx * c3.dy / e3.value), s3.area = 0; (l3 = h3.length) > 0; ) s3.push(a3 = h3[l3 - 1]), s3.area += a3.area, "squarify" !== g2 || (o3 = r2(s3, v2)) <= p3 ? (h3.pop(), p3 = o3) : (s3.area -= s3.pop().area, u2(s3, v2, c3, false), v2 = Math.min(c3.dx, c3.dy), s3.length = s3.area = 0, p3 = 1 / 0);
        s3.length && (u2(s3, v2, c3, true), s3.length = s3.area = 0), i3.forEach(t2);
      }
    }
    function e2(t3) {
      var r3 = t3.children;
      if (r3 && r3.length) {
        var i3, a3 = f2(t3), o3 = r3.slice(), l3 = [];
        for (n2(o3, a3.dx * a3.dy / t3.value), l3.area = 0; i3 = o3.pop(); ) l3.push(i3), l3.area += i3.area, null != i3.z && (u2(l3, i3.z ? a3.dx : a3.dy, a3, !o3.length), l3.length = l3.area = 0);
        r3.forEach(e2);
      }
    }
    function r2(n3, t3) {
      for (var e3, r3 = n3.area, u3 = 0, i3 = 1 / 0, a3 = -1, o3 = n3.length; ++a3 < o3; ) (e3 = n3[a3].area) && (i3 > e3 && (i3 = e3), e3 > u3 && (u3 = e3));
      return r3 *= r3, t3 *= t3, r3 ? Math.max(t3 * u3 * p2 / r3, r3 / (t3 * i3 * p2)) : 1 / 0;
    }
    function u2(n3, t3, e3, r3) {
      var u3, i3 = -1, a3 = n3.length, o3 = e3.x, c3 = e3.y, s3 = t3 ? l2(n3.area / t3) : 0;
      if (t3 == e3.dx) {
        for ((r3 || s3 > e3.dy) && (s3 = e3.dy); ++i3 < a3; ) u3 = n3[i3], u3.x = o3, u3.y = c3, u3.dy = s3, o3 += u3.dx = Math.min(e3.x + e3.dx - o3, s3 ? l2(u3.area / s3) : 0);
        u3.z = true, u3.dx += e3.x + e3.dx - o3, e3.y += s3, e3.dy -= s3;
      } else {
        for ((r3 || s3 > e3.dx) && (s3 = e3.dx); ++i3 < a3; ) u3 = n3[i3], u3.x = o3, u3.y = c3, u3.dx = s3, c3 += u3.dy = Math.min(e3.y + e3.dy - c3, s3 ? l2(u3.area / s3) : 0);
        u3.z = false, u3.dy += e3.y + e3.dy - c3, e3.x += s3, e3.dx -= s3;
      }
    }
    function i2(r3) {
      var u3 = a2 || o2(r3), i3 = u3[0];
      return i3.x = i3.y = 0, i3.value ? (i3.dx = c2[0], i3.dy = c2[1]) : i3.dx = i3.dy = 0, a2 && o2.revalue(i3), n2([i3], i3.dx * i3.dy / i3.value), (a2 ? e2 : t2)(i3), h2 && (a2 = u3), u3;
    }
    var a2, o2 = oa.layout.hierarchy(), l2 = Math.round, c2 = [1, 1], s2 = null, f2 = Ou, h2 = false, g2 = "squarify", p2 = 0.5 * (1 + Math.sqrt(5));
    return i2.size = function(n3) {
      return arguments.length ? (c2 = n3, i2) : c2;
    }, i2.padding = function(n3) {
      function t3(t4) {
        var e4 = n3.call(i2, t4, t4.depth);
        return null == e4 ? Ou(t4) : Iu(t4, "number" == typeof e4 ? [e4, e4, e4, e4] : e4);
      }
      function e3(t4) {
        return Iu(t4, n3);
      }
      if (!arguments.length) return s2;
      var r3;
      return f2 = null == (s2 = n3) ? Ou : "function" == (r3 = typeof n3) ? t3 : "number" === r3 ? (n3 = [n3, n3, n3, n3], e3) : e3, i2;
    }, i2.round = function(n3) {
      return arguments.length ? (l2 = n3 ? Math.round : Number, i2) : l2 != Number;
    }, i2.sticky = function(n3) {
      return arguments.length ? (h2 = n3, a2 = null, i2) : h2;
    }, i2.ratio = function(n3) {
      return arguments.length ? (p2 = n3, i2) : p2;
    }, i2.mode = function(n3) {
      return arguments.length ? (g2 = n3 + "", i2) : g2;
    }, uu(i2, o2);
  }, oa.random = { normal: function(n2, t2) {
    var e2 = arguments.length;
    return 2 > e2 && (t2 = 1), 1 > e2 && (n2 = 0), function() {
      var e3, r2, u2;
      do
        e3 = 2 * Math.random() - 1, r2 = 2 * Math.random() - 1, u2 = e3 * e3 + r2 * r2;
      while (!u2 || u2 > 1);
      return n2 + t2 * e3 * Math.sqrt(-2 * Math.log(u2) / u2);
    };
  }, logNormal: function() {
    var n2 = oa.random.normal.apply(oa, arguments);
    return function() {
      return Math.exp(n2());
    };
  }, bates: function(n2) {
    var t2 = oa.random.irwinHall(n2);
    return function() {
      return t2() / n2;
    };
  }, irwinHall: function(n2) {
    return function() {
      for (var t2 = 0, e2 = 0; n2 > e2; e2++) t2 += Math.random();
      return t2;
    };
  } }, oa.scale = {};
  var wl = { floor: y, ceil: y };
  oa.scale.linear = function() {
    return Wu([0, 1], [0, 1], Mr, false);
  };
  var Sl = { s: 1, g: 1, p: 1, r: 1, e: 1 };
  oa.scale.log = function() {
    return ri(oa.scale.linear().domain([0, 1]), 10, true, [1, 10]);
  };
  var kl = oa.format(".0e"), Nl = { floor: function(n2) {
    return -Math.ceil(-n2);
  }, ceil: function(n2) {
    return -Math.floor(-n2);
  } };
  oa.scale.pow = function() {
    return ui(oa.scale.linear(), 1, [0, 1]);
  }, oa.scale.sqrt = function() {
    return oa.scale.pow().exponent(0.5);
  }, oa.scale.ordinal = function() {
    return ai([], { t: "range", a: [[]] });
  }, oa.scale.category10 = function() {
    return oa.scale.ordinal().range(El);
  }, oa.scale.category20 = function() {
    return oa.scale.ordinal().range(Al);
  }, oa.scale.category20b = function() {
    return oa.scale.ordinal().range(Cl);
  }, oa.scale.category20c = function() {
    return oa.scale.ordinal().range(zl);
  };
  var El = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(xn), Al = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(xn), Cl = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(xn), zl = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(xn);
  oa.scale.quantile = function() {
    return oi([], []);
  }, oa.scale.quantize = function() {
    return li(0, 1, [0, 1]);
  }, oa.scale.threshold = function() {
    return ci([0.5], [0, 1]);
  }, oa.scale.identity = function() {
    return si([0, 1]);
  }, oa.svg = {}, oa.svg.arc = function() {
    function n2() {
      var n3 = Math.max(0, +e2.apply(this, arguments)), c2 = Math.max(0, +r2.apply(this, arguments)), s2 = a2.apply(this, arguments) - Ha, f2 = o2.apply(this, arguments) - Ha, h2 = Math.abs(f2 - s2), g2 = s2 > f2 ? 0 : 1;
      if (n3 > c2 && (p2 = c2, c2 = n3, n3 = p2), h2 >= Fa) return t2(c2, g2) + (n3 ? t2(n3, 1 - g2) : "") + "Z";
      var p2, v2, d2, m2, y2, M2, x2, b2, _6, w2, S2, k2, N2 = 0, E2 = 0, A2 = [];
      if ((m2 = (+l2.apply(this, arguments) || 0) / 2) && (d2 = i2 === Ll ? Math.sqrt(n3 * n3 + c2 * c2) : +i2.apply(this, arguments), g2 || (E2 *= -1), c2 && (E2 = tn(d2 / c2 * Math.sin(m2))), n3 && (N2 = tn(d2 / n3 * Math.sin(m2)))), c2) {
        y2 = c2 * Math.cos(s2 + E2), M2 = c2 * Math.sin(s2 + E2), x2 = c2 * Math.cos(f2 - E2), b2 = c2 * Math.sin(f2 - E2);
        var C2 = Math.abs(f2 - s2 - 2 * E2) <= ja ? 0 : 1;
        if (E2 && mi(y2, M2, x2, b2) === g2 ^ C2) {
          var z2 = (s2 + f2) / 2;
          y2 = c2 * Math.cos(z2), M2 = c2 * Math.sin(z2), x2 = b2 = null;
        }
      } else y2 = M2 = 0;
      if (n3) {
        _6 = n3 * Math.cos(f2 - N2), w2 = n3 * Math.sin(f2 - N2), S2 = n3 * Math.cos(s2 + N2), k2 = n3 * Math.sin(s2 + N2);
        var L2 = Math.abs(s2 - f2 + 2 * N2) <= ja ? 0 : 1;
        if (N2 && mi(_6, w2, S2, k2) === 1 - g2 ^ L2) {
          var q2 = (s2 + f2) / 2;
          _6 = n3 * Math.cos(q2), w2 = n3 * Math.sin(q2), S2 = k2 = null;
        }
      } else _6 = w2 = 0;
      if (h2 > Da && (p2 = Math.min(Math.abs(c2 - n3) / 2, +u2.apply(this, arguments))) > 1e-3) {
        v2 = c2 > n3 ^ g2 ? 0 : 1;
        var T2 = p2, R2 = p2;
        if (ja > h2) {
          var D2 = null == S2 ? [_6, w2] : null == x2 ? [y2, M2] : Re([y2, M2], [S2, k2], [x2, b2], [_6, w2]), P2 = y2 - D2[0], j2 = M2 - D2[1], U2 = x2 - D2[0], F2 = b2 - D2[1], H2 = 1 / Math.sin(Math.acos((P2 * U2 + j2 * F2) / (Math.sqrt(P2 * P2 + j2 * j2) * Math.sqrt(U2 * U2 + F2 * F2))) / 2), O2 = Math.sqrt(D2[0] * D2[0] + D2[1] * D2[1]);
          R2 = Math.min(p2, (n3 - O2) / (H2 - 1)), T2 = Math.min(p2, (c2 - O2) / (H2 + 1));
        }
        if (null != x2) {
          var I2 = yi(null == S2 ? [_6, w2] : [S2, k2], [y2, M2], c2, T2, g2), Y2 = yi([x2, b2], [_6, w2], c2, T2, g2);
          p2 === T2 ? A2.push("M", I2[0], "A", T2, ",", T2, " 0 0,", v2, " ", I2[1], "A", c2, ",", c2, " 0 ", 1 - g2 ^ mi(I2[1][0], I2[1][1], Y2[1][0], Y2[1][1]), ",", g2, " ", Y2[1], "A", T2, ",", T2, " 0 0,", v2, " ", Y2[0]) : A2.push("M", I2[0], "A", T2, ",", T2, " 0 1,", v2, " ", Y2[0]);
        } else A2.push("M", y2, ",", M2);
        if (null != S2) {
          var Z2 = yi([y2, M2], [S2, k2], n3, -R2, g2), V2 = yi([_6, w2], null == x2 ? [y2, M2] : [x2, b2], n3, -R2, g2);
          p2 === R2 ? A2.push("L", V2[0], "A", R2, ",", R2, " 0 0,", v2, " ", V2[1], "A", n3, ",", n3, " 0 ", g2 ^ mi(V2[1][0], V2[1][1], Z2[1][0], Z2[1][1]), ",", 1 - g2, " ", Z2[1], "A", R2, ",", R2, " 0 0,", v2, " ", Z2[0]) : A2.push("L", V2[0], "A", R2, ",", R2, " 0 0,", v2, " ", Z2[0]);
        } else A2.push("L", _6, ",", w2);
      } else A2.push("M", y2, ",", M2), null != x2 && A2.push("A", c2, ",", c2, " 0 ", C2, ",", g2, " ", x2, ",", b2), A2.push("L", _6, ",", w2), null != S2 && A2.push("A", n3, ",", n3, " 0 ", L2, ",", 1 - g2, " ", S2, ",", k2);
      return A2.push("Z"), A2.join("");
    }
    function t2(n3, t3) {
      return "M0," + n3 + "A" + n3 + "," + n3 + " 0 1," + t3 + " 0," + -n3 + "A" + n3 + "," + n3 + " 0 1," + t3 + " 0," + n3;
    }
    var e2 = hi, r2 = gi, u2 = fi, i2 = Ll, a2 = pi, o2 = vi, l2 = di;
    return n2.innerRadius = function(t3) {
      return arguments.length ? (e2 = En(t3), n2) : e2;
    }, n2.outerRadius = function(t3) {
      return arguments.length ? (r2 = En(t3), n2) : r2;
    }, n2.cornerRadius = function(t3) {
      return arguments.length ? (u2 = En(t3), n2) : u2;
    }, n2.padRadius = function(t3) {
      return arguments.length ? (i2 = t3 == Ll ? Ll : En(t3), n2) : i2;
    }, n2.startAngle = function(t3) {
      return arguments.length ? (a2 = En(t3), n2) : a2;
    }, n2.endAngle = function(t3) {
      return arguments.length ? (o2 = En(t3), n2) : o2;
    }, n2.padAngle = function(t3) {
      return arguments.length ? (l2 = En(t3), n2) : l2;
    }, n2.centroid = function() {
      var n3 = (+e2.apply(this, arguments) + +r2.apply(this, arguments)) / 2, t3 = (+a2.apply(this, arguments) + +o2.apply(this, arguments)) / 2 - Ha;
      return [Math.cos(t3) * n3, Math.sin(t3) * n3];
    }, n2;
  };
  var Ll = "auto";
  oa.svg.line = function() {
    return Mi(y);
  };
  var ql = oa.map({ linear: xi, "linear-closed": bi, step: _i, "step-before": wi, "step-after": Si, basis: zi, "basis-open": Li, "basis-closed": qi, bundle: Ti, cardinal: Ei, "cardinal-open": ki, "cardinal-closed": Ni, monotone: Fi });
  ql.forEach(function(n2, t2) {
    t2.key = n2, t2.closed = /-closed$/.test(n2);
  });
  var Tl = [0, 2 / 3, 1 / 3, 0], Rl = [0, 1 / 3, 2 / 3, 0], Dl = [0, 1 / 6, 2 / 3, 1 / 6];
  oa.svg.line.radial = function() {
    var n2 = Mi(Hi);
    return n2.radius = n2.x, delete n2.x, n2.angle = n2.y, delete n2.y, n2;
  }, wi.reverse = Si, Si.reverse = wi, oa.svg.area = function() {
    return Oi(y);
  }, oa.svg.area.radial = function() {
    var n2 = Oi(Hi);
    return n2.radius = n2.x, delete n2.x, n2.innerRadius = n2.x0, delete n2.x0, n2.outerRadius = n2.x1, delete n2.x1, n2.angle = n2.y, delete n2.y, n2.startAngle = n2.y0, delete n2.y0, n2.endAngle = n2.y1, delete n2.y1, n2;
  }, oa.svg.chord = function() {
    function n2(n3, o3) {
      var l3 = t2(this, i2, n3, o3), c3 = t2(this, a2, n3, o3);
      return "M" + l3.p0 + r2(l3.r, l3.p1, l3.a1 - l3.a0) + (e2(l3, c3) ? u2(l3.r, l3.p1, l3.r, l3.p0) : u2(l3.r, l3.p1, c3.r, c3.p0) + r2(c3.r, c3.p1, c3.a1 - c3.a0) + u2(c3.r, c3.p1, l3.r, l3.p0)) + "Z";
    }
    function t2(n3, t3, e3, r3) {
      var u3 = t3.call(n3, e3, r3), i3 = o2.call(n3, u3, r3), a3 = l2.call(n3, u3, r3) - Ha, s2 = c2.call(n3, u3, r3) - Ha;
      return { r: i3, a0: a3, a1: s2, p0: [i3 * Math.cos(a3), i3 * Math.sin(a3)], p1: [i3 * Math.cos(s2), i3 * Math.sin(s2)] };
    }
    function e2(n3, t3) {
      return n3.a0 == t3.a0 && n3.a1 == t3.a1;
    }
    function r2(n3, t3, e3) {
      return "A" + n3 + "," + n3 + " 0 " + +(e3 > ja) + ",1 " + t3;
    }
    function u2(n3, t3, e3, r3) {
      return "Q 0,0 " + r3;
    }
    var i2 = Me, a2 = xe, o2 = Ii, l2 = pi, c2 = vi;
    return n2.radius = function(t3) {
      return arguments.length ? (o2 = En(t3), n2) : o2;
    }, n2.source = function(t3) {
      return arguments.length ? (i2 = En(t3), n2) : i2;
    }, n2.target = function(t3) {
      return arguments.length ? (a2 = En(t3), n2) : a2;
    }, n2.startAngle = function(t3) {
      return arguments.length ? (l2 = En(t3), n2) : l2;
    }, n2.endAngle = function(t3) {
      return arguments.length ? (c2 = En(t3), n2) : c2;
    }, n2;
  }, oa.svg.diagonal = function() {
    function n2(n3, u2) {
      var i2 = t2.call(this, n3, u2), a2 = e2.call(this, n3, u2), o2 = (i2.y + a2.y) / 2, l2 = [i2, { x: i2.x, y: o2 }, { x: a2.x, y: o2 }, a2];
      return l2 = l2.map(r2), "M" + l2[0] + "C" + l2[1] + " " + l2[2] + " " + l2[3];
    }
    var t2 = Me, e2 = xe, r2 = Yi;
    return n2.source = function(e3) {
      return arguments.length ? (t2 = En(e3), n2) : t2;
    }, n2.target = function(t3) {
      return arguments.length ? (e2 = En(t3), n2) : e2;
    }, n2.projection = function(t3) {
      return arguments.length ? (r2 = t3, n2) : r2;
    }, n2;
  }, oa.svg.diagonal.radial = function() {
    var n2 = oa.svg.diagonal(), t2 = Yi, e2 = n2.projection;
    return n2.projection = function(n3) {
      return arguments.length ? e2(Zi(t2 = n3)) : t2;
    }, n2;
  }, oa.svg.symbol = function() {
    function n2(n3, r2) {
      return (Pl.get(t2.call(this, n3, r2)) || $i)(e2.call(this, n3, r2));
    }
    var t2 = Xi, e2 = Vi;
    return n2.type = function(e3) {
      return arguments.length ? (t2 = En(e3), n2) : t2;
    }, n2.size = function(t3) {
      return arguments.length ? (e2 = En(t3), n2) : e2;
    }, n2;
  };
  var Pl = oa.map({ circle: $i, cross: function(n2) {
    var t2 = Math.sqrt(n2 / 5) / 2;
    return "M" + -3 * t2 + "," + -t2 + "H" + -t2 + "V" + -3 * t2 + "H" + t2 + "V" + -t2 + "H" + 3 * t2 + "V" + t2 + "H" + t2 + "V" + 3 * t2 + "H" + -t2 + "V" + t2 + "H" + -3 * t2 + "Z";
  }, diamond: function(n2) {
    var t2 = Math.sqrt(n2 / (2 * Ul)), e2 = t2 * Ul;
    return "M0," + -t2 + "L" + e2 + ",0 0," + t2 + " " + -e2 + ",0Z";
  }, square: function(n2) {
    var t2 = Math.sqrt(n2) / 2;
    return "M" + -t2 + "," + -t2 + "L" + t2 + "," + -t2 + " " + t2 + "," + t2 + " " + -t2 + "," + t2 + "Z";
  }, "triangle-down": function(n2) {
    var t2 = Math.sqrt(n2 / jl), e2 = t2 * jl / 2;
    return "M0," + e2 + "L" + t2 + "," + -e2 + " " + -t2 + "," + -e2 + "Z";
  }, "triangle-up": function(n2) {
    var t2 = Math.sqrt(n2 / jl), e2 = t2 * jl / 2;
    return "M0," + -e2 + "L" + t2 + "," + e2 + " " + -t2 + "," + e2 + "Z";
  } });
  oa.svg.symbolTypes = Pl.keys();
  var jl = Math.sqrt(3), Ul = Math.tan(30 * Oa);
  Aa.transition = function(n2) {
    for (var t2, e2, r2 = Fl || ++Yl, u2 = Ki(n2), i2 = [], a2 = Hl || { time: Date.now(), ease: Nr, delay: 0, duration: 250 }, o2 = -1, l2 = this.length; ++o2 < l2; ) {
      i2.push(t2 = []);
      for (var c2 = this[o2], s2 = -1, f2 = c2.length; ++s2 < f2; ) (e2 = c2[s2]) && Qi(e2, s2, u2, r2, a2), t2.push(e2);
    }
    return Wi(i2, u2, r2);
  }, Aa.interrupt = function(n2) {
    return this.each(null == n2 ? Ol : Bi(Ki(n2)));
  };
  var Fl, Hl, Ol = Bi(Ki()), Il = [], Yl = 0;
  Il.call = Aa.call, Il.empty = Aa.empty, Il.node = Aa.node, Il.size = Aa.size, oa.transition = function(n2, t2) {
    return n2 && n2.transition ? Fl ? n2.transition(t2) : n2 : oa.selection().transition(n2);
  }, oa.transition.prototype = Il, Il.select = function(n2) {
    var t2, e2, r2, u2 = this.id, i2 = this.namespace, a2 = [];
    n2 = A(n2);
    for (var o2 = -1, l2 = this.length; ++o2 < l2; ) {
      a2.push(t2 = []);
      for (var c2 = this[o2], s2 = -1, f2 = c2.length; ++s2 < f2; ) (r2 = c2[s2]) && (e2 = n2.call(r2, r2.__data__, s2, o2)) ? ("__data__" in r2 && (e2.__data__ = r2.__data__), Qi(e2, s2, i2, u2, r2[i2][u2]), t2.push(e2)) : t2.push(null);
    }
    return Wi(a2, i2, u2);
  }, Il.selectAll = function(n2) {
    var t2, e2, r2, u2, i2, a2 = this.id, o2 = this.namespace, l2 = [];
    n2 = C(n2);
    for (var c2 = -1, s2 = this.length; ++c2 < s2; ) for (var f2 = this[c2], h2 = -1, g2 = f2.length; ++h2 < g2; ) if (r2 = f2[h2]) {
      i2 = r2[o2][a2], e2 = n2.call(r2, r2.__data__, h2, c2), l2.push(t2 = []);
      for (var p2 = -1, v2 = e2.length; ++p2 < v2; ) (u2 = e2[p2]) && Qi(u2, p2, o2, a2, i2), t2.push(u2);
    }
    return Wi(l2, o2, a2);
  }, Il.filter = function(n2) {
    var t2, e2, r2, u2 = [];
    "function" != typeof n2 && (n2 = O(n2));
    for (var i2 = 0, a2 = this.length; a2 > i2; i2++) {
      u2.push(t2 = []);
      for (var e2 = this[i2], o2 = 0, l2 = e2.length; l2 > o2; o2++) (r2 = e2[o2]) && n2.call(r2, r2.__data__, o2, i2) && t2.push(r2);
    }
    return Wi(u2, this.namespace, this.id);
  }, Il.tween = function(n2, t2) {
    var e2 = this.id, r2 = this.namespace;
    return arguments.length < 2 ? this.node()[r2][e2].tween.get(n2) : Y(this, null == t2 ? function(t3) {
      t3[r2][e2].tween.remove(n2);
    } : function(u2) {
      u2[r2][e2].tween.set(n2, t2);
    });
  }, Il.attr = function(n2, t2) {
    function e2() {
      this.removeAttribute(o2);
    }
    function r2() {
      this.removeAttributeNS(o2.space, o2.local);
    }
    function u2(n3) {
      return null == n3 ? e2 : (n3 += "", function() {
        var t3, e3 = this.getAttribute(o2);
        return e3 !== n3 && (t3 = a2(e3, n3), function(n4) {
          this.setAttribute(o2, t3(n4));
        });
      });
    }
    function i2(n3) {
      return null == n3 ? r2 : (n3 += "", function() {
        var t3, e3 = this.getAttributeNS(o2.space, o2.local);
        return e3 !== n3 && (t3 = a2(e3, n3), function(n4) {
          this.setAttributeNS(o2.space, o2.local, t3(n4));
        });
      });
    }
    if (arguments.length < 2) {
      for (t2 in n2) this.attr(t2, n2[t2]);
      return this;
    }
    var a2 = "transform" == n2 ? $r : Mr, o2 = oa.ns.qualify(n2);
    return Ji(this, "attr." + n2, t2, o2.local ? i2 : u2);
  }, Il.attrTween = function(n2, t2) {
    function e2(n3, e3) {
      var r3 = t2.call(this, n3, e3, this.getAttribute(u2));
      return r3 && function(n4) {
        this.setAttribute(u2, r3(n4));
      };
    }
    function r2(n3, e3) {
      var r3 = t2.call(this, n3, e3, this.getAttributeNS(u2.space, u2.local));
      return r3 && function(n4) {
        this.setAttributeNS(u2.space, u2.local, r3(n4));
      };
    }
    var u2 = oa.ns.qualify(n2);
    return this.tween("attr." + n2, u2.local ? r2 : e2);
  }, Il.style = function(n2, e2, r2) {
    function u2() {
      this.style.removeProperty(n2);
    }
    function i2(e3) {
      return null == e3 ? u2 : (e3 += "", function() {
        var u3, i3 = t(this).getComputedStyle(this, null).getPropertyValue(n2);
        return i3 !== e3 && (u3 = Mr(i3, e3), function(t2) {
          this.style.setProperty(n2, u3(t2), r2);
        });
      });
    }
    var a2 = arguments.length;
    if (3 > a2) {
      if ("string" != typeof n2) {
        2 > a2 && (e2 = "");
        for (r2 in n2) this.style(r2, n2[r2], e2);
        return this;
      }
      r2 = "";
    }
    return Ji(this, "style." + n2, e2, i2);
  }, Il.styleTween = function(n2, e2, r2) {
    function u2(u3, i2) {
      var a2 = e2.call(this, u3, i2, t(this).getComputedStyle(this, null).getPropertyValue(n2));
      return a2 && function(t2) {
        this.style.setProperty(n2, a2(t2), r2);
      };
    }
    return arguments.length < 3 && (r2 = ""), this.tween("style." + n2, u2);
  }, Il.text = function(n2) {
    return Ji(this, "text", n2, Gi);
  }, Il.remove = function() {
    var n2 = this.namespace;
    return this.each("end.transition", function() {
      var t2;
      this[n2].count < 2 && (t2 = this.parentNode) && t2.removeChild(this);
    });
  }, Il.ease = function(n2) {
    var t2 = this.id, e2 = this.namespace;
    return arguments.length < 1 ? this.node()[e2][t2].ease : ("function" != typeof n2 && (n2 = oa.ease.apply(oa, arguments)), Y(this, function(r2) {
      r2[e2][t2].ease = n2;
    }));
  }, Il.delay = function(n2) {
    var t2 = this.id, e2 = this.namespace;
    return arguments.length < 1 ? this.node()[e2][t2].delay : Y(this, "function" == typeof n2 ? function(r2, u2, i2) {
      r2[e2][t2].delay = +n2.call(r2, r2.__data__, u2, i2);
    } : (n2 = +n2, function(r2) {
      r2[e2][t2].delay = n2;
    }));
  }, Il.duration = function(n2) {
    var t2 = this.id, e2 = this.namespace;
    return arguments.length < 1 ? this.node()[e2][t2].duration : Y(this, "function" == typeof n2 ? function(r2, u2, i2) {
      r2[e2][t2].duration = Math.max(1, n2.call(r2, r2.__data__, u2, i2));
    } : (n2 = Math.max(1, n2), function(r2) {
      r2[e2][t2].duration = n2;
    }));
  }, Il.each = function(n2, t2) {
    var e2 = this.id, r2 = this.namespace;
    if (arguments.length < 2) {
      var u2 = Hl, i2 = Fl;
      try {
        Fl = e2, Y(this, function(t3, u3, i3) {
          Hl = t3[r2][e2], n2.call(t3, t3.__data__, u3, i3);
        });
      } finally {
        Hl = u2, Fl = i2;
      }
    } else Y(this, function(u3) {
      var i3 = u3[r2][e2];
      (i3.event || (i3.event = oa.dispatch("start", "end", "interrupt"))).on(n2, t2);
    });
    return this;
  }, Il.transition = function() {
    for (var n2, t2, e2, r2, u2 = this.id, i2 = ++Yl, a2 = this.namespace, o2 = [], l2 = 0, c2 = this.length; c2 > l2; l2++) {
      o2.push(n2 = []);
      for (var t2 = this[l2], s2 = 0, f2 = t2.length; f2 > s2; s2++) (e2 = t2[s2]) && (r2 = e2[a2][u2], Qi(e2, s2, a2, i2, { time: r2.time, ease: r2.ease, delay: r2.delay + r2.duration, duration: r2.duration })), n2.push(e2);
    }
    return Wi(o2, a2, i2);
  }, oa.svg.axis = function() {
    function n2(n3) {
      n3.each(function() {
        var n4, c2 = oa.select(this), s2 = this.__chart__ || e2, f2 = this.__chart__ = e2.copy(), h2 = null == l2 ? f2.ticks ? f2.ticks.apply(f2, o2) : f2.domain() : l2, g2 = null == t2 ? f2.tickFormat ? f2.tickFormat.apply(f2, o2) : y : t2, p2 = c2.selectAll(".tick").data(h2, f2), v2 = p2.enter().insert("g", ".domain").attr("class", "tick").style("opacity", Da), d2 = oa.transition(p2.exit()).style("opacity", Da).remove(), m2 = oa.transition(p2.order()).style("opacity", 1), M2 = Math.max(u2, 0) + a2, x2 = Zu(f2), b2 = c2.selectAll(".domain").data([0]), _6 = (b2.enter().append("path").attr("class", "domain"), oa.transition(b2));
        v2.append("line"), v2.append("text");
        var w2, S2, k2, N2, E2 = v2.select("line"), A2 = m2.select("line"), C2 = p2.select("text").text(g2), z2 = v2.select("text"), L2 = m2.select("text"), q2 = "top" === r2 || "left" === r2 ? -1 : 1;
        if ("bottom" === r2 || "top" === r2 ? (n4 = na, w2 = "x", k2 = "y", S2 = "x2", N2 = "y2", C2.attr("dy", 0 > q2 ? "0em" : ".71em").style("text-anchor", "middle"), _6.attr("d", "M" + x2[0] + "," + q2 * i2 + "V0H" + x2[1] + "V" + q2 * i2)) : (n4 = ta, w2 = "y", k2 = "x", S2 = "y2", N2 = "x2", C2.attr("dy", ".32em").style("text-anchor", 0 > q2 ? "end" : "start"), _6.attr("d", "M" + q2 * i2 + "," + x2[0] + "H0V" + x2[1] + "H" + q2 * i2)), E2.attr(N2, q2 * u2), z2.attr(k2, q2 * M2), A2.attr(S2, 0).attr(N2, q2 * u2), L2.attr(w2, 0).attr(k2, q2 * M2), f2.rangeBand) {
          var T2 = f2, R2 = T2.rangeBand() / 2;
          s2 = f2 = function(n5) {
            return T2(n5) + R2;
          };
        } else s2.rangeBand ? s2 = f2 : d2.call(n4, f2, s2);
        v2.call(n4, s2, f2), m2.call(n4, f2, f2);
      });
    }
    var t2, e2 = oa.scale.linear(), r2 = Zl, u2 = 6, i2 = 6, a2 = 3, o2 = [10], l2 = null;
    return n2.scale = function(t3) {
      return arguments.length ? (e2 = t3, n2) : e2;
    }, n2.orient = function(t3) {
      return arguments.length ? (r2 = t3 in Vl ? t3 + "" : Zl, n2) : r2;
    }, n2.ticks = function() {
      return arguments.length ? (o2 = ca(arguments), n2) : o2;
    }, n2.tickValues = function(t3) {
      return arguments.length ? (l2 = t3, n2) : l2;
    }, n2.tickFormat = function(e3) {
      return arguments.length ? (t2 = e3, n2) : t2;
    }, n2.tickSize = function(t3) {
      var e3 = arguments.length;
      return e3 ? (u2 = +t3, i2 = +arguments[e3 - 1], n2) : u2;
    }, n2.innerTickSize = function(t3) {
      return arguments.length ? (u2 = +t3, n2) : u2;
    }, n2.outerTickSize = function(t3) {
      return arguments.length ? (i2 = +t3, n2) : i2;
    }, n2.tickPadding = function(t3) {
      return arguments.length ? (a2 = +t3, n2) : a2;
    }, n2.tickSubdivide = function() {
      return arguments.length && n2;
    }, n2;
  };
  var Zl = "bottom", Vl = { top: 1, right: 1, bottom: 1, left: 1 };
  oa.svg.brush = function() {
    function n2(t2) {
      t2.each(function() {
        var t3 = oa.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", i2).on("touchstart.brush", i2), a3 = t3.selectAll(".background").data([0]);
        a3.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"), t3.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var o3 = t3.selectAll(".resize").data(v2, y);
        o3.exit().remove(), o3.enter().append("g").attr("class", function(n3) {
          return "resize " + n3;
        }).style("cursor", function(n3) {
          return Xl[n3];
        }).append("rect").attr("x", function(n3) {
          return /[ew]$/.test(n3) ? -3 : null;
        }).attr("y", function(n3) {
          return /^[ns]/.test(n3) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden"), o3.style("display", n2.empty() ? "none" : null);
        var l3, f3 = oa.transition(t3), h3 = oa.transition(a3);
        c2 && (l3 = Zu(c2), h3.attr("x", l3[0]).attr("width", l3[1] - l3[0]), r2(f3)), s2 && (l3 = Zu(s2), h3.attr("y", l3[0]).attr("height", l3[1] - l3[0]), u2(f3)), e2(f3);
      });
    }
    function e2(n3) {
      n3.selectAll(".resize").attr("transform", function(n4) {
        return "translate(" + f2[+/e$/.test(n4)] + "," + h2[+/^s/.test(n4)] + ")";
      });
    }
    function r2(n3) {
      n3.select(".extent").attr("x", f2[0]), n3.selectAll(".extent,.n>rect,.s>rect").attr("width", f2[1] - f2[0]);
    }
    function u2(n3) {
      n3.select(".extent").attr("y", h2[0]), n3.selectAll(".extent,.e>rect,.w>rect").attr("height", h2[1] - h2[0]);
    }
    function i2() {
      function i3() {
        32 == oa.event.keyCode && (C2 || (M2 = null, L2[0] -= f2[1], L2[1] -= h2[1], C2 = 2), S());
      }
      function v3() {
        32 == oa.event.keyCode && 2 == C2 && (L2[0] += f2[1], L2[1] += h2[1], C2 = 0, S());
      }
      function d2() {
        var n3 = oa.mouse(b2), t2 = false;
        x2 && (n3[0] += x2[0], n3[1] += x2[1]), C2 || (oa.event.altKey ? (M2 || (M2 = [(f2[0] + f2[1]) / 2, (h2[0] + h2[1]) / 2]), L2[0] = f2[+(n3[0] < M2[0])], L2[1] = h2[+(n3[1] < M2[1])]) : M2 = null), E2 && m2(n3, c2, 0) && (r2(k2), t2 = true), A2 && m2(n3, s2, 1) && (u2(k2), t2 = true), t2 && (e2(k2), w2({ type: "brush", mode: C2 ? "move" : "resize" }));
      }
      function m2(n3, t2, e3) {
        var r3, u3, i4 = Zu(t2), l3 = i4[0], c3 = i4[1], s3 = L2[e3], v4 = e3 ? h2 : f2, d4 = v4[1] - v4[0];
        return C2 && (l3 -= s3, c3 -= d4 + s3), r3 = (e3 ? p2 : g2) ? Math.max(l3, Math.min(c3, n3[e3])) : n3[e3], C2 ? u3 = (r3 += s3) + d4 : (M2 && (s3 = Math.max(l3, Math.min(c3, 2 * M2[e3] - r3))), r3 > s3 ? (u3 = r3, r3 = s3) : u3 = s3), v4[0] != r3 || v4[1] != u3 ? (e3 ? o2 = null : a2 = null, v4[0] = r3, v4[1] = u3, true) : void 0;
      }
      function y2() {
        d2(), k2.style("pointer-events", "all").selectAll(".resize").style("display", n2.empty() ? "none" : null), oa.select("body").style("cursor", null), q2.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null), z2(), w2({ type: "brushend" });
      }
      var M2, x2, b2 = this, _6 = oa.select(oa.event.target), w2 = l2.of(b2, arguments), k2 = oa.select(b2), N2 = _6.datum(), E2 = !/^(n|s)$/.test(N2) && c2, A2 = !/^(e|w)$/.test(N2) && s2, C2 = _6.classed("extent"), z2 = W(b2), L2 = oa.mouse(b2), q2 = oa.select(t(b2)).on("keydown.brush", i3).on("keyup.brush", v3);
      if (oa.event.changedTouches ? q2.on("touchmove.brush", d2).on("touchend.brush", y2) : q2.on("mousemove.brush", d2).on("mouseup.brush", y2), k2.interrupt().selectAll("*").interrupt(), C2) L2[0] = f2[0] - L2[0], L2[1] = h2[0] - L2[1];
      else if (N2) {
        var T2 = +/w$/.test(N2), R2 = +/^n/.test(N2);
        x2 = [f2[1 - T2] - L2[0], h2[1 - R2] - L2[1]], L2[0] = f2[T2], L2[1] = h2[R2];
      } else oa.event.altKey && (M2 = L2.slice());
      k2.style("pointer-events", "none").selectAll(".resize").style("display", null), oa.select("body").style("cursor", _6.style("cursor")), w2({ type: "brushstart" }), d2();
    }
    var a2, o2, l2 = N(n2, "brushstart", "brush", "brushend"), c2 = null, s2 = null, f2 = [0, 0], h2 = [0, 0], g2 = true, p2 = true, v2 = $l[0];
    return n2.event = function(n3) {
      n3.each(function() {
        var n4 = l2.of(this, arguments), t2 = { x: f2, y: h2, i: a2, j: o2 }, e3 = this.__chart__ || t2;
        this.__chart__ = t2, Fl ? oa.select(this).transition().each("start.brush", function() {
          a2 = e3.i, o2 = e3.j, f2 = e3.x, h2 = e3.y, n4({ type: "brushstart" });
        }).tween("brush:brush", function() {
          var e4 = xr(f2, t2.x), r3 = xr(h2, t2.y);
          return a2 = o2 = null, function(u3) {
            f2 = t2.x = e4(u3), h2 = t2.y = r3(u3), n4({ type: "brush", mode: "resize" });
          };
        }).each("end.brush", function() {
          a2 = t2.i, o2 = t2.j, n4({ type: "brush", mode: "resize" }), n4({ type: "brushend" });
        }) : (n4({ type: "brushstart" }), n4({ type: "brush", mode: "resize" }), n4({ type: "brushend" }));
      });
    }, n2.x = function(t2) {
      return arguments.length ? (c2 = t2, v2 = $l[!c2 << 1 | !s2], n2) : c2;
    }, n2.y = function(t2) {
      return arguments.length ? (s2 = t2, v2 = $l[!c2 << 1 | !s2], n2) : s2;
    }, n2.clamp = function(t2) {
      return arguments.length ? (c2 && s2 ? (g2 = !!t2[0], p2 = !!t2[1]) : c2 ? g2 = !!t2 : s2 && (p2 = !!t2), n2) : c2 && s2 ? [g2, p2] : c2 ? g2 : s2 ? p2 : null;
    }, n2.extent = function(t2) {
      var e3, r3, u3, i3, l3;
      return arguments.length ? (c2 && (e3 = t2[0], r3 = t2[1], s2 && (e3 = e3[0], r3 = r3[0]), a2 = [e3, r3], c2.invert && (e3 = c2(e3), r3 = c2(r3)), e3 > r3 && (l3 = e3, e3 = r3, r3 = l3), (e3 != f2[0] || r3 != f2[1]) && (f2 = [e3, r3])), s2 && (u3 = t2[0], i3 = t2[1], c2 && (u3 = u3[1], i3 = i3[1]), o2 = [u3, i3], s2.invert && (u3 = s2(u3), i3 = s2(i3)), u3 > i3 && (l3 = u3, u3 = i3, i3 = l3), (u3 != h2[0] || i3 != h2[1]) && (h2 = [u3, i3])), n2) : (c2 && (a2 ? (e3 = a2[0], r3 = a2[1]) : (e3 = f2[0], r3 = f2[1], c2.invert && (e3 = c2.invert(e3), r3 = c2.invert(r3)), e3 > r3 && (l3 = e3, e3 = r3, r3 = l3))), s2 && (o2 ? (u3 = o2[0], i3 = o2[1]) : (u3 = h2[0], i3 = h2[1], s2.invert && (u3 = s2.invert(u3), i3 = s2.invert(i3)), u3 > i3 && (l3 = u3, u3 = i3, i3 = l3))), c2 && s2 ? [[e3, u3], [r3, i3]] : c2 ? [e3, r3] : s2 && [u3, i3]);
    }, n2.clear = function() {
      return n2.empty() || (f2 = [0, 0], h2 = [0, 0], a2 = o2 = null), n2;
    }, n2.empty = function() {
      return !!c2 && f2[0] == f2[1] || !!s2 && h2[0] == h2[1];
    }, oa.rebind(n2, l2, "on");
  };
  var Xl = { n: "ns-resize", e: "ew-resize", s: "ns-resize", w: "ew-resize", nw: "nwse-resize", ne: "nesw-resize", se: "nwse-resize", sw: "nesw-resize" }, $l = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []], Bl = ho.format = Mo.timeFormat, Wl = Bl.utc, Jl = Wl("%Y-%m-%dT%H:%M:%S.%LZ");
  Bl.iso = Date.prototype.toISOString && +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? ea : Jl, ea.parse = function(n2) {
    var t2 = new Date(n2);
    return isNaN(t2) ? null : t2;
  }, ea.toString = Jl.toString, ho.second = On(function(n2) {
    return new go(1e3 * Math.floor(n2 / 1e3));
  }, function(n2, t2) {
    n2.setTime(n2.getTime() + 1e3 * Math.floor(t2));
  }, function(n2) {
    return n2.getSeconds();
  }), ho.seconds = ho.second.range, ho.seconds.utc = ho.second.utc.range, ho.minute = On(function(n2) {
    return new go(6e4 * Math.floor(n2 / 6e4));
  }, function(n2, t2) {
    n2.setTime(n2.getTime() + 6e4 * Math.floor(t2));
  }, function(n2) {
    return n2.getMinutes();
  }), ho.minutes = ho.minute.range, ho.minutes.utc = ho.minute.utc.range, ho.hour = On(function(n2) {
    var t2 = n2.getTimezoneOffset() / 60;
    return new go(36e5 * (Math.floor(n2 / 36e5 - t2) + t2));
  }, function(n2, t2) {
    n2.setTime(n2.getTime() + 36e5 * Math.floor(t2));
  }, function(n2) {
    return n2.getHours();
  }), ho.hours = ho.hour.range, ho.hours.utc = ho.hour.utc.range, ho.month = On(function(n2) {
    return n2 = ho.day(n2), n2.setDate(1), n2;
  }, function(n2, t2) {
    n2.setMonth(n2.getMonth() + t2);
  }, function(n2) {
    return n2.getMonth();
  }), ho.months = ho.month.range, ho.months.utc = ho.month.utc.range;
  var Gl = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6], Kl = [[ho.second, 1], [ho.second, 5], [ho.second, 15], [ho.second, 30], [ho.minute, 1], [ho.minute, 5], [ho.minute, 15], [ho.minute, 30], [ho.hour, 1], [ho.hour, 3], [ho.hour, 6], [ho.hour, 12], [ho.day, 1], [ho.day, 2], [ho.week, 1], [ho.month, 1], [ho.month, 3], [ho.year, 1]], Ql = Bl.multi([[".%L", function(n2) {
    return n2.getMilliseconds();
  }], [":%S", function(n2) {
    return n2.getSeconds();
  }], ["%I:%M", function(n2) {
    return n2.getMinutes();
  }], ["%I %p", function(n2) {
    return n2.getHours();
  }], ["%a %d", function(n2) {
    return n2.getDay() && 1 != n2.getDate();
  }], ["%b %d", function(n2) {
    return 1 != n2.getDate();
  }], ["%B", function(n2) {
    return n2.getMonth();
  }], ["%Y", zt]]), nc = { range: function(n2, t2, e2) {
    return oa.range(Math.ceil(n2 / e2) * e2, +t2, e2).map(ua);
  }, floor: y, ceil: y };
  Kl.year = ho.year, ho.scale = function() {
    return ra(oa.scale.linear(), Kl, Ql);
  };
  var tc = Kl.map(function(n2) {
    return [n2[0].utc, n2[1]];
  }), ec = Wl.multi([[".%L", function(n2) {
    return n2.getUTCMilliseconds();
  }], [":%S", function(n2) {
    return n2.getUTCSeconds();
  }], ["%I:%M", function(n2) {
    return n2.getUTCMinutes();
  }], ["%I %p", function(n2) {
    return n2.getUTCHours();
  }], ["%a %d", function(n2) {
    return n2.getUTCDay() && 1 != n2.getUTCDate();
  }], ["%b %d", function(n2) {
    return 1 != n2.getUTCDate();
  }], ["%B", function(n2) {
    return n2.getUTCMonth();
  }], ["%Y", zt]]);
  tc.year = ho.year.utc, ho.scale.utc = function() {
    return ra(oa.scale.linear(), tc, ec);
  }, oa.text = An(function(n2) {
    return n2.responseText;
  }), oa.json = function(n2, t2) {
    return Cn(n2, "application/json", ia, t2);
  }, oa.html = function(n2, t2) {
    return Cn(n2, "text/html", aa, t2);
  }, oa.xml = An(function(n2) {
    return n2.responseXML;
  }), "function" == typeof define && define.amd ? (this.d3 = oa, define(oa)) : "object" == typeof module && module.exports ? module.exports = oa : this.d3 = oa;
}.apply(window);

// src/helpers/pptx/assets/nv.d3.min.js
!function() {
  var a = {};
  a.dev = false, a.tooltip = a.tooltip || {}, a.utils = a.utils || {}, a.models = a.models || {}, a.charts = {}, a.logs = {}, a.dom = {}, a.dispatch = d3.dispatch("render_start", "render_end"), Function.prototype.bind || (Function.prototype.bind = function(a2) {
    if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var b = Array.prototype.slice.call(arguments, 1), c = this, d = function() {
    }, e = function() {
      return c.apply(this instanceof d && a2 ? this : a2, b.concat(Array.prototype.slice.call(arguments)));
    };
    return d.prototype = this.prototype, e.prototype = new d(), e;
  }), a.dev && (a.dispatch.on("render_start", function(b) {
    a.logs.startTime = +/* @__PURE__ */ new Date();
  }), a.dispatch.on("render_end", function(b) {
    a.logs.endTime = +/* @__PURE__ */ new Date(), a.logs.totalTime = a.logs.endTime - a.logs.startTime, a.log("total", a.logs.totalTime);
  })), a.log = function() {
    if (a.dev && window.console && console.log && console.log.apply) console.log.apply(console, arguments);
    else if (a.dev && window.console && "function" == typeof console.log && Function.prototype.bind) {
      var b = Function.prototype.bind.call(console.log, console);
      b.apply(console, arguments);
    }
    return arguments[arguments.length - 1];
  }, a.deprecated = function(a2, b) {
    console && console.warn && console.warn("nvd3 warning: `" + a2 + "` has been deprecated. ", b || "");
  }, a.render = function(b) {
    b = b || 1, a.render.active = true, a.dispatch.render_start();
    var c = function() {
      for (var d, e, f = 0; b > f && (e = a.render.queue[f]); f++) d = e.generate(), typeof e.callback == typeof Function && e.callback(d);
      a.render.queue.splice(0, f), a.render.queue.length ? setTimeout(c) : (a.dispatch.render_end(), a.render.active = false);
    };
    setTimeout(c);
  }, a.render.active = false, a.render.queue = [], a.addGraph = function(b) {
    typeof arguments[0] == typeof Function && (b = { generate: arguments[0], callback: arguments[1] }), a.render.queue.push(b), a.render.active || a.render();
  }, "undefined" != typeof module && "undefined" != typeof exports && (module.exports = a), "undefined" != typeof window && (window.nv = a), a.dom.write = function(a2) {
    return void 0 !== window.fastdom ? fastdom.write(a2) : a2();
  }, a.dom.read = function(a2) {
    return void 0 !== window.fastdom ? fastdom.read(a2) : a2();
  }, a.interactiveGuideline = function() {
    "use strict";
    function b(l) {
      l.each(function(l2) {
        function m() {
          var a2 = d3.mouse(this), d2 = a2[0], e2 = a2[1], h2 = true, i2 = false;
          if (k && (d2 = d3.event.offsetX, e2 = d3.event.offsetY, "svg" !== d3.event.target.tagName && (h2 = false), d3.event.target.className.baseVal.match("nv-legend") && (i2 = true)), h2 && (d2 -= c.left, e2 -= c.top), 0 > d2 || 0 > e2 || d2 > o || e2 > p || d3.event.relatedTarget && void 0 === d3.event.relatedTarget.ownerSVGElement || i2) {
            if (k && d3.event.relatedTarget && void 0 === d3.event.relatedTarget.ownerSVGElement && (void 0 === d3.event.relatedTarget.className || d3.event.relatedTarget.className.match(j.nvPointerEventsClass))) return;
            return g.elementMouseout({ mouseX: d2, mouseY: e2 }), b.renderGuideLine(null), void j.hidden(true);
          }
          j.hidden(false);
          var l3 = f.invert(d2);
          g.elementMousemove({ mouseX: d2, mouseY: e2, pointXValue: l3 }), "dblclick" === d3.event.type && g.elementDblclick({ mouseX: d2, mouseY: e2, pointXValue: l3 }), "click" === d3.event.type && g.elementClick({ mouseX: d2, mouseY: e2, pointXValue: l3 }), "mousedown" === d3.event.type && g.elementMouseDown({ mouseX: d2, mouseY: e2, pointXValue: l3 }), "mouseup" === d3.event.type && g.elementMouseUp({ mouseX: d2, mouseY: e2, pointXValue: l3 });
        }
        var n = d3.select(this), o = d || 960, p = e || 400, q = n.selectAll("g.nv-wrap.nv-interactiveLineLayer").data([l2]), r = q.enter().append("g").attr("class", " nv-wrap nv-interactiveLineLayer");
        r.append("g").attr("class", "nv-interactiveGuideLine"), i && (i.on("touchmove", m).on("mousemove", m, true).on("mouseout", m, true).on("mousedown", m, true).on("mouseup", m, true).on("dblclick", m).on("click", m), b.guideLine = null, b.renderGuideLine = function(c2) {
          h && (b.guideLine && b.guideLine.attr("x1") === c2 || a.dom.write(function() {
            var b2 = q.select(".nv-interactiveGuideLine").selectAll("line").data(null != c2 ? [a.utils.NaNtoZero(c2)] : [], String);
            b2.enter().append("line").attr("class", "nv-guideline").attr("x1", function(a2) {
              return a2;
            }).attr("x2", function(a2) {
              return a2;
            }).attr("y1", p).attr("y2", 0), b2.exit().remove();
          }));
        });
      });
    }
    var c = { left: 0, top: 0 }, d = null, e = null, f = d3.scale.linear(), g = d3.dispatch("elementMousemove", "elementMouseout", "elementClick", "elementDblclick", "elementMouseDown", "elementMouseUp"), h = true, i = null, j = a.models.tooltip(), k = "ActiveXObject" in window;
    return j.duration(0).hideDelay(0).hidden(false), b.dispatch = g, b.tooltip = j, b.margin = function(a2) {
      return arguments.length ? (c.top = "undefined" != typeof a2.top ? a2.top : c.top, c.left = "undefined" != typeof a2.left ? a2.left : c.left, b) : c;
    }, b.width = function(a2) {
      return arguments.length ? (d = a2, b) : d;
    }, b.height = function(a2) {
      return arguments.length ? (e = a2, b) : e;
    }, b.xScale = function(a2) {
      return arguments.length ? (f = a2, b) : f;
    }, b.showGuideLine = function(a2) {
      return arguments.length ? (h = a2, b) : h;
    }, b.svgContainer = function(a2) {
      return arguments.length ? (i = a2, b) : i;
    }, b;
  }, a.interactiveBisect = function(a2, b, c) {
    "use strict";
    if (!(a2 instanceof Array)) return null;
    var d;
    d = "function" != typeof c ? function(a3) {
      return a3.x;
    } : c;
    var e = function(a3, b2) {
      return d(a3) - b2;
    }, f = d3.bisector(e).left, g = d3.max([0, f(a2, b) - 1]), h = d(a2[g]);
    if ("undefined" == typeof h && (h = g), h === b) return g;
    var i = d3.min([g + 1, a2.length - 1]), j = d(a2[i]);
    return "undefined" == typeof j && (j = i), Math.abs(j - b) >= Math.abs(h - b) ? g : i;
  }, a.nearestValueIndex = function(a2, b, c) {
    "use strict";
    var d = 1 / 0, e = null;
    return a2.forEach(function(a3, f) {
      var g = Math.abs(b - a3);
      null != a3 && d >= g && c > g && (d = g, e = f);
    }), e;
  }, a.models.tooltip = function() {
    "use strict";
    function b() {
      if (!m) {
        var a2 = j ? j : document.body;
        m = d3.select(a2).append("div").attr("class", "nvtooltip " + (i ? i : "xy-tooltip")).attr("id", d), m.style("top", 0).style("left", 0), m.style("opacity", 0), m.style("position", "fixed"), m.selectAll("div, table, td, tr").classed(r, true), m.classed(r, true);
      }
    }
    function c() {
      return o && x(e) ? (a.dom.write(function() {
        b();
        var a2 = w(e);
        a2 && (m.node().innerHTML = a2), z();
      }), c) : void 0;
    }
    var d = "nvtooltip-" + Math.floor(1e5 * Math.random()), e = null, f = "w", g = 25, h = 0, i = null, j = null, k = true, l = 200, m = null, n = { left: null, top: null }, o = true, p = 100, q = true, r = "nv-pointer-events-none", s = function() {
      return { left: d3.event.clientX, top: d3.event.clientY };
    }, t = function(a2, b2) {
      return a2;
    }, u = function(a2) {
      return a2;
    }, v = function(a2, b2) {
      return a2;
    }, w = function(a2) {
      if (null === a2) return "";
      var b2 = d3.select(document.createElement("table"));
      if (q) {
        var c2 = b2.selectAll("thead").data([a2]).enter().append("thead");
        c2.append("tr").append("td").attr("colspan", 3).append("strong").classed("x-value", true).html(u(a2.value));
      }
      var d2 = b2.selectAll("tbody").data([a2]).enter().append("tbody"), e2 = d2.selectAll("tr").data(function(a3) {
        return a3.series;
      }).enter().append("tr").classed("highlight", function(a3) {
        return a3.highlight;
      });
      e2.append("td").classed("legend-color-guide", true).append("div").style("background-color", function(a3) {
        return a3.color;
      }), e2.append("td").classed("key", true).classed("total", function(a3) {
        return !!a3.total;
      }).html(function(a3, b3) {
        return v(a3.key, b3);
      }), e2.append("td").classed("value", true).html(function(a3, b3) {
        return t(a3.value, b3);
      }), e2.selectAll("td").each(function(a3) {
        if (a3.highlight) {
          var b3 = d3.scale.linear().domain([0, 1]).range(["#fff", a3.color]), c3 = 0.6;
          d3.select(this).style("border-bottom-color", b3(c3)).style("border-top-color", b3(c3));
        }
      });
      var f2 = b2.node().outerHTML;
      return void 0 !== a2.footer && (f2 += "<div class='footer'>" + a2.footer + "</div>"), f2;
    }, x = function(a2) {
      if (a2 && a2.series) {
        if (a2.series instanceof Array) return !!a2.series.length;
        if (a2.series instanceof Object) return a2.series = [a2.series], true;
      }
      return false;
    }, y = function(a2) {
      var b2, c2, d2, e2 = m.node().offsetHeight, h2 = m.node().offsetWidth, i2 = document.documentElement.clientWidth, j2 = document.documentElement.clientHeight;
      switch (f) {
        case "e":
          b2 = -h2 - g, c2 = -(e2 / 2), a2.left + b2 < 0 && (b2 = g), (d2 = a2.top + c2) < 0 && (c2 -= d2), (d2 = a2.top + c2 + e2) > j2 && (c2 -= d2 - j2);
          break;
        case "w":
          b2 = g, c2 = -(e2 / 2), a2.left + b2 + h2 > i2 && (b2 = -h2 - g), (d2 = a2.top + c2) < 0 && (c2 -= d2), (d2 = a2.top + c2 + e2) > j2 && (c2 -= d2 - j2);
          break;
        case "n":
          b2 = -(h2 / 2) - 5, c2 = g, a2.top + c2 + e2 > j2 && (c2 = -e2 - g), (d2 = a2.left + b2) < 0 && (b2 -= d2), (d2 = a2.left + b2 + h2) > i2 && (b2 -= d2 - i2);
          break;
        case "s":
          b2 = -(h2 / 2), c2 = -e2 - g, a2.top + c2 < 0 && (c2 = g), (d2 = a2.left + b2) < 0 && (b2 -= d2), (d2 = a2.left + b2 + h2) > i2 && (b2 -= d2 - i2);
          break;
        case "center":
          b2 = -(h2 / 2), c2 = -(e2 / 2);
          break;
        default:
          b2 = 0, c2 = 0;
      }
      return { left: b2, top: c2 };
    }, z = function() {
      a.dom.read(function() {
        var a2 = s(), b2 = y(a2), c2 = a2.left + b2.left, d2 = a2.top + b2.top;
        if (k) m.interrupt().transition().delay(l).duration(0).style("opacity", 0);
        else {
          var e2 = "translate(" + n.left + "px, " + n.top + "px)", f2 = "translate(" + c2 + "px, " + d2 + "px)", g2 = d3.interpolateString(e2, f2), h2 = m.style("opacity") < 0.1;
          m.interrupt().transition().duration(h2 ? 0 : p).styleTween("transform", function(a3) {
            return g2;
          }, "important").styleTween("-webkit-transform", function(a3) {
            return g2;
          }).style("-ms-transform", f2).style("opacity", 1);
        }
        n.left = c2, n.top = d2;
      });
    };
    return c.nvPointerEventsClass = r, c.options = a.utils.optionsFunc.bind(c), c._options = Object.create({}, { duration: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, gravity: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, distance: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, snapDistance: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, classes: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, chartContainer: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, enabled: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, hideDelay: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, contentGenerator: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, valueFormatter: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, headerFormatter: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, keyFormatter: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, headerEnabled: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, position: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, hidden: { get: function() {
      return k;
    }, set: function(a2) {
      k != a2 && (k = !!a2, c());
    } }, data: { get: function() {
      return e;
    }, set: function(a2) {
      a2.point && (a2.value = a2.point.x, a2.series = a2.series || {}, a2.series.value = a2.point.y, a2.series.color = a2.point.color || a2.series.color), e = a2;
    } }, node: { get: function() {
      return m.node();
    }, set: function(a2) {
    } }, id: { get: function() {
      return d;
    }, set: function(a2) {
    } } }), a.utils.initOptions(c), c;
  }, a.utils.windowSize = function() {
    var a2 = { width: 640, height: 480 };
    return window.innerWidth && window.innerHeight ? (a2.width = window.innerWidth, a2.height = window.innerHeight, a2) : "CSS1Compat" == document.compatMode && document.documentElement && document.documentElement.offsetWidth ? (a2.width = document.documentElement.offsetWidth, a2.height = document.documentElement.offsetHeight, a2) : document.body && document.body.offsetWidth ? (a2.width = document.body.offsetWidth, a2.height = document.body.offsetHeight, a2) : a2;
  }, a.utils.windowResize = function(b) {
    return window.addEventListener ? window.addEventListener("resize", b) : a.log("ERROR: Failed to bind to window.resize with: ", b), { callback: b, clear: function() {
      window.removeEventListener("resize", b);
    } };
  }, a.utils.getColor = function(b) {
    if (void 0 === b) return a.utils.defaultColor();
    if (Array.isArray(b)) {
      var c = d3.scale.ordinal().range(b);
      return function(a2, b2) {
        var d = void 0 === b2 ? a2 : b2;
        return a2.color || c(d);
      };
    }
    return b;
  }, a.utils.defaultColor = function() {
    return a.utils.getColor(d3.scale.category20().range());
  }, a.utils.customTheme = function(a2, b, c) {
    b = b || function(a3) {
      return a3.key;
    }, c = c || d3.scale.category20().range();
    var d = c.length;
    return function(e, f) {
      var g = b(e);
      return "function" == typeof a2[g] ? a2[g]() : void 0 !== a2[g] ? a2[g] : (d || (d = c.length), d -= 1, c[d]);
    };
  }, a.utils.pjax = function(b, c) {
    var d = function(d2) {
      d3.html(d2, function(d4) {
        var e = d3.select(c).node();
        e.parentNode.replaceChild(d3.select(d4).select(c).node(), e), a.utils.pjax(b, c);
      });
    };
    d3.selectAll(b).on("click", function() {
      history.pushState(this.href, this.textContent, this.href), d(this.href), d3.event.preventDefault();
    }), d3.select(window).on("popstate", function() {
      d3.event.state && d(d3.event.state);
    });
  }, a.utils.calcApproxTextWidth = function(a2) {
    if ("function" == typeof a2.style && "function" == typeof a2.text) {
      var b = parseInt(a2.style("font-size").replace("px", ""), 10), c = a2.text().length;
      return c * b * 0.5;
    }
    return 0;
  }, a.utils.NaNtoZero = function(a2) {
    return "number" != typeof a2 || isNaN(a2) || null === a2 || a2 === 1 / 0 || a2 === -(1 / 0) ? 0 : a2;
  }, d3.selection.prototype.watchTransition = function(a2) {
    var b = [this].concat([].slice.call(arguments, 1));
    return a2.transition.apply(a2, b);
  }, a.utils.renderWatch = function(b, c) {
    if (!(this instanceof a.utils.renderWatch)) return new a.utils.renderWatch(b, c);
    var d = void 0 !== c ? c : 250, e = [], f = this;
    this.models = function(a2) {
      return a2 = [].slice.call(arguments, 0), a2.forEach(function(a3) {
        a3.__rendered = false, function(a4) {
          a4.dispatch.on("renderEnd", function(b2) {
            a4.__rendered = true, f.renderEnd("model");
          });
        }(a3), e.indexOf(a3) < 0 && e.push(a3);
      }), this;
    }, this.reset = function(a2) {
      void 0 !== a2 && (d = a2), e = [];
    }, this.transition = function(a2, b2, c2) {
      if (b2 = arguments.length > 1 ? [].slice.call(arguments, 1) : [], c2 = b2.length > 1 ? b2.pop() : void 0 !== d ? d : 250, a2.__rendered = false, e.indexOf(a2) < 0 && e.push(a2), 0 === c2) return a2.__rendered = true, a2.delay = function() {
        return this;
      }, a2.duration = function() {
        return this;
      }, a2;
      0 === a2.length ? a2.__rendered = true : a2.every(function(a3) {
        return !a3.length;
      }) ? a2.__rendered = true : a2.__rendered = false;
      var g = 0;
      return a2.transition().duration(c2).each(function() {
        ++g;
      }).each("end", function(c3, d2) {
        0 === --g && (a2.__rendered = true, f.renderEnd.apply(this, b2));
      });
    }, this.renderEnd = function() {
      e.every(function(a2) {
        return a2.__rendered;
      }) && (e.forEach(function(a2) {
        a2.__rendered = false;
      }), b.renderEnd.apply(this, arguments));
    };
  }, a.utils.deepExtend = function(b) {
    var c = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    c.forEach(function(c2) {
      for (var d in c2) {
        var e = b[d] instanceof Array, f = "object" == typeof b[d], g = "object" == typeof c2[d];
        f && !e && g ? a.utils.deepExtend(b[d], c2[d]) : b[d] = c2[d];
      }
    });
  }, a.utils.state = function() {
    if (!(this instanceof a.utils.state)) return new a.utils.state();
    var b = {}, c = function() {
    }, d = function() {
      return {};
    }, e = null, f = null;
    this.dispatch = d3.dispatch("change", "set"), this.dispatch.on("set", function(a2) {
      c(a2, true);
    }), this.getter = function(a2) {
      return d = a2, this;
    }, this.setter = function(a2, b2) {
      return b2 || (b2 = function() {
      }), c = function(c2, d2) {
        a2(c2), d2 && b2();
      }, this;
    }, this.init = function(b2) {
      e = e || {}, a.utils.deepExtend(e, b2);
    };
    var g = function() {
      var a2 = d();
      if (JSON.stringify(a2) === JSON.stringify(b)) return false;
      for (var c2 in a2) void 0 === b[c2] && (b[c2] = {}), b[c2] = a2[c2], f = true;
      return true;
    };
    this.update = function() {
      e && (c(e, false), e = null), g.call(this) && this.dispatch.change(b);
    };
  }, a.utils.optionsFunc = function(a2) {
    return a2 && d3.map(a2).forEach(function(a3, b) {
      "function" == typeof this[a3] && this[a3](b);
    }.bind(this)), this;
  }, a.utils.calcTicksX = function(b, c) {
    var d = 1, e = 0;
    for (e; e < c.length; e += 1) {
      var f = c[e] && c[e].values ? c[e].values.length : 0;
      d = f > d ? f : d;
    }
    return a.log("Requested number of ticks: ", b), a.log("Calculated max values to be: ", d), b = b > d ? b = d - 1 : b, b = 1 > b ? 1 : b, b = Math.floor(b), a.log("Calculating tick count as: ", b), b;
  }, a.utils.calcTicksY = function(b, c) {
    return a.utils.calcTicksX(b, c);
  }, a.utils.initOption = function(a2, b) {
    a2._calls && a2._calls[b] ? a2[b] = a2._calls[b] : (a2[b] = function(c) {
      return arguments.length ? (a2._overrides[b] = true, a2._options[b] = c, a2) : a2._options[b];
    }, a2["_" + b] = function(c) {
      return arguments.length ? (a2._overrides[b] || (a2._options[b] = c), a2) : a2._options[b];
    });
  }, a.utils.initOptions = function(b) {
    b._overrides = b._overrides || {};
    var c = Object.getOwnPropertyNames(b._options || {}), d = Object.getOwnPropertyNames(b._calls || {});
    c = c.concat(d);
    for (var e in c) a.utils.initOption(b, c[e]);
  }, a.utils.inheritOptionsD3 = function(a2, b, c) {
    a2._d3options = c.concat(a2._d3options || []), c.unshift(b), c.unshift(a2), d3.rebind.apply(this, c);
  }, a.utils.arrayUnique = function(a2) {
    return a2.sort().filter(function(b, c) {
      return !c || b != a2[c - 1];
    });
  }, a.utils.symbolMap = d3.map(), a.utils.symbol = function() {
    function b(b2, e) {
      var f = c.call(this, b2, e), g = d.call(this, b2, e);
      return -1 !== d3.svg.symbolTypes.indexOf(f) ? d3.svg.symbol().type(f).size(g)() : a.utils.symbolMap.get(f)(g);
    }
    var c, d = 64;
    return b.type = function(a2) {
      return arguments.length ? (c = d3.functor(a2), b) : c;
    }, b.size = function(a2) {
      return arguments.length ? (d = d3.functor(a2), b) : d;
    }, b;
  }, a.utils.inheritOptions = function(b, c) {
    var d = Object.getOwnPropertyNames(c._options || {}), e = Object.getOwnPropertyNames(c._calls || {}), f = c._inherited || [], g = c._d3options || [], h = d.concat(e).concat(f).concat(g);
    h.unshift(c), h.unshift(b), d3.rebind.apply(this, h), b._inherited = a.utils.arrayUnique(d.concat(e).concat(f).concat(d).concat(b._inherited || [])), b._d3options = a.utils.arrayUnique(g.concat(b._d3options || []));
  }, a.utils.initSVG = function(a2) {
    a2.classed({ "nvd3-svg": true });
  }, a.utils.sanitizeHeight = function(a2, b) {
    return a2 || parseInt(b.style("height"), 10) || 400;
  }, a.utils.sanitizeWidth = function(a2, b) {
    return a2 || parseInt(b.style("width"), 10) || 960;
  }, a.utils.availableHeight = function(b, c, d) {
    return a.utils.sanitizeHeight(b, c) - d.top - d.bottom;
  }, a.utils.availableWidth = function(b, c, d) {
    return a.utils.sanitizeWidth(b, c) - d.left - d.right;
  }, a.utils.noData = function(b, c) {
    var d = b.options(), e = d.margin(), f = d.noData(), g = null == f ? ["No Data Available."] : [f], h = a.utils.availableHeight(null, c, e), i = a.utils.availableWidth(null, c, e), j = e.left + i / 2, k = e.top + h / 2;
    c.selectAll("g").remove();
    var l = c.selectAll(".nv-noData").data(g);
    l.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle"), l.attr("x", j).attr("y", k).text(function(a2) {
      return a2;
    });
  }, a.utils.wrapTicks = function(a2, b) {
    a2.each(function() {
      for (var a3, c = d3.select(this), d = c.text().split(/\s+/).reverse(), e = [], f = 0, g = 1.1, h = c.attr("y"), i = parseFloat(c.attr("dy")), j = c.text(null).append("tspan").attr("x", 0).attr("y", h).attr("dy", i + "em"); a3 = d.pop(); ) e.push(a3), j.text(e.join(" ")), j.node().getComputedTextLength() > b && (e.pop(), j.text(e.join(" ")), e = [a3], j = c.append("tspan").attr("x", 0).attr("y", h).attr("dy", ++f * g + i + "em").text(a3));
    });
  }, a.models.axis = function() {
    "use strict";
    function b(g2) {
      return s.reset(), g2.each(function(b2) {
        var g3 = d3.select(this);
        a.utils.initSVG(g3);
        var p2 = g3.selectAll("g.nv-wrap.nv-axis").data([b2]), q2 = p2.enter().append("g").attr("class", "nvd3 nv-wrap nv-axis"), t = (q2.append("g"), p2.select("g"));
        null !== n ? c.ticks(n) : ("top" == c.orient() || "bottom" == c.orient()) && c.ticks(Math.abs(d.range()[1] - d.range()[0]) / 100), t.watchTransition(s, "axis").call(c), r = r || c.scale();
        var u = c.tickFormat();
        null == u && (u = r.tickFormat());
        var v = t.selectAll("text.nv-axislabel").data([h || null]);
        v.exit().remove();
        var w, x, y;
        switch (c.orient()) {
          case "top":
            v.enter().append("text").attr("class", "nv-axislabel"), y = 0, 1 === d.range().length ? y = m ? 2 * d.range()[0] + d.rangeBand() : 0 : 2 === d.range().length ? y = m ? d.range()[0] + d.range()[1] + d.rangeBand() : d.range()[1] : d.range().length > 2 && (y = d.range()[d.range().length - 1] + (d.range()[1] - d.range()[0])), v.attr("text-anchor", "middle").attr("y", 0).attr("x", y / 2), i && (x = p2.selectAll("g.nv-axisMaxMin").data(d.domain()), x.enter().append("g").attr("class", function(a2, b3) {
              return ["nv-axisMaxMin", "nv-axisMaxMin-x", 0 == b3 ? "nv-axisMin-x" : "nv-axisMax-x"].join(" ");
            }).append("text"), x.exit().remove(), x.attr("transform", function(b3, c2) {
              return "translate(" + a.utils.NaNtoZero(d(b3)) + ",0)";
            }).select("text").attr("dy", "-0.5em").attr("y", -c.tickPadding()).attr("text-anchor", "middle").text(function(a2, b3) {
              var c2 = u(a2);
              return ("" + c2).match("NaN") ? "" : c2;
            }), x.watchTransition(s, "min-max top").attr("transform", function(b3, c2) {
              return "translate(" + a.utils.NaNtoZero(d.range()[c2]) + ",0)";
            }));
            break;
          case "bottom":
            w = o + 36;
            var z = 30, A = 0, B = t.selectAll("g").select("text"), C = "";
            if (j % 360) {
              B.each(function(a2, b3) {
                var c2 = this.getBoundingClientRect(), d2 = c2.width;
                A = c2.height, d2 > z && (z = d2);
              }), C = "rotate(" + j + " 0," + (A / 2 + c.tickPadding()) + ")";
              var D = Math.abs(Math.sin(j * Math.PI / 180));
              w = (D ? D * z : z) + 30, B.attr("transform", C).style("text-anchor", j % 360 > 0 ? "start" : "end");
            }
            v.enter().append("text").attr("class", "nv-axislabel"), y = 0, 1 === d.range().length ? y = m ? 2 * d.range()[0] + d.rangeBand() : 0 : 2 === d.range().length ? y = m ? d.range()[0] + d.range()[1] + d.rangeBand() : d.range()[1] : d.range().length > 2 && (y = d.range()[d.range().length - 1] + (d.range()[1] - d.range()[0])), v.attr("text-anchor", "middle").attr("y", w).attr("x", y / 2), i && (x = p2.selectAll("g.nv-axisMaxMin").data([d.domain()[0], d.domain()[d.domain().length - 1]]), x.enter().append("g").attr("class", function(a2, b3) {
              return ["nv-axisMaxMin", "nv-axisMaxMin-x", 0 == b3 ? "nv-axisMin-x" : "nv-axisMax-x"].join(" ");
            }).append("text"), x.exit().remove(), x.attr("transform", function(b3, c2) {
              return "translate(" + a.utils.NaNtoZero(d(b3) + (m ? d.rangeBand() / 2 : 0)) + ",0)";
            }).select("text").attr("dy", ".71em").attr("y", c.tickPadding()).attr("transform", C).style("text-anchor", j ? j % 360 > 0 ? "start" : "end" : "middle").text(function(a2, b3) {
              var c2 = u(a2);
              return ("" + c2).match("NaN") ? "" : c2;
            }), x.watchTransition(s, "min-max bottom").attr("transform", function(b3, c2) {
              return "translate(" + a.utils.NaNtoZero(d(b3) + (m ? d.rangeBand() / 2 : 0)) + ",0)";
            })), l && B.attr("transform", function(a2, b3) {
              return "translate(0," + (b3 % 2 == 0 ? "0" : "12") + ")";
            });
            break;
          case "right":
            v.enter().append("text").attr("class", "nv-axislabel"), v.style("text-anchor", k ? "middle" : "begin").attr("transform", k ? "rotate(90)" : "").attr("y", k ? -Math.max(e.right, f) + 12 : -10).attr("x", k ? d3.max(d.range()) / 2 : c.tickPadding()), i && (x = p2.selectAll("g.nv-axisMaxMin").data(d.domain()), x.enter().append("g").attr("class", function(a2, b3) {
              return ["nv-axisMaxMin", "nv-axisMaxMin-y", 0 == b3 ? "nv-axisMin-y" : "nv-axisMax-y"].join(" ");
            }).append("text").style("opacity", 0), x.exit().remove(), x.attr("transform", function(b3, c2) {
              return "translate(0," + a.utils.NaNtoZero(d(b3)) + ")";
            }).select("text").attr("dy", ".32em").attr("y", 0).attr("x", c.tickPadding()).style("text-anchor", "start").text(function(a2, b3) {
              var c2 = u(a2);
              return ("" + c2).match("NaN") ? "" : c2;
            }), x.watchTransition(s, "min-max right").attr("transform", function(b3, c2) {
              return "translate(0," + a.utils.NaNtoZero(d.range()[c2]) + ")";
            }).select("text").style("opacity", 1));
            break;
          case "left":
            v.enter().append("text").attr("class", "nv-axislabel"), v.style("text-anchor", k ? "middle" : "end").attr("transform", k ? "rotate(-90)" : "").attr("y", k ? -Math.max(e.left, f) + 25 - (o || 0) : -10).attr("x", k ? -d3.max(d.range()) / 2 : -c.tickPadding()), i && (x = p2.selectAll("g.nv-axisMaxMin").data(d.domain()), x.enter().append("g").attr("class", function(a2, b3) {
              return ["nv-axisMaxMin", "nv-axisMaxMin-y", 0 == b3 ? "nv-axisMin-y" : "nv-axisMax-y"].join(" ");
            }).append("text").style("opacity", 0), x.exit().remove(), x.attr("transform", function(b3, c2) {
              return "translate(0," + a.utils.NaNtoZero(r(b3)) + ")";
            }).select("text").attr("dy", ".32em").attr("y", 0).attr("x", -c.tickPadding()).attr("text-anchor", "end").text(function(a2, b3) {
              var c2 = u(a2);
              return ("" + c2).match("NaN") ? "" : c2;
            }), x.watchTransition(s, "min-max right").attr("transform", function(b3, c2) {
              return "translate(0," + a.utils.NaNtoZero(d.range()[c2]) + ")";
            }).select("text").style("opacity", 1));
        }
        if (v.text(function(a2) {
          return a2;
        }), !i || "left" !== c.orient() && "right" !== c.orient() || (t.selectAll("g").each(function(a2, b3) {
          d3.select(this).select("text").attr("opacity", 1), (d(a2) < d.range()[1] + 10 || d(a2) > d.range()[0] - 10) && ((a2 > 1e-10 || -1e-10 > a2) && d3.select(this).attr("opacity", 0), d3.select(this).select("text").attr("opacity", 0));
        }), d.domain()[0] == d.domain()[1] && 0 == d.domain()[0] && p2.selectAll("g.nv-axisMaxMin").style("opacity", function(a2, b3) {
          return b3 ? 0 : 1;
        })), i && ("top" === c.orient() || "bottom" === c.orient())) {
          var E = [];
          p2.selectAll("g.nv-axisMaxMin").each(function(a2, b3) {
            try {
              b3 ? E.push(d(a2) - this.getBoundingClientRect().width - 4) : E.push(d(a2) + this.getBoundingClientRect().width + 4);
            } catch (c2) {
              b3 ? E.push(d(a2) - 4) : E.push(d(a2) + 4);
            }
          }), t.selectAll("g").each(function(a2, b3) {
            (d(a2) < E[0] || d(a2) > E[1]) && (a2 > 1e-10 || -1e-10 > a2 ? d3.select(this).remove() : d3.select(this).select("text").remove());
          });
        }
        t.selectAll(".tick").filter(function(a2) {
          return !parseFloat(Math.round(1e5 * a2) / 1e6) && void 0 !== a2;
        }).classed("zero", true), r = d.copy();
      }), s.renderEnd("axis immediate"), b;
    }
    var c = d3.svg.axis(), d = d3.scale.linear(), e = { top: 0, right: 0, bottom: 0, left: 0 }, f = 75, g = 60, h = null, i = true, j = 0, k = true, l = false, m = false, n = null, o = 0, p = 250, q = d3.dispatch("renderEnd");
    c.scale(d).orient("bottom").tickFormat(function(a2) {
      return a2;
    });
    var r, s = a.utils.renderWatch(q, p);
    return b.axis = c, b.dispatch = q, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { axisLabelDistance: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, staggerLabels: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, rotateLabels: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, rotateYLabel: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, showMaxMin: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, axisLabel: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, height: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, ticks: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, width: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, margin: { get: function() {
      return e;
    }, set: function(a2) {
      e.top = void 0 !== a2.top ? a2.top : e.top, e.right = void 0 !== a2.right ? a2.right : e.right, e.bottom = void 0 !== a2.bottom ? a2.bottom : e.bottom, e.left = void 0 !== a2.left ? a2.left : e.left;
    } }, duration: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2, s.reset(p);
    } }, scale: { get: function() {
      return d;
    }, set: function(e2) {
      d = e2, c.scale(d), m = "function" == typeof d.rangeBands, a.utils.inheritOptionsD3(b, d, ["domain", "range", "rangeBand", "rangeBands"]);
    } } }), a.utils.initOptions(b), a.utils.inheritOptionsD3(b, c, ["orient", "tickValues", "tickSubdivide", "tickSize", "tickPadding", "tickFormat"]), a.utils.inheritOptionsD3(b, d, ["domain", "range", "rangeBand", "rangeBands"]), b;
  }, a.models.boxPlot = function() {
    "use strict";
    function b(l2) {
      return v.reset(), l2.each(function(b2) {
        var l3 = j - i.left - i.right, p2 = k - i.top - i.bottom;
        r = d3.select(this), a.utils.initSVG(r), m.domain(c || b2.map(function(a2, b3) {
          return o(a2, b3);
        })).rangeBands(e || [0, l3], 0.1);
        var w = [];
        if (!d) {
          var x = d3.min(b2.map(function(a2) {
            var b3 = [];
            return b3.push(a2.values.Q1), a2.values.hasOwnProperty("whisker_low") && null !== a2.values.whisker_low && b3.push(a2.values.whisker_low), a2.values.hasOwnProperty("outliers") && null !== a2.values.outliers && (b3 = b3.concat(a2.values.outliers)), d3.min(b3);
          })), y = d3.max(b2.map(function(a2) {
            var b3 = [];
            return b3.push(a2.values.Q3), a2.values.hasOwnProperty("whisker_high") && null !== a2.values.whisker_high && b3.push(a2.values.whisker_high), a2.values.hasOwnProperty("outliers") && null !== a2.values.outliers && (b3 = b3.concat(a2.values.outliers)), d3.max(b3);
          }));
          w = [x, y];
        }
        n.domain(d || w), n.range(f || [p2, 0]), g = g || m, h = h || n.copy().range([n(0), n(0)]);
        var z = r.selectAll("g.nv-wrap").data([b2]);
        z.enter().append("g").attr("class", "nvd3 nv-wrap");
        z.attr("transform", "translate(" + i.left + "," + i.top + ")");
        var A = z.selectAll(".nv-boxplot").data(function(a2) {
          return a2;
        }), B = A.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
        A.attr("class", "nv-boxplot").attr("transform", function(a2, b3, c2) {
          return "translate(" + (m(o(a2, b3)) + 0.05 * m.rangeBand()) + ", 0)";
        }).classed("hover", function(a2) {
          return a2.hover;
        }), A.watchTransition(v, "nv-boxplot: boxplots").style("stroke-opacity", 1).style("fill-opacity", 0.75).delay(function(a2, c2) {
          return c2 * t / b2.length;
        }).attr("transform", function(a2, b3) {
          return "translate(" + (m(o(a2, b3)) + 0.05 * m.rangeBand()) + ", 0)";
        }), A.exit().remove(), B.each(function(a2, b3) {
          var c2 = d3.select(this);
          ["low", "high"].forEach(function(d2) {
            a2.values.hasOwnProperty("whisker_" + d2) && null !== a2.values["whisker_" + d2] && (c2.append("line").style("stroke", a2.color ? a2.color : q(a2, b3)).attr("class", "nv-boxplot-whisker nv-boxplot-" + d2), c2.append("line").style("stroke", a2.color ? a2.color : q(a2, b3)).attr("class", "nv-boxplot-tick nv-boxplot-" + d2));
          });
        });
        var C = A.selectAll(".nv-boxplot-outlier").data(function(a2) {
          return a2.values.hasOwnProperty("outliers") && null !== a2.values.outliers ? a2.values.outliers : [];
        });
        C.enter().append("circle").style("fill", function(a2, b3, c2) {
          return q(a2, c2);
        }).style("stroke", function(a2, b3, c2) {
          return q(a2, c2);
        }).on("mouseover", function(a2, b3, c2) {
          d3.select(this).classed("hover", true), s.elementMouseover({ series: { key: a2, color: q(a2, c2) }, e: d3.event });
        }).on("mouseout", function(a2, b3, c2) {
          d3.select(this).classed("hover", false), s.elementMouseout({ series: { key: a2, color: q(a2, c2) }, e: d3.event });
        }).on("mousemove", function(a2, b3) {
          s.elementMousemove({ e: d3.event });
        }), C.attr("class", "nv-boxplot-outlier"), C.watchTransition(v, "nv-boxplot: nv-boxplot-outlier").attr("cx", 0.45 * m.rangeBand()).attr("cy", function(a2, b3, c2) {
          return n(a2);
        }).attr("r", "3"), C.exit().remove();
        var D = function() {
          return null === u ? 0.9 * m.rangeBand() : Math.min(75, 0.9 * m.rangeBand());
        }, E = function() {
          return 0.45 * m.rangeBand() - D() / 2;
        }, F = function() {
          return 0.45 * m.rangeBand() + D() / 2;
        };
        ["low", "high"].forEach(function(a2) {
          var b3 = "low" === a2 ? "Q1" : "Q3";
          A.select("line.nv-boxplot-whisker.nv-boxplot-" + a2).watchTransition(v, "nv-boxplot: boxplots").attr("x1", 0.45 * m.rangeBand()).attr("y1", function(b4, c2) {
            return n(b4.values["whisker_" + a2]);
          }).attr("x2", 0.45 * m.rangeBand()).attr("y2", function(a3, c2) {
            return n(a3.values[b3]);
          }), A.select("line.nv-boxplot-tick.nv-boxplot-" + a2).watchTransition(v, "nv-boxplot: boxplots").attr("x1", E).attr("y1", function(b4, c2) {
            return n(b4.values["whisker_" + a2]);
          }).attr("x2", F).attr("y2", function(b4, c2) {
            return n(b4.values["whisker_" + a2]);
          });
        }), ["low", "high"].forEach(function(a2) {
          B.selectAll(".nv-boxplot-" + a2).on("mouseover", function(b3, c2, d2) {
            d3.select(this).classed("hover", true), s.elementMouseover({ series: { key: b3.values["whisker_" + a2], color: q(b3, d2) }, e: d3.event });
          }).on("mouseout", function(b3, c2, d2) {
            d3.select(this).classed("hover", false), s.elementMouseout({ series: { key: b3.values["whisker_" + a2], color: q(b3, d2) }, e: d3.event });
          }).on("mousemove", function(a3, b3) {
            s.elementMousemove({ e: d3.event });
          });
        }), B.append("rect").attr("class", "nv-boxplot-box").on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), s.elementMouseover({ key: a2.label, value: a2.label, series: [{ key: "Q3", value: a2.values.Q3, color: a2.color || q(a2, b3) }, { key: "Q2", value: a2.values.Q2, color: a2.color || q(a2, b3) }, { key: "Q1", value: a2.values.Q1, color: a2.color || q(a2, b3) }], data: a2, index: b3, e: d3.event });
        }).on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), s.elementMouseout({ key: a2.label, value: a2.label, series: [{ key: "Q3", value: a2.values.Q3, color: a2.color || q(a2, b3) }, { key: "Q2", value: a2.values.Q2, color: a2.color || q(a2, b3) }, { key: "Q1", value: a2.values.Q1, color: a2.color || q(a2, b3) }], data: a2, index: b3, e: d3.event });
        }).on("mousemove", function(a2, b3) {
          s.elementMousemove({ e: d3.event });
        }), A.select("rect.nv-boxplot-box").watchTransition(v, "nv-boxplot: boxes").attr("y", function(a2, b3) {
          return n(a2.values.Q3);
        }).attr("width", D).attr("x", E).attr("height", function(a2, b3) {
          return Math.abs(n(a2.values.Q3) - n(a2.values.Q1)) || 1;
        }).style("fill", function(a2, b3) {
          return a2.color || q(a2, b3);
        }).style("stroke", function(a2, b3) {
          return a2.color || q(a2, b3);
        }), B.append("line").attr("class", "nv-boxplot-median"), A.select("line.nv-boxplot-median").watchTransition(v, "nv-boxplot: boxplots line").attr("x1", E).attr("y1", function(a2, b3) {
          return n(a2.values.Q2);
        }).attr("x2", F).attr("y2", function(a2, b3) {
          return n(a2.values.Q2);
        }), g = m.copy(), h = n.copy();
      }), v.renderEnd("nv-boxplot immediate"), b;
    }
    var c, d, e, f, g, h, i = { top: 0, right: 0, bottom: 0, left: 0 }, j = 960, k = 500, l = Math.floor(1e4 * Math.random()), m = d3.scale.ordinal(), n = d3.scale.linear(), o = function(a2) {
      return a2.x;
    }, p = function(a2) {
      return a2.y;
    }, q = a.utils.defaultColor(), r = null, s = d3.dispatch("elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), t = 250, u = null, v = a.utils.renderWatch(s, t);
    return b.dispatch = s, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, height: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, maxBoxWidth: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, x: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, y: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, xScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, yScale: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, xDomain: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, yDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, xRange: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, yRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, id: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, margin: { get: function() {
      return i;
    }, set: function(a2) {
      i.top = void 0 !== a2.top ? a2.top : i.top, i.right = void 0 !== a2.right ? a2.right : i.right, i.bottom = void 0 !== a2.bottom ? a2.bottom : i.bottom, i.left = void 0 !== a2.left ? a2.left : i.left;
    } }, color: { get: function() {
      return q;
    }, set: function(b2) {
      q = a.utils.getColor(b2);
    } }, duration: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2, v.reset(t);
    } } }), a.utils.initOptions(b), b;
  }, a.models.boxPlotChart = function() {
    "use strict";
    function b(k2) {
      return t.reset(), t.models(e), l && t.models(f), m && t.models(g), k2.each(function(k3) {
        var p2 = d3.select(this);
        a.utils.initSVG(p2);
        var t2 = (i || parseInt(p2.style("width")) || 960) - h.left - h.right, u = (j || parseInt(p2.style("height")) || 400) - h.top - h.bottom;
        if (b.update = function() {
          r.beforeUpdate(), p2.transition().duration(s).call(b);
        }, b.container = this, !(k3 && k3.length && k3.filter(function(a2) {
          return a2.values.hasOwnProperty("Q1") && a2.values.hasOwnProperty("Q2") && a2.values.hasOwnProperty("Q3");
        }).length)) {
          var v = p2.selectAll(".nv-noData").data([q]);
          return v.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle"), v.attr("x", h.left + t2 / 2).attr("y", h.top + u / 2).text(function(a2) {
            return a2;
          }), b;
        }
        p2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale().clamp(true);
        var w = p2.selectAll("g.nv-wrap.nv-boxPlotWithAxes").data([k3]), x = w.enter().append("g").attr("class", "nvd3 nv-wrap nv-boxPlotWithAxes").append("g"), y = x.append("defs"), z = w.select("g");
        x.append("g").attr("class", "nv-x nv-axis"), x.append("g").attr("class", "nv-y nv-axis").append("g").attr("class", "nv-zeroLine").append("line"), x.append("g").attr("class", "nv-barsWrap"), z.attr("transform", "translate(" + h.left + "," + h.top + ")"), n && z.select(".nv-y.nv-axis").attr("transform", "translate(" + t2 + ",0)"), e.width(t2).height(u);
        var A = z.select(".nv-barsWrap").datum(k3.filter(function(a2) {
          return !a2.disabled;
        }));
        if (A.transition().call(e), y.append("clipPath").attr("id", "nv-x-label-clip-" + e.id()).append("rect"), z.select("#nv-x-label-clip-" + e.id() + " rect").attr("width", c.rangeBand() * (o ? 2 : 1)).attr("height", 16).attr("x", -c.rangeBand() / (o ? 1 : 2)), l) {
          f.scale(c).ticks(a.utils.calcTicksX(t2 / 100, k3)).tickSize(-u, 0), z.select(".nv-x.nv-axis").attr("transform", "translate(0," + d.range()[0] + ")"), z.select(".nv-x.nv-axis").call(f);
          var B = z.select(".nv-x.nv-axis").selectAll("g");
          o && B.selectAll("text").attr("transform", function(a2, b2, c2) {
            return "translate(0," + (c2 % 2 == 0 ? "5" : "17") + ")";
          });
        }
        m && (g.scale(d).ticks(Math.floor(u / 36)).tickSize(-t2, 0), z.select(".nv-y.nv-axis").call(g)), z.select(".nv-zeroLine line").attr("x1", 0).attr("x2", t2).attr("y1", d(0)).attr("y2", d(0));
      }), t.renderEnd("nv-boxplot chart immediate"), b;
    }
    var c, d, e = a.models.boxPlot(), f = a.models.axis(), g = a.models.axis(), h = { top: 15, right: 10, bottom: 50, left: 60 }, i = null, j = null, k = a.utils.getColor(), l = true, m = true, n = false, o = false, p = a.models.tooltip(), q = "No Data Available.", r = d3.dispatch("beforeUpdate", "renderEnd"), s = 250;
    f.orient("bottom").showMaxMin(false).tickFormat(function(a2) {
      return a2;
    }), g.orient(n ? "right" : "left").tickFormat(d3.format(",.1f")), p.duration(0);
    var t = a.utils.renderWatch(r, s);
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      p.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      p.data(a2).hidden(true);
    }), e.dispatch.on("elementMousemove.tooltip", function(a2) {
      p();
    }), b.dispatch = r, b.boxplot = e, b.xAxis = f, b.yAxis = g, b.tooltip = p, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, height: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, staggerLabels: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, showXAxis: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, showYAxis: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, tooltipContent: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, noData: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, margin: { get: function() {
      return h;
    }, set: function(a2) {
      h.top = void 0 !== a2.top ? a2.top : h.top, h.right = void 0 !== a2.right ? a2.right : h.right, h.bottom = void 0 !== a2.bottom ? a2.bottom : h.bottom, h.left = void 0 !== a2.left ? a2.left : h.left;
    } }, duration: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2, t.reset(s), e.duration(s), f.duration(s), g.duration(s);
    } }, color: { get: function() {
      return k;
    }, set: function(b2) {
      k = a.utils.getColor(b2), e.color(k);
    } }, rightAlignYAxis: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2, g.orient(a2 ? "right" : "left");
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.bullet = function() {
    "use strict";
    function b(d2) {
      return d2.each(function(b2, d4) {
        var p2 = m - c.left - c.right, s = n - c.top - c.bottom;
        o = d3.select(this), a.utils.initSVG(o);
        var t = f.call(this, b2, d4).slice().sort(d3.descending), u = g.call(this, b2, d4).slice().sort(d3.descending), v = h.call(this, b2, d4).slice().sort(d3.descending), w = i.call(this, b2, d4).slice(), x = j.call(this, b2, d4).slice(), y = k.call(this, b2, d4).slice(), z = d3.scale.linear().domain(d3.extent(d3.merge([l, t]))).range(e ? [p2, 0] : [0, p2]);
        this.__chart__ || d3.scale.linear().domain([0, 1 / 0]).range(z.range());
        this.__chart__ = z;
        var A = d3.min(t), B = d3.max(t), C = t[1], D = o.selectAll("g.nv-wrap.nv-bullet").data([b2]), E = D.enter().append("g").attr("class", "nvd3 nv-wrap nv-bullet"), F = E.append("g"), G = D.select("g");
        F.append("rect").attr("class", "nv-range nv-rangeMax"), F.append("rect").attr("class", "nv-range nv-rangeAvg"), F.append("rect").attr("class", "nv-range nv-rangeMin"), F.append("rect").attr("class", "nv-measure"), D.attr("transform", "translate(" + c.left + "," + c.top + ")");
        var H = function(a2) {
          return Math.abs(z(a2) - z(0));
        }, I = function(a2) {
          return z(0 > a2 ? a2 : 0);
        };
        G.select("rect.nv-rangeMax").attr("height", s).attr("width", H(B > 0 ? B : A)).attr("x", I(B > 0 ? B : A)).datum(B > 0 ? B : A), G.select("rect.nv-rangeAvg").attr("height", s).attr("width", H(C)).attr("x", I(C)).datum(C), G.select("rect.nv-rangeMin").attr("height", s).attr("width", H(B)).attr("x", I(B)).attr("width", H(B > 0 ? A : B)).attr("x", I(B > 0 ? A : B)).datum(B > 0 ? A : B), G.select("rect.nv-measure").style("fill", q).attr("height", s / 3).attr("y", s / 3).attr("width", 0 > v ? z(0) - z(v[0]) : z(v[0]) - z(0)).attr("x", I(v)).on("mouseover", function() {
          r.elementMouseover({ value: v[0], label: y[0] || "Current", color: d3.select(this).style("fill") });
        }).on("mousemove", function() {
          r.elementMousemove({ value: v[0], label: y[0] || "Current", color: d3.select(this).style("fill") });
        }).on("mouseout", function() {
          r.elementMouseout({ value: v[0], label: y[0] || "Current", color: d3.select(this).style("fill") });
        });
        var J = s / 6, K = u.map(function(a2, b3) {
          return { value: a2, label: x[b3] };
        });
        F.selectAll("path.nv-markerTriangle").data(K).enter().append("path").attr("class", "nv-markerTriangle").attr("transform", function(a2) {
          return "translate(" + z(a2.value) + "," + s / 2 + ")";
        }).attr("d", "M0," + J + "L" + J + "," + -J + " " + -J + "," + -J + "Z").on("mouseover", function(a2) {
          r.elementMouseover({ value: a2.value, label: a2.label || "Previous", color: d3.select(this).style("fill"), pos: [z(a2.value), s / 2] });
        }).on("mousemove", function(a2) {
          r.elementMousemove({ value: a2.value, label: a2.label || "Previous", color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          r.elementMouseout({ value: a2.value, label: a2.label || "Previous", color: d3.select(this).style("fill") });
        }), D.selectAll(".nv-range").on("mouseover", function(a2, b3) {
          var c2 = w[b3] || (b3 ? 1 == b3 ? "Mean" : "Minimum" : "Maximum");
          r.elementMouseover({ value: a2, label: c2, color: d3.select(this).style("fill") });
        }).on("mousemove", function() {
          r.elementMousemove({ value: v[0], label: y[0] || "Previous", color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          var c2 = w[b3] || (b3 ? 1 == b3 ? "Mean" : "Minimum" : "Maximum");
          r.elementMouseout({ value: a2, label: c2, color: d3.select(this).style("fill") });
        });
      }), b;
    }
    var c = { top: 0, right: 0, bottom: 0, left: 0 }, d = "left", e = false, f = function(a2) {
      return a2.ranges;
    }, g = function(a2) {
      return a2.markers ? a2.markers : [0];
    }, h = function(a2) {
      return a2.measures;
    }, i = function(a2) {
      return a2.rangeLabels ? a2.rangeLabels : [];
    }, j = function(a2) {
      return a2.markerLabels ? a2.markerLabels : [];
    }, k = function(a2) {
      return a2.measureLabels ? a2.measureLabels : [];
    }, l = [0], m = 380, n = 30, o = null, p = null, q = a.utils.getColor(["#1f77b4"]), r = d3.dispatch("elementMouseover", "elementMouseout", "elementMousemove");
    return b.dispatch = r, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { ranges: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, markers: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, measures: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, forceX: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, width: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, height: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, tickFormat: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, margin: { get: function() {
      return c;
    }, set: function(a2) {
      c.top = void 0 !== a2.top ? a2.top : c.top, c.right = void 0 !== a2.right ? a2.right : c.right, c.bottom = void 0 !== a2.bottom ? a2.bottom : c.bottom, c.left = void 0 !== a2.left ? a2.left : c.left;
    } }, orient: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2, e = "right" == d || "bottom" == d;
    } }, color: { get: function() {
      return q;
    }, set: function(b2) {
      q = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.bulletChart = function() {
    "use strict";
    function b(d2) {
      return d2.each(function(e2, o2) {
        var p2 = d3.select(this);
        a.utils.initSVG(p2);
        var q = a.utils.availableWidth(k, p2, g), r = l - g.top - g.bottom;
        if (b.update = function() {
          b(d2);
        }, b.container = this, !e2 || !h.call(this, e2, o2)) return a.utils.noData(b, p2), b;
        p2.selectAll(".nv-noData").remove();
        var s = h.call(this, e2, o2).slice().sort(d3.descending), t = i.call(this, e2, o2).slice().sort(d3.descending), u = j.call(this, e2, o2).slice().sort(d3.descending), v = p2.selectAll("g.nv-wrap.nv-bulletChart").data([e2]), w = v.enter().append("g").attr("class", "nvd3 nv-wrap nv-bulletChart"), x = w.append("g"), y = v.select("g");
        x.append("g").attr("class", "nv-bulletWrap"), x.append("g").attr("class", "nv-titles"), v.attr("transform", "translate(" + g.left + "," + g.top + ")");
        var z = d3.scale.linear().domain([0, Math.max(s[0], t[0], u[0])]).range(f ? [q, 0] : [0, q]), A = this.__chart__ || d3.scale.linear().domain([0, 1 / 0]).range(z.range());
        this.__chart__ = z;
        var B = x.select(".nv-titles").append("g").attr("text-anchor", "end").attr("transform", "translate(-6," + (l - g.top - g.bottom) / 2 + ")");
        B.append("text").attr("class", "nv-title").text(function(a2) {
          return a2.title;
        }), B.append("text").attr("class", "nv-subtitle").attr("dy", "1em").text(function(a2) {
          return a2.subtitle;
        }), c.width(q).height(r);
        var C = y.select(".nv-bulletWrap");
        d3.transition(C).call(c);
        var D = m || z.tickFormat(q / 100), E = y.selectAll("g.nv-tick").data(z.ticks(n ? n : q / 50), function(a2) {
          return this.textContent || D(a2);
        }), F = E.enter().append("g").attr("class", "nv-tick").attr("transform", function(a2) {
          return "translate(" + A(a2) + ",0)";
        }).style("opacity", 1e-6);
        F.append("line").attr("y1", r).attr("y2", 7 * r / 6), F.append("text").attr("text-anchor", "middle").attr("dy", "1em").attr("y", 7 * r / 6).text(D);
        var G = d3.transition(E).attr("transform", function(a2) {
          return "translate(" + z(a2) + ",0)";
        }).style("opacity", 1);
        G.select("line").attr("y1", r).attr("y2", 7 * r / 6), G.select("text").attr("y", 7 * r / 6), d3.transition(E.exit()).attr("transform", function(a2) {
          return "translate(" + z(a2) + ",0)";
        }).style("opacity", 1e-6).remove();
      }), d3.timer.flush(), b;
    }
    var c = a.models.bullet(), d = a.models.tooltip(), e = "left", f = false, g = { top: 5, right: 40, bottom: 20, left: 120 }, h = function(a2) {
      return a2.ranges;
    }, i = function(a2) {
      return a2.markers ? a2.markers : [0];
    }, j = function(a2) {
      return a2.measures;
    }, k = null, l = 55, m = null, n = null, o = null, p = d3.dispatch();
    return d.duration(0).headerEnabled(false), c.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.series = { key: a2.label, value: a2.value, color: a2.color }, d.data(a2).hidden(false);
    }), c.dispatch.on("elementMouseout.tooltip", function(a2) {
      d.hidden(true);
    }), c.dispatch.on("elementMousemove.tooltip", function(a2) {
      d();
    }), b.bullet = c, b.dispatch = p, b.tooltip = d, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { ranges: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, markers: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, measures: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, width: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, height: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, tickFormat: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, ticks: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, noData: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, margin: { get: function() {
      return g;
    }, set: function(a2) {
      g.top = void 0 !== a2.top ? a2.top : g.top, g.right = void 0 !== a2.right ? a2.right : g.right, g.bottom = void 0 !== a2.bottom ? a2.bottom : g.bottom, g.left = void 0 !== a2.left ? a2.left : g.left;
    } }, orient: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2, f = "right" == e || "bottom" == e;
    } } }), a.utils.inheritOptions(b, c), a.utils.initOptions(b), b;
  }, a.models.candlestickBar = function() {
    "use strict";
    function b(x2) {
      return x2.each(function(b2) {
        c = d3.select(this);
        var x3 = a.utils.availableWidth(i, c, h), y2 = a.utils.availableHeight(j, c, h);
        a.utils.initSVG(c);
        var A = x3 / b2[0].values.length * 0.45;
        l.domain(d || d3.extent(b2[0].values.map(n).concat(t))), v ? l.range(f || [0.5 * x3 / b2[0].values.length, x3 * (b2[0].values.length - 0.5) / b2[0].values.length]) : l.range(f || [5 + A / 2, x3 - A / 2 - 5]), m.domain(e || [d3.min(b2[0].values.map(s).concat(u)), d3.max(b2[0].values.map(r).concat(u))]).range(g || [y2, 0]), l.domain()[0] === l.domain()[1] && (l.domain()[0] ? l.domain([l.domain()[0] - 0.01 * l.domain()[0], l.domain()[1] + 0.01 * l.domain()[1]]) : l.domain([-1, 1])), m.domain()[0] === m.domain()[1] && (m.domain()[0] ? m.domain([m.domain()[0] + 0.01 * m.domain()[0], m.domain()[1] - 0.01 * m.domain()[1]]) : m.domain([-1, 1]));
        var B = d3.select(this).selectAll("g.nv-wrap.nv-candlestickBar").data([b2[0].values]), C = B.enter().append("g").attr("class", "nvd3 nv-wrap nv-candlestickBar"), D = C.append("defs"), E = C.append("g"), F = B.select("g");
        E.append("g").attr("class", "nv-ticks"), B.attr("transform", "translate(" + h.left + "," + h.top + ")"), c.on("click", function(a2, b3) {
          z.chartClick({ data: a2, index: b3, pos: d3.event, id: k });
        }), D.append("clipPath").attr("id", "nv-chart-clip-path-" + k).append("rect"), B.select("#nv-chart-clip-path-" + k + " rect").attr("width", x3).attr("height", y2), F.attr("clip-path", w ? "url(#nv-chart-clip-path-" + k + ")" : "");
        var G = B.select(".nv-ticks").selectAll(".nv-tick").data(function(a2) {
          return a2;
        });
        G.exit().remove();
        var H = G.enter().append("g");
        G.attr("class", function(a2, b3, c2) {
          return (p(a2, b3) > q(a2, b3) ? "nv-tick negative" : "nv-tick positive") + " nv-tick-" + c2 + "-" + b3;
        });
        H.append("line").attr("class", "nv-candlestick-lines").attr("transform", function(a2, b3) {
          return "translate(" + l(n(a2, b3)) + ",0)";
        }).attr("x1", 0).attr("y1", function(a2, b3) {
          return m(r(a2, b3));
        }).attr("x2", 0).attr("y2", function(a2, b3) {
          return m(s(a2, b3));
        }), H.append("rect").attr("class", "nv-candlestick-rects nv-bars").attr("transform", function(a2, b3) {
          return "translate(" + (l(n(a2, b3)) - A / 2) + "," + (m(o(a2, b3)) - (p(a2, b3) > q(a2, b3) ? m(q(a2, b3)) - m(p(a2, b3)) : 0)) + ")";
        }).attr("x", 0).attr("y", 0).attr("width", A).attr("height", function(a2, b3) {
          var c2 = p(a2, b3), d2 = q(a2, b3);
          return c2 > d2 ? m(d2) - m(c2) : m(c2) - m(d2);
        });
        G.select(".nv-candlestick-lines").transition().attr("transform", function(a2, b3) {
          return "translate(" + l(n(a2, b3)) + ",0)";
        }).attr("x1", 0).attr("y1", function(a2, b3) {
          return m(r(a2, b3));
        }).attr("x2", 0).attr("y2", function(a2, b3) {
          return m(s(a2, b3));
        }), G.select(".nv-candlestick-rects").transition().attr("transform", function(a2, b3) {
          return "translate(" + (l(n(a2, b3)) - A / 2) + "," + (m(o(a2, b3)) - (p(a2, b3) > q(a2, b3) ? m(q(a2, b3)) - m(p(a2, b3)) : 0)) + ")";
        }).attr("x", 0).attr("y", 0).attr("width", A).attr("height", function(a2, b3) {
          var c2 = p(a2, b3), d2 = q(a2, b3);
          return c2 > d2 ? m(d2) - m(c2) : m(c2) - m(d2);
        });
      }), b;
    }
    var c, d, e, f, g, h = { top: 0, right: 0, bottom: 0, left: 0 }, i = null, j = null, k = Math.floor(1e4 * Math.random()), l = d3.scale.linear(), m = d3.scale.linear(), n = function(a2) {
      return a2.x;
    }, o = function(a2) {
      return a2.y;
    }, p = function(a2) {
      return a2.open;
    }, q = function(a2) {
      return a2.close;
    }, r = function(a2) {
      return a2.high;
    }, s = function(a2) {
      return a2.low;
    }, t = [], u = [], v = false, w = true, x = a.utils.defaultColor(), y = false, z = d3.dispatch("stateChange", "changeState", "renderEnd", "chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove");
    return b.highlightPoint = function(a2, d2) {
      b.clearHighlights(), c.select(".nv-candlestickBar .nv-tick-0-" + a2).classed("hover", d2);
    }, b.clearHighlights = function() {
      c.select(".nv-candlestickBar .nv-tick.hover").classed("hover", false);
    }, b.dispatch = z, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, height: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, xScale: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, yScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, xDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, yDomain: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, xRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, yRange: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, forceX: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, forceY: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, padData: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, clipEdge: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, id: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, interactive: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, x: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, y: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, open: { get: function() {
      return p();
    }, set: function(a2) {
      p = a2;
    } }, close: { get: function() {
      return q();
    }, set: function(a2) {
      q = a2;
    } }, high: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, low: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, margin: { get: function() {
      return h;
    }, set: function(a2) {
      h.top = void 0 != a2.top ? a2.top : h.top, h.right = void 0 != a2.right ? a2.right : h.right, h.bottom = void 0 != a2.bottom ? a2.bottom : h.bottom, h.left = void 0 != a2.left ? a2.left : h.left;
    } }, color: { get: function() {
      return x;
    }, set: function(b2) {
      x = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.cumulativeLineChart = function() {
    "use strict";
    function b(l2) {
      return H.reset(), H.models(f), r && H.models(g), s && H.models(h), l2.each(function(l3) {
        function A2(a2, c2) {
          d3.select(b.container).style("cursor", "ew-resize");
        }
        function E2(a2, b2) {
          G.x = d3.event.x, G.i = Math.round(F.invert(G.x)), K2();
        }
        function H2(a2, c2) {
          d3.select(b.container).style("cursor", "auto"), y.index = G.i, C.stateChange(y);
        }
        function K2() {
          ba.data([G]);
          var a2 = b.duration();
          b.duration(0), b.update(), b.duration(a2);
        }
        var L = d3.select(this);
        a.utils.initSVG(L), L.classed("nv-chart-" + x, true);
        var M = this, N = a.utils.availableWidth(o, L, m), O = a.utils.availableHeight(p, L, m);
        if (b.update = function() {
          0 === D ? L.call(b) : L.transition().duration(D).call(b);
        }, b.container = this, y.setter(J(l3), b.update).getter(I(l3)).update(), y.disabled = l3.map(function(a2) {
          return !!a2.disabled;
        }), !z) {
          var P;
          z = {};
          for (P in y) y[P] instanceof Array ? z[P] = y[P].slice(0) : z[P] = y[P];
        }
        var Q = d3.behavior.drag().on("dragstart", A2).on("drag", E2).on("dragend", H2);
        if (!(l3 && l3.length && l3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, L), b;
        if (L.selectAll(".nv-noData").remove(), d = f.xScale(), e = f.yScale(), w) f.yDomain(null);
        else {
          var R = l3.filter(function(a2) {
            return !a2.disabled;
          }).map(function(a2, b2) {
            var c2 = d3.extent(a2.values, f.y());
            return c2[0] < -0.95 && (c2[0] = -0.95), [(c2[0] - c2[1]) / (1 + c2[1]), (c2[1] - c2[0]) / (1 + c2[0])];
          }), S = [d3.min(R, function(a2) {
            return a2[0];
          }), d3.max(R, function(a2) {
            return a2[1];
          })];
          f.yDomain(S);
        }
        F.domain([0, l3[0].values.length - 1]).range([0, N]).clamp(true);
        var l3 = c(G.i, l3), T = v ? "none" : "all", U = L.selectAll("g.nv-wrap.nv-cumulativeLine").data([l3]), V = U.enter().append("g").attr("class", "nvd3 nv-wrap nv-cumulativeLine").append("g"), W = U.select("g");
        if (V.append("g").attr("class", "nv-interactive"), V.append("g").attr("class", "nv-x nv-axis").style("pointer-events", "none"), V.append("g").attr("class", "nv-y nv-axis"), V.append("g").attr("class", "nv-background"), V.append("g").attr("class", "nv-linesWrap").style("pointer-events", T), V.append("g").attr("class", "nv-avgLinesWrap").style("pointer-events", "none"), V.append("g").attr("class", "nv-legendWrap"), V.append("g").attr("class", "nv-controlsWrap"), q && (i.width(N), W.select(".nv-legendWrap").datum(l3).call(i), m.top != i.height() && (m.top = i.height(), O = a.utils.availableHeight(p, L, m)), W.select(".nv-legendWrap").attr("transform", "translate(0," + -m.top + ")")), u) {
          var X = [{ key: "Re-scale y-axis", disabled: !w }];
          j.width(140).color(["#444", "#444", "#444"]).rightAlign(false).margin({ top: 5, right: 0, bottom: 5, left: 20 }), W.select(".nv-controlsWrap").datum(X).attr("transform", "translate(0," + -m.top + ")").call(j);
        }
        U.attr("transform", "translate(" + m.left + "," + m.top + ")"), t && W.select(".nv-y.nv-axis").attr("transform", "translate(" + N + ",0)");
        var Y = l3.filter(function(a2) {
          return a2.tempDisabled;
        });
        U.select(".tempDisabled").remove(), Y.length && U.append("text").attr("class", "tempDisabled").attr("x", N / 2).attr("y", "-.71em").style("text-anchor", "end").text(Y.map(function(a2) {
          return a2.key;
        }).join(", ") + " values cannot be calculated for this time period."), v && (k.width(N).height(O).margin({ left: m.left, top: m.top }).svgContainer(L).xScale(d), U.select(".nv-interactive").call(k)), V.select(".nv-background").append("rect"), W.select(".nv-background rect").attr("width", N).attr("height", O), f.y(function(a2) {
          return a2.display.y;
        }).width(N).height(O).color(l3.map(function(a2, b2) {
          return a2.color || n(a2, b2);
        }).filter(function(a2, b2) {
          return !l3[b2].disabled && !l3[b2].tempDisabled;
        }));
        var Z = W.select(".nv-linesWrap").datum(l3.filter(function(a2) {
          return !a2.disabled && !a2.tempDisabled;
        }));
        Z.call(f), l3.forEach(function(a2, b2) {
          a2.seriesIndex = b2;
        });
        var $ = l3.filter(function(a2) {
          return !a2.disabled && !!B(a2);
        }), _5 = W.select(".nv-avgLinesWrap").selectAll("line").data($, function(a2) {
          return a2.key;
        }), aa = function(a2) {
          var b2 = e(B(a2));
          return 0 > b2 ? 0 : b2 > O ? O : b2;
        };
        _5.enter().append("line").style("stroke-width", 2).style("stroke-dasharray", "10,10").style("stroke", function(a2, b2) {
          return f.color()(a2, a2.seriesIndex);
        }).attr("x1", 0).attr("x2", N).attr("y1", aa).attr("y2", aa), _5.style("stroke-opacity", function(a2) {
          var b2 = e(B(a2));
          return 0 > b2 || b2 > O ? 0 : 1;
        }).attr("x1", 0).attr("x2", N).attr("y1", aa).attr("y2", aa), _5.exit().remove();
        var ba = Z.selectAll(".nv-indexLine").data([G]);
        ba.enter().append("rect").attr("class", "nv-indexLine").attr("width", 3).attr("x", -2).attr("fill", "red").attr("fill-opacity", 0.5).style("pointer-events", "all").call(Q), ba.attr("transform", function(a2) {
          return "translate(" + F(a2.i) + ",0)";
        }).attr("height", O), r && (g.scale(d)._ticks(a.utils.calcTicksX(N / 70, l3)).tickSize(-O, 0), W.select(".nv-x.nv-axis").attr("transform", "translate(0," + e.range()[0] + ")"), W.select(".nv-x.nv-axis").call(g)), s && (h.scale(e)._ticks(a.utils.calcTicksY(O / 36, l3)).tickSize(-N, 0), W.select(".nv-y.nv-axis").call(h)), W.select(".nv-background rect").on("click", function() {
          G.x = d3.mouse(this)[0], G.i = Math.round(F.invert(G.x)), y.index = G.i, C.stateChange(y), K2();
        }), f.dispatch.on("elementClick", function(a2) {
          G.i = a2.pointIndex, G.x = F(G.i), y.index = G.i, C.stateChange(y), K2();
        }), j.dispatch.on("legendClick", function(a2, c2) {
          a2.disabled = !a2.disabled, w = !a2.disabled, y.rescaleY = w, C.stateChange(y), b.update();
        }), i.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) y[c2] = a2[c2];
          C.stateChange(y), b.update();
        }), k.dispatch.on("elementMousemove", function(c2) {
          f.clearHighlights();
          var d2, e2, i2, j2 = [];
          if (l3.filter(function(a2, b2) {
            return a2.seriesIndex = b2, !a2.disabled;
          }).forEach(function(g2, h2) {
            e2 = a.interactiveBisect(g2.values, c2.pointXValue, b.x()), f.highlightPoint(h2, e2, true);
            var k2 = g2.values[e2];
            "undefined" != typeof k2 && ("undefined" == typeof d2 && (d2 = k2), "undefined" == typeof i2 && (i2 = b.xScale()(b.x()(k2, e2))), j2.push({ key: g2.key, value: b.y()(k2, e2), color: n(g2, g2.seriesIndex) }));
          }), j2.length > 2) {
            var m2 = b.yScale().invert(c2.mouseY), o2 = Math.abs(b.yScale().domain()[0] - b.yScale().domain()[1]), p2 = 0.03 * o2, q2 = a.nearestValueIndex(j2.map(function(a2) {
              return a2.value;
            }), m2, p2);
            null !== q2 && (j2[q2].highlight = true);
          }
          var r2 = g.tickFormat()(b.x()(d2, e2), e2);
          k.tooltip.chartContainer(M.parentNode).valueFormatter(function(a2, b2) {
            return h.tickFormat()(a2);
          }).data({ value: r2, series: j2 })(), k.renderGuideLine(i2);
        }), k.dispatch.on("elementMouseout", function(a2) {
          f.clearHighlights();
        }), C.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (l3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), y.disabled = a2.disabled), "undefined" != typeof a2.index && (G.i = a2.index, G.x = F(G.i), y.index = a2.index, ba.data([G])), "undefined" != typeof a2.rescaleY && (w = a2.rescaleY), b.update();
        });
      }), H.renderEnd("cumulativeLineChart immediate"), b;
    }
    function c(a2, b2) {
      return K || (K = f.y()), b2.map(function(b3, c2) {
        if (!b3.values) return b3;
        var d2 = b3.values[a2];
        if (null == d2) return b3;
        var e2 = K(d2, a2);
        return -0.95 > e2 && !E ? (b3.tempDisabled = true, b3) : (b3.tempDisabled = false, b3.values = b3.values.map(function(a3, b4) {
          return a3.display = { y: (K(a3, b4) - e2) / (1 + e2) }, a3;
        }), b3);
      });
    }
    var d, e, f = a.models.line(), g = a.models.axis(), h = a.models.axis(), i = a.models.legend(), j = a.models.legend(), k = a.interactiveGuideline(), l = a.models.tooltip(), m = { top: 30, right: 30, bottom: 50, left: 60 }, n = a.utils.defaultColor(), o = null, p = null, q = true, r = true, s = true, t = false, u = true, v = false, w = true, x = f.id(), y = a.utils.state(), z = null, A = null, B = function(a2) {
      return a2.average;
    }, C = d3.dispatch("stateChange", "changeState", "renderEnd"), D = 250, E = false;
    y.index = 0, y.rescaleY = w, g.orient("bottom").tickPadding(7), h.orient(t ? "right" : "left"), l.valueFormatter(function(a2, b2) {
      return h.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }), j.updateState(false);
    var F = d3.scale.linear(), G = { i: 0, x: 0 }, H = a.utils.renderWatch(C, D), I = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }), index: G.i, rescaleY: w };
      };
    }, J = function(a2) {
      return function(b2) {
        void 0 !== b2.index && (G.i = b2.index), void 0 !== b2.rescaleY && (w = b2.rescaleY), void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    f.dispatch.on("elementMouseover.tooltip", function(a2) {
      var c2 = { x: b.x()(a2.point), y: b.y()(a2.point), color: a2.point.color };
      a2.point = c2, l.data(a2).hidden(false);
    }), f.dispatch.on("elementMouseout.tooltip", function(a2) {
      l.hidden(true);
    });
    var K = null;
    return b.dispatch = C, b.lines = f, b.legend = i, b.controls = j, b.xAxis = g, b.yAxis = h, b.interactiveLayer = k, b.state = y, b.tooltip = l, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, height: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, rescaleY: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, showControls: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, showLegend: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, average: { get: function() {
      return B;
    }, set: function(a2) {
      B = a2;
    } }, defaultState: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, noData: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, showXAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showYAxis: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, noErrorCheck: { get: function() {
      return E;
    }, set: function(a2) {
      E = a2;
    } }, margin: { get: function() {
      return m;
    }, set: function(a2) {
      m.top = void 0 !== a2.top ? a2.top : m.top, m.right = void 0 !== a2.right ? a2.right : m.right, m.bottom = void 0 !== a2.bottom ? a2.bottom : m.bottom, m.left = void 0 !== a2.left ? a2.left : m.left;
    } }, color: { get: function() {
      return n;
    }, set: function(b2) {
      n = a.utils.getColor(b2), i.color(n);
    } }, useInteractiveGuideline: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2, a2 === true && (b.interactive(false), b.useVoronoi(false));
    } }, rightAlignYAxis: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2, h.orient(a2 ? "right" : "left");
    } }, duration: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2, f.duration(D), g.duration(D), h.duration(D), H.reset(D);
    } } }), a.utils.inheritOptions(b, f), a.utils.initOptions(b), b;
  }, a.models.discreteBar = function() {
    "use strict";
    function b(m2) {
      return y.reset(), m2.each(function(b2) {
        var m3 = k - j.left - j.right, x2 = l - j.top - j.bottom;
        c = d3.select(this), a.utils.initSVG(c), b2.forEach(function(a2, b3) {
          a2.values.forEach(function(a3) {
            a3.series = b3;
          });
        });
        var z = d && e ? [] : b2.map(function(a2) {
          return a2.values.map(function(a3, b3) {
            return { x: p(a3, b3), y: q(a3, b3), y0: a3.y0 };
          });
        });
        n.domain(d || d3.merge(z).map(function(a2) {
          return a2.x;
        })).rangeBands(f || [0, m3], 0.1), o.domain(e || d3.extent(d3.merge(z).map(function(a2) {
          return a2.y;
        }).concat(r))), t ? o.range(g || [x2 - (o.domain()[0] < 0 ? 12 : 0), o.domain()[1] > 0 ? 12 : 0]) : o.range(g || [x2, 0]), h = h || n, i = i || o.copy().range([o(0), o(0)]);
        var A = c.selectAll("g.nv-wrap.nv-discretebar").data([b2]), B = A.enter().append("g").attr("class", "nvd3 nv-wrap nv-discretebar"), C = B.append("g");
        A.select("g");
        C.append("g").attr("class", "nv-groups"), A.attr("transform", "translate(" + j.left + "," + j.top + ")");
        var D = A.select(".nv-groups").selectAll(".nv-group").data(function(a2) {
          return a2;
        }, function(a2) {
          return a2.key;
        });
        D.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6), D.exit().watchTransition(y, "discreteBar: exit groups").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove(), D.attr("class", function(a2, b3) {
          return "nv-group nv-series-" + b3;
        }).classed("hover", function(a2) {
          return a2.hover;
        }), D.watchTransition(y, "discreteBar: groups").style("stroke-opacity", 1).style("fill-opacity", 0.75);
        var E = D.selectAll("g.nv-bar").data(function(a2) {
          return a2.values;
        });
        E.exit().remove();
        var F = E.enter().append("g").attr("transform", function(a2, b3, c2) {
          return "translate(" + (n(p(a2, b3)) + 0.05 * n.rangeBand()) + ", " + o(0) + ")";
        }).on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), v.elementMouseover({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), v.elementMouseout({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mousemove", function(a2, b3) {
          v.elementMousemove({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("click", function(a2, b3) {
          v.elementClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        }).on("dblclick", function(a2, b3) {
          v.elementDblClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        });
        F.append("rect").attr("height", 0).attr("width", 0.9 * n.rangeBand() / b2.length), t ? (F.append("text").attr("text-anchor", "middle"), E.select("text").text(function(a2, b3) {
          return u(q(a2, b3));
        }).watchTransition(y, "discreteBar: bars text").attr("x", 0.9 * n.rangeBand() / 2).attr("y", function(a2, b3) {
          return q(a2, b3) < 0 ? o(q(a2, b3)) - o(0) + 12 : -4;
        })) : E.selectAll("text").remove(), E.attr("class", function(a2, b3) {
          return q(a2, b3) < 0 ? "nv-bar negative" : "nv-bar positive";
        }).style("fill", function(a2, b3) {
          return a2.color || s(a2, b3);
        }).style("stroke", function(a2, b3) {
          return a2.color || s(a2, b3);
        }).select("rect").attr("class", w).watchTransition(y, "discreteBar: bars rect").attr("width", 0.9 * n.rangeBand() / b2.length), E.watchTransition(y, "discreteBar: bars").attr("transform", function(a2, b3) {
          var c2 = n(p(a2, b3)) + 0.05 * n.rangeBand(), d2 = q(a2, b3) < 0 ? o(0) : o(0) - o(q(a2, b3)) < 1 ? o(0) - 1 : o(q(a2, b3));
          return "translate(" + c2 + ", " + d2 + ")";
        }).select("rect").attr("height", function(a2, b3) {
          return Math.max(Math.abs(o(q(a2, b3)) - o(e && e[0] || 0)) || 1);
        }), h = n.copy(), i = o.copy();
      }), y.renderEnd("discreteBar immediate"), b;
    }
    var c, d, e, f, g, h, i, j = { top: 0, right: 0, bottom: 0, left: 0 }, k = 960, l = 500, m = Math.floor(1e4 * Math.random()), n = d3.scale.ordinal(), o = d3.scale.linear(), p = function(a2) {
      return a2.x;
    }, q = function(a2) {
      return a2.y;
    }, r = [0], s = a.utils.defaultColor(), t = false, u = d3.format(",.2f"), v = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), w = "discreteBar", x = 250, y = a.utils.renderWatch(v, x);
    return b.dispatch = v, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, height: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, forceY: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showValues: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, x: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, y: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, xScale: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, yScale: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, xDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, yDomain: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, xRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, yRange: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, valueFormat: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, id: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, rectClass: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, margin: { get: function() {
      return j;
    }, set: function(a2) {
      j.top = void 0 !== a2.top ? a2.top : j.top, j.right = void 0 !== a2.right ? a2.right : j.right, j.bottom = void 0 !== a2.bottom ? a2.bottom : j.bottom, j.left = void 0 !== a2.left ? a2.left : j.left;
    } }, color: { get: function() {
      return s;
    }, set: function(b2) {
      s = a.utils.getColor(b2);
    } }, duration: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2, y.reset(x);
    } } }), a.utils.initOptions(b), b;
  }, a.models.discreteBarChart = function() {
    "use strict";
    function b(h2) {
      return v.reset(), v.models(e), m && v.models(f), n && v.models(g), h2.each(function(h3) {
        var l2 = d3.select(this);
        a.utils.initSVG(l2);
        var s2 = a.utils.availableWidth(j, l2, i), v2 = a.utils.availableHeight(k, l2, i);
        if (b.update = function() {
          t.beforeUpdate(), l2.transition().duration(u).call(b);
        }, b.container = this, !(h3 && h3.length && h3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, l2), b;
        l2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale().clamp(true);
        var w = l2.selectAll("g.nv-wrap.nv-discreteBarWithAxes").data([h3]), x = w.enter().append("g").attr("class", "nvd3 nv-wrap nv-discreteBarWithAxes").append("g"), y = x.append("defs"), z = w.select("g");
        x.append("g").attr("class", "nv-x nv-axis"), x.append("g").attr("class", "nv-y nv-axis").append("g").attr("class", "nv-zeroLine").append("line"), x.append("g").attr("class", "nv-barsWrap"), z.attr("transform", "translate(" + i.left + "," + i.top + ")"), o && z.select(".nv-y.nv-axis").attr("transform", "translate(" + s2 + ",0)"), e.width(s2).height(v2);
        var A = z.select(".nv-barsWrap").datum(h3.filter(function(a2) {
          return !a2.disabled;
        }));
        if (A.transition().call(e), y.append("clipPath").attr("id", "nv-x-label-clip-" + e.id()).append("rect"), z.select("#nv-x-label-clip-" + e.id() + " rect").attr("width", c.rangeBand() * (p ? 2 : 1)).attr("height", 16).attr("x", -c.rangeBand() / (p ? 1 : 2)), m) {
          f.scale(c)._ticks(a.utils.calcTicksX(s2 / 100, h3)).tickSize(-v2, 0), z.select(".nv-x.nv-axis").attr("transform", "translate(0," + (d.range()[0] + (e.showValues() && d.domain()[0] < 0 ? 16 : 0)) + ")"), z.select(".nv-x.nv-axis").call(f);
          var B = z.select(".nv-x.nv-axis").selectAll("g");
          p && B.selectAll("text").attr("transform", function(a2, b2, c2) {
            return "translate(0," + (c2 % 2 == 0 ? "5" : "17") + ")";
          }), r && B.selectAll(".tick text").attr("transform", "rotate(" + r + " 0,0)").style("text-anchor", r > 0 ? "start" : "end"), q && z.selectAll(".tick text").call(a.utils.wrapTicks, b.xAxis.rangeBand());
        }
        n && (g.scale(d)._ticks(a.utils.calcTicksY(v2 / 36, h3)).tickSize(-s2, 0), z.select(".nv-y.nv-axis").call(g)), z.select(".nv-zeroLine line").attr("x1", 0).attr("x2", s2).attr("y1", d(0)).attr("y2", d(0));
      }), v.renderEnd("discreteBar chart immediate"), b;
    }
    var c, d, e = a.models.discreteBar(), f = a.models.axis(), g = a.models.axis(), h = a.models.tooltip(), i = { top: 15, right: 10, bottom: 50, left: 60 }, j = null, k = null, l = a.utils.getColor(), m = true, n = true, o = false, p = false, q = false, r = 0, s = null, t = d3.dispatch("beforeUpdate", "renderEnd"), u = 250;
    f.orient("bottom").showMaxMin(false).tickFormat(function(a2) {
      return a2;
    }), g.orient(o ? "right" : "left").tickFormat(d3.format(",.1f")), h.duration(0).headerEnabled(false).valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }).keyFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    });
    var v = a.utils.renderWatch(t, u);
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.series = { key: b.x()(a2.data), value: b.y()(a2.data), color: a2.color }, h.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      h.hidden(true);
    }), e.dispatch.on("elementMousemove.tooltip", function(a2) {
      h();
    }), b.dispatch = t, b.discretebar = e, b.xAxis = f, b.yAxis = g, b.tooltip = h, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, height: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, staggerLabels: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, rotateLabels: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, wrapLabels: { get: function() {
      return q;
    }, set: function(a2) {
      q = !!a2;
    } }, showXAxis: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, showYAxis: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, noData: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, margin: { get: function() {
      return i;
    }, set: function(a2) {
      i.top = void 0 !== a2.top ? a2.top : i.top, i.right = void 0 !== a2.right ? a2.right : i.right, i.bottom = void 0 !== a2.bottom ? a2.bottom : i.bottom, i.left = void 0 !== a2.left ? a2.left : i.left;
    } }, duration: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2, v.reset(u), e.duration(u), f.duration(u), g.duration(u);
    } }, color: { get: function() {
      return l;
    }, set: function(b2) {
      l = a.utils.getColor(b2), e.color(l);
    } }, rightAlignYAxis: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2, g.orient(a2 ? "right" : "left");
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.distribution = function() {
    "use strict";
    function b(k2) {
      return m.reset(), k2.each(function(b2) {
        var k3 = (e - ("x" === g ? d.left + d.right : d.top + d.bottom), "x" == g ? "y" : "x"), l2 = d3.select(this);
        a.utils.initSVG(l2), c = c || j;
        var n = l2.selectAll("g.nv-distribution").data([b2]), o = n.enter().append("g").attr("class", "nvd3 nv-distribution"), p = (o.append("g"), n.select("g"));
        n.attr("transform", "translate(" + d.left + "," + d.top + ")");
        var q = p.selectAll("g.nv-dist").data(function(a2) {
          return a2;
        }, function(a2) {
          return a2.key;
        });
        q.enter().append("g"), q.attr("class", function(a2, b3) {
          return "nv-dist nv-series-" + b3;
        }).style("stroke", function(a2, b3) {
          return i(a2, b3);
        });
        var r = q.selectAll("line.nv-dist" + g).data(function(a2) {
          return a2.values;
        });
        r.enter().append("line").attr(g + "1", function(a2, b3) {
          return c(h(a2, b3));
        }).attr(g + "2", function(a2, b3) {
          return c(h(a2, b3));
        }), m.transition(q.exit().selectAll("line.nv-dist" + g), "dist exit").attr(g + "1", function(a2, b3) {
          return j(h(a2, b3));
        }).attr(g + "2", function(a2, b3) {
          return j(h(a2, b3));
        }).style("stroke-opacity", 0).remove(), r.attr("class", function(a2, b3) {
          return "nv-dist" + g + " nv-dist" + g + "-" + b3;
        }).attr(k3 + "1", 0).attr(k3 + "2", f), m.transition(r, "dist").attr(g + "1", function(a2, b3) {
          return j(h(a2, b3));
        }).attr(g + "2", function(a2, b3) {
          return j(h(a2, b3));
        }), c = j.copy();
      }), m.renderEnd("distribution immediate"), b;
    }
    var c, d = { top: 0, right: 0, bottom: 0, left: 0 }, e = 400, f = 8, g = "x", h = function(a2) {
      return a2[g];
    }, i = a.utils.defaultColor(), j = d3.scale.linear(), k = 250, l = d3.dispatch("renderEnd"), m = a.utils.renderWatch(l, k);
    return b.options = a.utils.optionsFunc.bind(b), b.dispatch = l, b.margin = function(a2) {
      return arguments.length ? (d.top = "undefined" != typeof a2.top ? a2.top : d.top, d.right = "undefined" != typeof a2.right ? a2.right : d.right, d.bottom = "undefined" != typeof a2.bottom ? a2.bottom : d.bottom, d.left = "undefined" != typeof a2.left ? a2.left : d.left, b) : d;
    }, b.width = function(a2) {
      return arguments.length ? (e = a2, b) : e;
    }, b.axis = function(a2) {
      return arguments.length ? (g = a2, b) : g;
    }, b.size = function(a2) {
      return arguments.length ? (f = a2, b) : f;
    }, b.getData = function(a2) {
      return arguments.length ? (h = d3.functor(a2), b) : h;
    }, b.scale = function(a2) {
      return arguments.length ? (j = a2, b) : j;
    }, b.color = function(c2) {
      return arguments.length ? (i = a.utils.getColor(c2), b) : i;
    }, b.duration = function(a2) {
      return arguments.length ? (k = a2, m.reset(k), b) : k;
    }, b;
  }, a.models.furiousLegend = function() {
    "use strict";
    function b(q) {
      function r(a2, b2) {
        return "furious" != p ? "#000" : n ? a2.disengaged ? g(a2, b2) : "#fff" : n ? void 0 : a2.disabled ? g(a2, b2) : "#fff";
      }
      function s(a2, b2) {
        return n && "furious" == p ? a2.disengaged ? "#fff" : g(a2, b2) : a2.disabled ? "#fff" : g(a2, b2);
      }
      return q.each(function(b2) {
        var q2 = d - c.left - c.right, t = d3.select(this);
        a.utils.initSVG(t);
        var u = t.selectAll("g.nv-legend").data([b2]), v = (u.enter().append("g").attr("class", "nvd3 nv-legend").append("g"), u.select("g"));
        u.attr("transform", "translate(" + c.left + "," + c.top + ")");
        var w, x = v.selectAll(".nv-series").data(function(a2) {
          return "furious" != p ? a2 : a2.filter(function(a3) {
            return n ? true : !a3.disengaged;
          });
        }), y = x.enter().append("g").attr("class", "nv-series");
        if ("classic" == p) y.append("circle").style("stroke-width", 2).attr("class", "nv-legend-symbol").attr("r", 5), w = x.select("circle");
        else if ("furious" == p) {
          y.append("rect").style("stroke-width", 2).attr("class", "nv-legend-symbol").attr("rx", 3).attr("ry", 3), w = x.select("rect"), y.append("g").attr("class", "nv-check-box").property("innerHTML", '<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr("transform", "translate(-10,-8)scale(0.5)");
          var z = x.select(".nv-check-box");
          z.each(function(a2, b3) {
            d3.select(this).selectAll("path").attr("stroke", r(a2, b3));
          });
        }
        y.append("text").attr("text-anchor", "start").attr("class", "nv-legend-text").attr("dy", ".32em").attr("dx", "8");
        var A = x.select("text.nv-legend-text");
        x.on("mouseover", function(a2, b3) {
          o.legendMouseover(a2, b3);
        }).on("mouseout", function(a2, b3) {
          o.legendMouseout(a2, b3);
        }).on("click", function(a2, b3) {
          o.legendClick(a2, b3);
          var c2 = x.data();
          if (l) {
            if ("classic" == p) m ? (c2.forEach(function(a3) {
              a3.disabled = true;
            }), a2.disabled = false) : (a2.disabled = !a2.disabled, c2.every(function(a3) {
              return a3.disabled;
            }) && c2.forEach(function(a3) {
              a3.disabled = false;
            }));
            else if ("furious" == p) {
              if (n) a2.disengaged = !a2.disengaged, a2.userDisabled = void 0 == a2.userDisabled ? !!a2.disabled : a2.userDisabled, a2.disabled = a2.disengaged || a2.userDisabled;
              else if (!n) {
                a2.disabled = !a2.disabled, a2.userDisabled = a2.disabled;
                var d2 = c2.filter(function(a3) {
                  return !a3.disengaged;
                });
                d2.every(function(a3) {
                  return a3.userDisabled;
                }) && c2.forEach(function(a3) {
                  a3.disabled = a3.userDisabled = false;
                });
              }
            }
            o.stateChange({ disabled: c2.map(function(a3) {
              return !!a3.disabled;
            }), disengaged: c2.map(function(a3) {
              return !!a3.disengaged;
            }) });
          }
        }).on("dblclick", function(a2, b3) {
          if (("furious" != p || !n) && (o.legendDblclick(a2, b3), l)) {
            var c2 = x.data();
            c2.forEach(function(a3) {
              a3.disabled = true, "furious" == p && (a3.userDisabled = a3.disabled);
            }), a2.disabled = false, "furious" == p && (a2.userDisabled = a2.disabled), o.stateChange({ disabled: c2.map(function(a3) {
              return !!a3.disabled;
            }) });
          }
        }), x.classed("nv-disabled", function(a2) {
          return a2.userDisabled;
        }), x.exit().remove(), A.attr("fill", r).text(f);
        var B;
        switch (p) {
          case "furious":
            B = 23;
            break;
          case "classic":
            B = 20;
        }
        if (i) {
          var C = [];
          x.each(function(b3, c2) {
            var d2;
            if (f(b3).length > h) {
              var e2 = f(b3).substring(0, h);
              d2 = d3.select(this).select("text").text(e2 + "..."), d3.select(this).append("svg:title").text(f(b3));
            } else d2 = d3.select(this).select("text");
            var g2;
            try {
              if (g2 = d2.node().getComputedTextLength(), 0 >= g2) throw Error();
            } catch (i2) {
              g2 = a.utils.calcApproxTextWidth(d2);
            }
            C.push(g2 + j);
          });
          for (var D = 0, E = 0, F = []; q2 > E && D < C.length; ) F[D] = C[D], E += C[D++];
          for (0 === D && (D = 1); E > q2 && D > 1; ) {
            F = [], D--;
            for (var G = 0; G < C.length; G++) C[G] > (F[G % D] || 0) && (F[G % D] = C[G]);
            E = F.reduce(function(a2, b3, c2, d2) {
              return a2 + b3;
            });
          }
          for (var H = [], I = 0, J = 0; D > I; I++) H[I] = J, J += F[I];
          x.attr("transform", function(a2, b3) {
            return "translate(" + H[b3 % D] + "," + (5 + Math.floor(b3 / D) * B) + ")";
          }), k ? v.attr("transform", "translate(" + (d - c.right - E) + "," + c.top + ")") : v.attr("transform", "translate(0," + c.top + ")"), e = c.top + c.bottom + Math.ceil(C.length / D) * B;
        } else {
          var K, L = 5, M = 5, N = 0;
          x.attr("transform", function(a2, b3) {
            var e2 = d3.select(this).select("text").node().getComputedTextLength() + j;
            return K = M, d < c.left + c.right + K + e2 && (M = K = 5, L += B), M += e2, M > N && (N = M), "translate(" + K + "," + L + ")";
          }), v.attr("transform", "translate(" + (d - c.right - N) + "," + c.top + ")"), e = c.top + c.bottom + L + 15;
        }
        "furious" == p && w.attr("width", function(a2, b3) {
          return A[0][b3].getComputedTextLength() + 27;
        }).attr("height", 18).attr("y", -9).attr("x", -15), w.style("fill", s).style("stroke", function(a2, b3) {
          return a2.color || g(a2, b3);
        });
      }), b;
    }
    var c = { top: 5, right: 0, bottom: 5, left: 0 }, d = 400, e = 20, f = function(a2) {
      return a2.key;
    }, g = a.utils.getColor(), h = 20, i = true, j = 28, k = true, l = true, m = false, n = false, o = d3.dispatch("legendClick", "legendDblclick", "legendMouseover", "legendMouseout", "stateChange"), p = "classic";
    return b.dispatch = o, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, height: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, key: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, align: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, rightAlign: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, maxKeyLength: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, padding: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, updateState: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, radioButtonMode: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, expanded: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, vers: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, margin: { get: function() {
      return c;
    }, set: function(a2) {
      c.top = void 0 !== a2.top ? a2.top : c.top, c.right = void 0 !== a2.right ? a2.right : c.right, c.bottom = void 0 !== a2.bottom ? a2.bottom : c.bottom, c.left = void 0 !== a2.left ? a2.left : c.left;
    } }, color: { get: function() {
      return g;
    }, set: function(b2) {
      g = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.historicalBar = function() {
    "use strict";
    function b(x) {
      return x.each(function(b2) {
        w.reset(), k = d3.select(this);
        var x2 = a.utils.availableWidth(h, k, g), y = a.utils.availableHeight(i, k, g);
        a.utils.initSVG(k), l.domain(c || d3.extent(b2[0].values.map(n).concat(p))), r ? l.range(e || [0.5 * x2 / b2[0].values.length, x2 * (b2[0].values.length - 0.5) / b2[0].values.length]) : l.range(e || [0, x2]), m.domain(d || d3.extent(b2[0].values.map(o).concat(q))).range(f || [y, 0]), l.domain()[0] === l.domain()[1] && (l.domain()[0] ? l.domain([l.domain()[0] - 0.01 * l.domain()[0], l.domain()[1] + 0.01 * l.domain()[1]]) : l.domain([-1, 1])), m.domain()[0] === m.domain()[1] && (m.domain()[0] ? m.domain([m.domain()[0] + 0.01 * m.domain()[0], m.domain()[1] - 0.01 * m.domain()[1]]) : m.domain([-1, 1]));
        var z = k.selectAll("g.nv-wrap.nv-historicalBar-" + j).data([b2[0].values]), A = z.enter().append("g").attr("class", "nvd3 nv-wrap nv-historicalBar-" + j), B = A.append("defs"), C = A.append("g"), D = z.select("g");
        C.append("g").attr("class", "nv-bars"), z.attr("transform", "translate(" + g.left + "," + g.top + ")"), k.on("click", function(a2, b3) {
          u.chartClick({ data: a2, index: b3, pos: d3.event, id: j });
        }), B.append("clipPath").attr("id", "nv-chart-clip-path-" + j).append("rect"), z.select("#nv-chart-clip-path-" + j + " rect").attr("width", x2).attr("height", y), D.attr("clip-path", s ? "url(#nv-chart-clip-path-" + j + ")" : "");
        var E = z.select(".nv-bars").selectAll(".nv-bar").data(function(a2) {
          return a2;
        }, function(a2, b3) {
          return n(a2, b3);
        });
        E.exit().remove(), E.enter().append("rect").attr("x", 0).attr("y", function(b3, c2) {
          return a.utils.NaNtoZero(m(Math.max(0, o(b3, c2))));
        }).attr("height", function(b3, c2) {
          return a.utils.NaNtoZero(Math.abs(m(o(b3, c2)) - m(0)));
        }).attr("transform", function(a2, c2) {
          return "translate(" + (l(n(a2, c2)) - x2 / b2[0].values.length * 0.45) + ",0)";
        }).on("mouseover", function(a2, b3) {
          v && (d3.select(this).classed("hover", true), u.elementMouseover({ data: a2, index: b3, color: d3.select(this).style("fill") }));
        }).on("mouseout", function(a2, b3) {
          v && (d3.select(this).classed("hover", false), u.elementMouseout({ data: a2, index: b3, color: d3.select(this).style("fill") }));
        }).on("mousemove", function(a2, b3) {
          v && u.elementMousemove({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("click", function(a2, b3) {
          v && (u.elementClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation());
        }).on("dblclick", function(a2, b3) {
          v && (u.elementDblClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation());
        }), E.attr("fill", function(a2, b3) {
          return t(a2, b3);
        }).attr("class", function(a2, b3, c2) {
          return (o(a2, b3) < 0 ? "nv-bar negative" : "nv-bar positive") + " nv-bar-" + c2 + "-" + b3;
        }).watchTransition(w, "bars").attr("transform", function(a2, c2) {
          return "translate(" + (l(n(a2, c2)) - x2 / b2[0].values.length * 0.45) + ",0)";
        }).attr("width", x2 / b2[0].values.length * 0.9), E.watchTransition(w, "bars").attr("y", function(b3, c2) {
          var d2 = o(b3, c2) < 0 ? m(0) : m(0) - m(o(b3, c2)) < 1 ? m(0) - 1 : m(o(b3, c2));
          return a.utils.NaNtoZero(d2);
        }).attr("height", function(b3, c2) {
          return a.utils.NaNtoZero(Math.max(Math.abs(m(o(b3, c2)) - m(0)), 1));
        });
      }), w.renderEnd("historicalBar immediate"), b;
    }
    var c, d, e, f, g = { top: 0, right: 0, bottom: 0, left: 0 }, h = null, i = null, j = Math.floor(1e4 * Math.random()), k = null, l = d3.scale.linear(), m = d3.scale.linear(), n = function(a2) {
      return a2.x;
    }, o = function(a2) {
      return a2.y;
    }, p = [], q = [0], r = false, s = true, t = a.utils.defaultColor(), u = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), v = true, w = a.utils.renderWatch(u, 0);
    return b.highlightPoint = function(a2, b2) {
      k.select(".nv-bars .nv-bar-0-" + a2).classed("hover", b2);
    }, b.clearHighlights = function() {
      k.select(".nv-bars .nv-bar.hover").classed("hover", false);
    }, b.dispatch = u, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, height: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, forceX: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, forceY: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, padData: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, x: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, y: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, xScale: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, yScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, xDomain: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, yDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, xRange: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, yRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, clipEdge: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, id: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, interactive: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, margin: { get: function() {
      return g;
    }, set: function(a2) {
      g.top = void 0 !== a2.top ? a2.top : g.top, g.right = void 0 !== a2.right ? a2.right : g.right, g.bottom = void 0 !== a2.bottom ? a2.bottom : g.bottom, g.left = void 0 !== a2.left ? a2.left : g.left;
    } }, color: { get: function() {
      return t;
    }, set: function(b2) {
      t = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.historicalBarChart = function(b) {
    "use strict";
    function c(b2) {
      return b2.each(function(k2) {
        z.reset(), z.models(f), q && z.models(g), r && z.models(h);
        var w2 = d3.select(this), A = this;
        a.utils.initSVG(w2);
        var B = a.utils.availableWidth(n, w2, l), C = a.utils.availableHeight(o, w2, l);
        if (c.update = function() {
          w2.transition().duration(y).call(c);
        }, c.container = this, u.disabled = k2.map(function(a2) {
          return !!a2.disabled;
        }), !v) {
          var D;
          v = {};
          for (D in u) u[D] instanceof Array ? v[D] = u[D].slice(0) : v[D] = u[D];
        }
        if (!(k2 && k2.length && k2.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(c, w2), c;
        w2.selectAll(".nv-noData").remove(), d = f.xScale(), e = f.yScale();
        var E = w2.selectAll("g.nv-wrap.nv-historicalBarChart").data([k2]), F = E.enter().append("g").attr("class", "nvd3 nv-wrap nv-historicalBarChart").append("g"), G = E.select("g");
        F.append("g").attr("class", "nv-x nv-axis"), F.append("g").attr("class", "nv-y nv-axis"), F.append("g").attr("class", "nv-barsWrap"), F.append("g").attr("class", "nv-legendWrap"), F.append("g").attr("class", "nv-interactive"), p && (i.width(B), G.select(".nv-legendWrap").datum(k2).call(i), l.top != i.height() && (l.top = i.height(), C = a.utils.availableHeight(o, w2, l)), E.select(".nv-legendWrap").attr("transform", "translate(0," + -l.top + ")")), E.attr("transform", "translate(" + l.left + "," + l.top + ")"), s && G.select(".nv-y.nv-axis").attr("transform", "translate(" + B + ",0)"), t && (j.width(B).height(C).margin({ left: l.left, top: l.top }).svgContainer(w2).xScale(d), E.select(".nv-interactive").call(j)), f.width(B).height(C).color(k2.map(function(a2, b3) {
          return a2.color || m(a2, b3);
        }).filter(function(a2, b3) {
          return !k2[b3].disabled;
        }));
        var H = G.select(".nv-barsWrap").datum(k2.filter(function(a2) {
          return !a2.disabled;
        }));
        H.transition().call(f), q && (g.scale(d)._ticks(a.utils.calcTicksX(B / 100, k2)).tickSize(-C, 0), G.select(".nv-x.nv-axis").attr("transform", "translate(0," + e.range()[0] + ")"), G.select(".nv-x.nv-axis").transition().call(g)), r && (h.scale(e)._ticks(a.utils.calcTicksY(C / 36, k2)).tickSize(-B, 0), G.select(".nv-y.nv-axis").transition().call(h)), j.dispatch.on("elementMousemove", function(b3) {
          f.clearHighlights();
          var d2, e2, i2, l2 = [];
          k2.filter(function(a2, b4) {
            return a2.seriesIndex = b4, !a2.disabled;
          }).forEach(function(g2, h2) {
            e2 = a.interactiveBisect(g2.values, b3.pointXValue, c.x()), f.highlightPoint(e2, true);
            var j2 = g2.values[e2];
            void 0 !== j2 && (void 0 === d2 && (d2 = j2), void 0 === i2 && (i2 = c.xScale()(c.x()(j2, e2))), l2.push({ key: g2.key, value: c.y()(j2, e2), color: m(g2, g2.seriesIndex), data: g2.values[e2] }));
          });
          var n2 = g.tickFormat()(c.x()(d2, e2));
          j.tooltip.chartContainer(A.parentNode).valueFormatter(function(a2, b4) {
            return h.tickFormat()(a2);
          }).data({ value: n2, index: e2, series: l2 })(), j.renderGuideLine(i2);
        }), j.dispatch.on("elementMouseout", function(a2) {
          x.tooltipHide(), f.clearHighlights();
        }), i.dispatch.on("legendClick", function(a2, d2) {
          a2.disabled = !a2.disabled, k2.filter(function(a3) {
            return !a3.disabled;
          }).length || k2.map(function(a3) {
            return a3.disabled = false, E.selectAll(".nv-series").classed("disabled", false), a3;
          }), u.disabled = k2.map(function(a3) {
            return !!a3.disabled;
          }), x.stateChange(u), b2.transition().call(c);
        }), i.dispatch.on("legendDblclick", function(a2) {
          k2.forEach(function(a3) {
            a3.disabled = true;
          }), a2.disabled = false, u.disabled = k2.map(function(a3) {
            return !!a3.disabled;
          }), x.stateChange(u), c.update();
        }), x.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (k2.forEach(function(b3, c2) {
            b3.disabled = a2.disabled[c2];
          }), u.disabled = a2.disabled), c.update();
        });
      }), z.renderEnd("historicalBarChart immediate"), c;
    }
    var d, e, f = b || a.models.historicalBar(), g = a.models.axis(), h = a.models.axis(), i = a.models.legend(), j = a.interactiveGuideline(), k = a.models.tooltip(), l = { top: 30, right: 90, bottom: 50, left: 90 }, m = a.utils.defaultColor(), n = null, o = null, p = false, q = true, r = true, s = false, t = false, u = {}, v = null, w = null, x = d3.dispatch("tooltipHide", "stateChange", "changeState", "renderEnd"), y = 250;
    g.orient("bottom").tickPadding(7), h.orient(s ? "right" : "left"), k.duration(0).headerEnabled(false).valueFormatter(function(a2, b2) {
      return h.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    });
    var z = a.utils.renderWatch(x, 0);
    return f.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.series = { key: c.x()(a2.data), value: c.y()(a2.data), color: a2.color }, k.data(a2).hidden(false);
    }), f.dispatch.on("elementMouseout.tooltip", function(a2) {
      k.hidden(true);
    }), f.dispatch.on("elementMousemove.tooltip", function(a2) {
      k();
    }), c.dispatch = x, c.bars = f, c.legend = i, c.xAxis = g, c.yAxis = h, c.interactiveLayer = j, c.tooltip = k, c.options = a.utils.optionsFunc.bind(c), c._options = Object.create({}, { width: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, height: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, showLegend: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, showXAxis: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, showYAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, defaultState: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, noData: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, margin: { get: function() {
      return l;
    }, set: function(a2) {
      l.top = void 0 !== a2.top ? a2.top : l.top, l.right = void 0 !== a2.right ? a2.right : l.right, l.bottom = void 0 !== a2.bottom ? a2.bottom : l.bottom, l.left = void 0 !== a2.left ? a2.left : l.left;
    } }, color: { get: function() {
      return m;
    }, set: function(b2) {
      m = a.utils.getColor(b2), i.color(m), f.color(m);
    } }, duration: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2, z.reset(y), h.duration(y), g.duration(y);
    } }, rightAlignYAxis: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2, h.orient(a2 ? "right" : "left");
    } }, useInteractiveGuideline: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2, a2 === true && c.interactive(false);
    } } }), a.utils.inheritOptions(c, f), a.utils.initOptions(c), c;
  }, a.models.ohlcBarChart = function() {
    var b = a.models.historicalBarChart(a.models.ohlcBar());
    return b.useInteractiveGuideline(true), b.interactiveLayer.tooltip.contentGenerator(function(a2) {
      var c = a2.series[0].data, d = c.open < c.close ? "2ca02c" : "d62728";
      return '<h3 style="color: #' + d + '">' + a2.value + "</h3><table><tr><td>open:</td><td>" + b.yAxis.tickFormat()(c.open) + "</td></tr><tr><td>close:</td><td>" + b.yAxis.tickFormat()(c.close) + "</td></tr><tr><td>high</td><td>" + b.yAxis.tickFormat()(c.high) + "</td></tr><tr><td>low:</td><td>" + b.yAxis.tickFormat()(c.low) + "</td></tr></table>";
    }), b;
  }, a.models.candlestickBarChart = function() {
    var b = a.models.historicalBarChart(a.models.candlestickBar());
    return b.useInteractiveGuideline(true), b.interactiveLayer.tooltip.contentGenerator(function(a2) {
      var c = a2.series[0].data, d = c.open < c.close ? "2ca02c" : "d62728";
      return '<h3 style="color: #' + d + '">' + a2.value + "</h3><table><tr><td>open:</td><td>" + b.yAxis.tickFormat()(c.open) + "</td></tr><tr><td>close:</td><td>" + b.yAxis.tickFormat()(c.close) + "</td></tr><tr><td>high</td><td>" + b.yAxis.tickFormat()(c.high) + "</td></tr><tr><td>low:</td><td>" + b.yAxis.tickFormat()(c.low) + "</td></tr></table>";
    }), b;
  }, a.models.legend = function() {
    "use strict";
    function b(q) {
      function r(a2, b2) {
        return "furious" != p ? "#000" : n ? a2.disengaged ? "#000" : "#fff" : n ? void 0 : (a2.color || (a2.color = g(a2, b2)), a2.disabled ? a2.color : "#fff");
      }
      function s(a2, b2) {
        return n && "furious" == p && a2.disengaged ? "#eee" : a2.color || g(a2, b2);
      }
      function t(a2, b2) {
        return n && "furious" == p ? 1 : a2.disabled ? 0 : 1;
      }
      return q.each(function(b2) {
        var g2 = d - c.left - c.right, q2 = d3.select(this);
        a.utils.initSVG(q2);
        var u = q2.selectAll("g.nv-legend").data([b2]), v = u.enter().append("g").attr("class", "nvd3 nv-legend").append("g"), w = u.select("g");
        u.attr("transform", "translate(" + c.left + "," + c.top + ")");
        var x, y, z = w.selectAll(".nv-series").data(function(a2) {
          return "furious" != p ? a2 : a2.filter(function(a3) {
            return n ? true : !a3.disengaged;
          });
        }), A = z.enter().append("g").attr("class", "nv-series");
        switch (p) {
          case "furious":
            y = 23;
            break;
          case "classic":
            y = 20;
        }
        if ("classic" == p) A.append("circle").style("stroke-width", 2).attr("class", "nv-legend-symbol").attr("r", 5), x = z.select("circle");
        else if ("furious" == p) {
          A.append("rect").style("stroke-width", 2).attr("class", "nv-legend-symbol").attr("rx", 3).attr("ry", 3), x = z.select(".nv-legend-symbol"), A.append("g").attr("class", "nv-check-box").property("innerHTML", '<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr("transform", "translate(-10,-8)scale(0.5)");
          var B = z.select(".nv-check-box");
          B.each(function(a2, b3) {
            d3.select(this).selectAll("path").attr("stroke", r(a2, b3));
          });
        }
        A.append("text").attr("text-anchor", "start").attr("class", "nv-legend-text").attr("dy", ".32em").attr("dx", "8");
        var C = z.select("text.nv-legend-text");
        z.on("mouseover", function(a2, b3) {
          o.legendMouseover(a2, b3);
        }).on("mouseout", function(a2, b3) {
          o.legendMouseout(a2, b3);
        }).on("click", function(a2, b3) {
          o.legendClick(a2, b3);
          var c2 = z.data();
          if (l) {
            if ("classic" == p) m ? (c2.forEach(function(a3) {
              a3.disabled = true;
            }), a2.disabled = false) : (a2.disabled = !a2.disabled, c2.every(function(a3) {
              return a3.disabled;
            }) && c2.forEach(function(a3) {
              a3.disabled = false;
            }));
            else if ("furious" == p) {
              if (n) a2.disengaged = !a2.disengaged, a2.userDisabled = void 0 == a2.userDisabled ? !!a2.disabled : a2.userDisabled, a2.disabled = a2.disengaged || a2.userDisabled;
              else if (!n) {
                a2.disabled = !a2.disabled, a2.userDisabled = a2.disabled;
                var d2 = c2.filter(function(a3) {
                  return !a3.disengaged;
                });
                d2.every(function(a3) {
                  return a3.userDisabled;
                }) && c2.forEach(function(a3) {
                  a3.disabled = a3.userDisabled = false;
                });
              }
            }
            o.stateChange({ disabled: c2.map(function(a3) {
              return !!a3.disabled;
            }), disengaged: c2.map(function(a3) {
              return !!a3.disengaged;
            }) });
          }
        }).on("dblclick", function(a2, b3) {
          if (("furious" != p || !n) && (o.legendDblclick(a2, b3), l)) {
            var c2 = z.data();
            c2.forEach(function(a3) {
              a3.disabled = true, "furious" == p && (a3.userDisabled = a3.disabled);
            }), a2.disabled = false, "furious" == p && (a2.userDisabled = a2.disabled), o.stateChange({ disabled: c2.map(function(a3) {
              return !!a3.disabled;
            }) });
          }
        }), z.classed("nv-disabled", function(a2) {
          return a2.userDisabled;
        }), z.exit().remove(), C.attr("fill", r).text(f);
        var D = 0;
        if (i) {
          var E = [];
          z.each(function(b3, c2) {
            var d2;
            if (f(b3).length > h) {
              var e2 = f(b3).substring(0, h);
              d2 = d3.select(this).select("text").text(e2 + "..."), d3.select(this).append("svg:title").text(f(b3));
            } else d2 = d3.select(this).select("text");
            var g3;
            try {
              if (g3 = d2.node().getComputedTextLength(), 0 >= g3) throw Error();
            } catch (i2) {
              g3 = a.utils.calcApproxTextWidth(d2);
            }
            E.push(g3 + j);
          });
          var F = 0, G = [];
          for (D = 0; g2 > D && F < E.length; ) G[F] = E[F], D += E[F++];
          for (0 === F && (F = 1); D > g2 && F > 1; ) {
            G = [], F--;
            for (var H = 0; H < E.length; H++) E[H] > (G[H % F] || 0) && (G[H % F] = E[H]);
            D = G.reduce(function(a2, b3, c2, d2) {
              return a2 + b3;
            });
          }
          for (var I = [], J = 0, K = 0; F > J; J++) I[J] = K, K += G[J];
          z.attr("transform", function(a2, b3) {
            return "translate(" + I[b3 % F] + "," + (5 + Math.floor(b3 / F) * y) + ")";
          }), k ? w.attr("transform", "translate(" + (d - c.right - D) + "," + c.top + ")") : w.attr("transform", "translate(0," + c.top + ")"), e = c.top + c.bottom + Math.ceil(E.length / F) * y;
        } else {
          var L, M = 5, N = 5, O = 0;
          z.attr("transform", function(a2, b3) {
            var e2 = d3.select(this).select("text").node().getComputedTextLength() + j;
            return L = N, d < c.left + c.right + L + e2 && (N = L = 5, M += y), N += e2, N > O && (O = N), L + O > D && (D = L + O), "translate(" + L + "," + M + ")";
          }), w.attr("transform", "translate(" + (d - c.right - O) + "," + c.top + ")"), e = c.top + c.bottom + M + 15;
        }
        if ("furious" == p) {
          x.attr("width", function(a2, b3) {
            return C[0][b3].getComputedTextLength() + 27;
          }).attr("height", 18).attr("y", -9).attr("x", -15), v.insert("rect", ":first-child").attr("class", "nv-legend-bg").attr("fill", "#eee").attr("opacity", 0);
          var P = w.select(".nv-legend-bg");
          P.transition().duration(300).attr("x", -y).attr("width", D + y - 12).attr("height", e + 10).attr("y", -c.top - 10).attr("opacity", n ? 1 : 0);
        }
        x.style("fill", s).style("fill-opacity", t).style("stroke", s);
      }), b;
    }
    var c = { top: 5, right: 0, bottom: 5, left: 0 }, d = 400, e = 20, f = function(a2) {
      return a2.key;
    }, g = a.utils.getColor(), h = 20, i = true, j = 32, k = true, l = true, m = false, n = false, o = d3.dispatch("legendClick", "legendDblclick", "legendMouseover", "legendMouseout", "stateChange"), p = "classic";
    return b.dispatch = o, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, height: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, key: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, align: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, maxKeyLength: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, rightAlign: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, padding: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, updateState: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, radioButtonMode: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, expanded: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, vers: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, margin: { get: function() {
      return c;
    }, set: function(a2) {
      c.top = void 0 !== a2.top ? a2.top : c.top, c.right = void 0 !== a2.right ? a2.right : c.right, c.bottom = void 0 !== a2.bottom ? a2.bottom : c.bottom, c.left = void 0 !== a2.left ? a2.left : c.left;
    } }, color: { get: function() {
      return g;
    }, set: function(b2) {
      g = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.line = function() {
    "use strict";
    function b(r2) {
      return v.reset(), v.models(e), r2.each(function(b2) {
        i = d3.select(this);
        var r3 = a.utils.availableWidth(g, i, f), s2 = a.utils.availableHeight(h, i, f);
        a.utils.initSVG(i), c = e.xScale(), d = e.yScale(), t = t || c, u = u || d;
        var w = i.selectAll("g.nv-wrap.nv-line").data([b2]), x = w.enter().append("g").attr("class", "nvd3 nv-wrap nv-line"), y = x.append("defs"), z = x.append("g"), A = w.select("g");
        z.append("g").attr("class", "nv-groups"), z.append("g").attr("class", "nv-scatterWrap"), w.attr("transform", "translate(" + f.left + "," + f.top + ")"), e.width(r3).height(s2);
        var B = w.select(".nv-scatterWrap");
        B.call(e), y.append("clipPath").attr("id", "nv-edge-clip-" + e.id()).append("rect"), w.select("#nv-edge-clip-" + e.id() + " rect").attr("width", r3).attr("height", s2 > 0 ? s2 : 0), A.attr("clip-path", p ? "url(#nv-edge-clip-" + e.id() + ")" : ""), B.attr("clip-path", p ? "url(#nv-edge-clip-" + e.id() + ")" : "");
        var C = w.select(".nv-groups").selectAll(".nv-group").data(function(a2) {
          return a2;
        }, function(a2) {
          return a2.key;
        });
        C.enter().append("g").style("stroke-opacity", 1e-6).style("stroke-width", function(a2) {
          return a2.strokeWidth || j;
        }).style("fill-opacity", 1e-6), C.exit().remove(), C.attr("class", function(a2, b3) {
          return (a2.classed || "") + " nv-group nv-series-" + b3;
        }).classed("hover", function(a2) {
          return a2.hover;
        }).style("fill", function(a2, b3) {
          return k(a2, b3);
        }).style("stroke", function(a2, b3) {
          return k(a2, b3);
        }), C.watchTransition(v, "line: groups").style("stroke-opacity", 1).style("fill-opacity", function(a2) {
          return a2.fillOpacity || 0.5;
        });
        var D = C.selectAll("path.nv-area").data(function(a2) {
          return o(a2) ? [a2] : [];
        });
        D.enter().append("path").attr("class", "nv-area").attr("d", function(b3) {
          return d3.svg.area().interpolate(q).defined(n).x(function(b4, c2) {
            return a.utils.NaNtoZero(t(l(b4, c2)));
          }).y0(function(b4, c2) {
            return a.utils.NaNtoZero(u(m(b4, c2)));
          }).y1(function(a2, b4) {
            return u(d.domain()[0] <= 0 ? d.domain()[1] >= 0 ? 0 : d.domain()[1] : d.domain()[0]);
          }).apply(this, [b3.values]);
        }), C.exit().selectAll("path.nv-area").remove(), D.watchTransition(v, "line: areaPaths").attr("d", function(b3) {
          return d3.svg.area().interpolate(q).defined(n).x(function(b4, d2) {
            return a.utils.NaNtoZero(c(l(b4, d2)));
          }).y0(function(b4, c2) {
            return a.utils.NaNtoZero(d(m(b4, c2)));
          }).y1(function(a2, b4) {
            return d(d.domain()[0] <= 0 ? d.domain()[1] >= 0 ? 0 : d.domain()[1] : d.domain()[0]);
          }).apply(this, [b3.values]);
        });
        var E = C.selectAll("path.nv-line").data(function(a2) {
          return [a2.values];
        });
        E.enter().append("path").attr("class", "nv-line").attr("d", d3.svg.line().interpolate(q).defined(n).x(function(b3, c2) {
          return a.utils.NaNtoZero(t(l(b3, c2)));
        }).y(function(b3, c2) {
          return a.utils.NaNtoZero(u(m(b3, c2)));
        })), E.watchTransition(v, "line: linePaths").attr("d", d3.svg.line().interpolate(q).defined(n).x(function(b3, d2) {
          return a.utils.NaNtoZero(c(l(b3, d2)));
        }).y(function(b3, c2) {
          return a.utils.NaNtoZero(d(m(b3, c2)));
        })), t = c.copy(), u = d.copy();
      }), v.renderEnd("line immediate"), b;
    }
    var c, d, e = a.models.scatter(), f = { top: 0, right: 0, bottom: 0, left: 0 }, g = 960, h = 500, i = null, j = 1.5, k = a.utils.defaultColor(), l = function(a2) {
      return a2.x;
    }, m = function(a2) {
      return a2.y;
    }, n = function(a2, b2) {
      return !isNaN(m(a2, b2)) && null !== m(a2, b2);
    }, o = function(a2) {
      return a2.area;
    }, p = false, q = "linear", r = 250, s = d3.dispatch("elementClick", "elementMouseover", "elementMouseout", "renderEnd");
    e.pointSize(16).pointDomain([16, 256]);
    var t, u, v = a.utils.renderWatch(s, r);
    return b.dispatch = s, b.scatter = e, e.dispatch.on("elementClick", function() {
      s.elementClick.apply(this, arguments);
    }), e.dispatch.on("elementMouseover", function() {
      s.elementMouseover.apply(this, arguments);
    }), e.dispatch.on("elementMouseout", function() {
      s.elementMouseout.apply(this, arguments);
    }), b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, height: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, defined: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, interpolate: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, clipEdge: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, margin: { get: function() {
      return f;
    }, set: function(a2) {
      f.top = void 0 !== a2.top ? a2.top : f.top, f.right = void 0 !== a2.right ? a2.right : f.right, f.bottom = void 0 !== a2.bottom ? a2.bottom : f.bottom, f.left = void 0 !== a2.left ? a2.left : f.left;
    } }, duration: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2, v.reset(r), e.duration(r);
    } }, isArea: { get: function() {
      return o;
    }, set: function(a2) {
      o = d3.functor(a2);
    } }, x: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2, e.x(a2);
    } }, y: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2, e.y(a2);
    } }, color: { get: function() {
      return k;
    }, set: function(b2) {
      k = a.utils.getColor(b2), e.color(k);
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.lineChart = function() {
    "use strict";
    function b(j2) {
      return y.reset(), y.models(e), p && y.models(f), q && y.models(g), j2.each(function(j3) {
        var v2 = d3.select(this), y2 = this;
        a.utils.initSVG(v2);
        var B = a.utils.availableWidth(m, v2, k), C = a.utils.availableHeight(n, v2, k);
        if (b.update = function() {
          0 === x ? v2.call(b) : v2.transition().duration(x).call(b);
        }, b.container = this, t.setter(A(j3), b.update).getter(z(j3)).update(), t.disabled = j3.map(function(a2) {
          return !!a2.disabled;
        }), !u) {
          var D;
          u = {};
          for (D in t) t[D] instanceof Array ? u[D] = t[D].slice(0) : u[D] = t[D];
        }
        if (!(j3 && j3.length && j3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, v2), b;
        v2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale();
        var E = v2.selectAll("g.nv-wrap.nv-lineChart").data([j3]), F = E.enter().append("g").attr("class", "nvd3 nv-wrap nv-lineChart").append("g"), G = E.select("g");
        F.append("rect").style("opacity", 0), F.append("g").attr("class", "nv-x nv-axis"), F.append("g").attr("class", "nv-y nv-axis"), F.append("g").attr("class", "nv-linesWrap"), F.append("g").attr("class", "nv-legendWrap"), F.append("g").attr("class", "nv-interactive"), G.select("rect").attr("width", B).attr("height", C > 0 ? C : 0), o && (h.width(B), G.select(".nv-legendWrap").datum(j3).call(h), k.top != h.height() && (k.top = h.height(), C = a.utils.availableHeight(n, v2, k)), E.select(".nv-legendWrap").attr("transform", "translate(0," + -k.top + ")")), E.attr("transform", "translate(" + k.left + "," + k.top + ")"), r && G.select(".nv-y.nv-axis").attr("transform", "translate(" + B + ",0)"), s && (i.width(B).height(C).margin({
          left: k.left,
          top: k.top
        }).svgContainer(v2).xScale(c), E.select(".nv-interactive").call(i)), e.width(B).height(C).color(j3.map(function(a2, b2) {
          return a2.color || l(a2, b2);
        }).filter(function(a2, b2) {
          return !j3[b2].disabled;
        }));
        var H = G.select(".nv-linesWrap").datum(j3.filter(function(a2) {
          return !a2.disabled;
        }));
        H.call(e), p && (f.scale(c)._ticks(a.utils.calcTicksX(B / 100, j3)).tickSize(-C, 0), G.select(".nv-x.nv-axis").attr("transform", "translate(0," + d.range()[0] + ")"), G.select(".nv-x.nv-axis").call(f)), q && (g.scale(d)._ticks(a.utils.calcTicksY(C / 36, j3)).tickSize(-B, 0), G.select(".nv-y.nv-axis").call(g)), h.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) t[c2] = a2[c2];
          w.stateChange(t), b.update();
        }), i.dispatch.on("elementMousemove", function(c2) {
          e.clearHighlights();
          var d2, h2, k2, m2 = [];
          if (j3.filter(function(a2, b2) {
            return a2.seriesIndex = b2, !a2.disabled;
          }).forEach(function(f2, g2) {
            h2 = a.interactiveBisect(f2.values, c2.pointXValue, b.x());
            var i2 = f2.values[h2], j4 = b.y()(i2, h2);
            null != j4 && e.highlightPoint(g2, h2, true), void 0 !== i2 && (void 0 === d2 && (d2 = i2), void 0 === k2 && (k2 = b.xScale()(b.x()(i2, h2))), m2.push({ key: f2.key, value: j4, color: l(f2, f2.seriesIndex) }));
          }), m2.length > 2) {
            var n2 = b.yScale().invert(c2.mouseY), o2 = Math.abs(b.yScale().domain()[0] - b.yScale().domain()[1]), p2 = 0.03 * o2, q2 = a.nearestValueIndex(m2.map(function(a2) {
              return a2.value;
            }), n2, p2);
            null !== q2 && (m2[q2].highlight = true);
          }
          var r2 = f.tickFormat()(b.x()(d2, h2));
          i.tooltip.chartContainer(y2.parentNode).valueFormatter(function(a2, b2) {
            return null == a2 ? "N/A" : g.tickFormat()(a2);
          }).data({ value: r2, index: h2, series: m2 })(), i.renderGuideLine(k2);
        }), i.dispatch.on("elementClick", function(c2) {
          var d2, f2 = [];
          j3.filter(function(a2, b2) {
            return a2.seriesIndex = b2, !a2.disabled;
          }).forEach(function(e2) {
            var g2 = a.interactiveBisect(e2.values, c2.pointXValue, b.x()), h2 = e2.values[g2];
            if ("undefined" != typeof h2) {
              "undefined" == typeof d2 && (d2 = b.xScale()(b.x()(h2, g2)));
              var i2 = b.yScale()(b.y()(h2, g2));
              f2.push({ point: h2, pointIndex: g2, pos: [d2, i2], seriesIndex: e2.seriesIndex, series: e2 });
            }
          }), e.dispatch.elementClick(f2);
        }), i.dispatch.on("elementMouseout", function(a2) {
          e.clearHighlights();
        }), w.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && j3.length === a2.disabled.length && (j3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), t.disabled = a2.disabled), b.update();
        });
      }), y.renderEnd("lineChart immediate"), b;
    }
    var c, d, e = a.models.line(), f = a.models.axis(), g = a.models.axis(), h = a.models.legend(), i = a.interactiveGuideline(), j = a.models.tooltip(), k = { top: 30, right: 20, bottom: 50, left: 60 }, l = a.utils.defaultColor(), m = null, n = null, o = true, p = true, q = true, r = false, s = false, t = a.utils.state(), u = null, v = null, w = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState", "renderEnd"), x = 250;
    f.orient("bottom").tickPadding(7), g.orient(r ? "right" : "left"), j.valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    });
    var y = a.utils.renderWatch(w, x), z = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }) };
      };
    }, A = function(a2) {
      return function(b2) {
        void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      j.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      j.hidden(true);
    }), b.dispatch = w, b.lines = e, b.legend = h, b.xAxis = f, b.yAxis = g, b.interactiveLayer = i, b.tooltip = j, b.dispatch = w, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, height: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, showLegend: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, showXAxis: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, showYAxis: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, defaultState: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, noData: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, margin: { get: function() {
      return k;
    }, set: function(a2) {
      k.top = void 0 !== a2.top ? a2.top : k.top, k.right = void 0 !== a2.right ? a2.right : k.right, k.bottom = void 0 !== a2.bottom ? a2.bottom : k.bottom, k.left = void 0 !== a2.left ? a2.left : k.left;
    } }, duration: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2, y.reset(x), e.duration(x), f.duration(x), g.duration(x);
    } }, color: { get: function() {
      return l;
    }, set: function(b2) {
      l = a.utils.getColor(b2), h.color(l), e.color(l);
    } }, rightAlignYAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2, g.orient(r ? "right" : "left");
    } }, useInteractiveGuideline: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2, s && (e.interactive(false), e.useVoronoi(false));
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.linePlusBarChart = function() {
    "use strict";
    function b(v2) {
      return v2.each(function(v3) {
        function J2(a2) {
          var b2 = +("e" == a2), c2 = b2 ? 1 : -1, d2 = Y / 3;
          return "M" + 0.5 * c2 + "," + d2 + "A6,6 0 0 " + b2 + " " + 6.5 * c2 + "," + (d2 + 6) + "V" + (2 * d2 - 6) + "A6,6 0 0 " + b2 + " " + 0.5 * c2 + "," + 2 * d2 + "ZM" + 2.5 * c2 + "," + (d2 + 8) + "V" + (2 * d2 - 8) + "M" + 4.5 * c2 + "," + (d2 + 8) + "V" + (2 * d2 - 8);
        }
        function T() {
          u.empty() || u.extent(I), la.data([u.empty() ? e.domain() : I]).each(function(a2, b2) {
            var c2 = e(a2[0]) - e.range()[0], d2 = e.range()[1] - e(a2[1]);
            d3.select(this).select(".left").attr("width", 0 > c2 ? 0 : c2), d3.select(this).select(".right").attr("x", e(a2[1])).attr("width", 0 > d2 ? 0 : d2);
          });
        }
        function U() {
          I = u.empty() ? null : u.extent(), c = u.empty() ? e.domain() : u.extent(), K.brush({ extent: c, brush: u }), T(), l.width(W).height(X).color(v3.map(function(a2, b3) {
            return a2.color || C(a2, b3);
          }).filter(function(a2, b3) {
            return !v3[b3].disabled && v3[b3].bar;
          })), j.width(W).height(X).color(v3.map(function(a2, b3) {
            return a2.color || C(a2, b3);
          }).filter(function(a2, b3) {
            return !v3[b3].disabled && !v3[b3].bar;
          }));
          var b2 = ea.select(".nv-focus .nv-barsWrap").datum($.length ? $.map(function(a2, b3) {
            return { key: a2.key, values: a2.values.filter(function(a3, b4) {
              return l.x()(a3, b4) >= c[0] && l.x()(a3, b4) <= c[1];
            }) };
          }) : [{ values: [] }]), h2 = ea.select(".nv-focus .nv-linesWrap").datum(S(_5) ? [{ values: [] }] : _5.filter(function(a2) {
            return !a2.disabled;
          }).map(function(a2, b3) {
            return { area: a2.area, fillOpacity: a2.fillOpacity, key: a2.key, values: a2.values.filter(function(a3, b4) {
              return j.x()(a3, b4) >= c[0] && j.x()(a3, b4) <= c[1];
            }) };
          }));
          d = $.length ? l.xScale() : j.xScale(), n.scale(d)._ticks(a.utils.calcTicksX(W / 100, v3)).tickSize(-X, 0), n.domain([Math.ceil(c[0]), Math.floor(c[1])]), ea.select(".nv-x.nv-axis").transition().duration(L).call(n), b2.transition().duration(L).call(l), h2.transition().duration(L).call(j), ea.select(".nv-focus .nv-x.nv-axis").attr("transform", "translate(0," + f.range()[0] + ")"), p.scale(f)._ticks(a.utils.calcTicksY(X / 36, v3)).tickSize(-W, 0), q.scale(g)._ticks(a.utils.calcTicksY(X / 36, v3)).tickSize($.length ? 0 : -W, 0), ea.select(".nv-focus .nv-y1.nv-axis").style("opacity", $.length ? 1 : 0), ea.select(".nv-focus .nv-y2.nv-axis").style("opacity", _5.length && !S(_5) ? 1 : 0).attr("transform", "translate(" + d.range()[1] + ",0)"), ea.select(".nv-focus .nv-y1.nv-axis").transition().duration(L).call(p), ea.select(".nv-focus .nv-y2.nv-axis").transition().duration(L).call(q);
        }
        var V = d3.select(this);
        a.utils.initSVG(V);
        var W = a.utils.availableWidth(y, V, w), X = a.utils.availableHeight(z, V, w) - (E ? H : 0), Y = H - x.top - x.bottom;
        if (b.update = function() {
          V.transition().duration(L).call(b);
        }, b.container = this, M.setter(R(v3), b.update).getter(Q(v3)).update(), M.disabled = v3.map(function(a2) {
          return !!a2.disabled;
        }), !N) {
          var Z;
          N = {};
          for (Z in M) M[Z] instanceof Array ? N[Z] = M[Z].slice(0) : N[Z] = M[Z];
        }
        if (!(v3 && v3.length && v3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, V), b;
        V.selectAll(".nv-noData").remove();
        var $ = v3.filter(function(a2) {
          return !a2.disabled && a2.bar;
        }), _5 = v3.filter(function(a2) {
          return !a2.bar;
        });
        d = l.xScale(), e = o.scale(), f = l.yScale(), g = j.yScale(), h = m.yScale(), i = k.yScale();
        var aa = v3.filter(function(a2) {
          return !a2.disabled && a2.bar;
        }).map(function(a2) {
          return a2.values.map(function(a3, b2) {
            return { x: A(a3, b2), y: B(a3, b2) };
          });
        }), ba = v3.filter(function(a2) {
          return !a2.disabled && !a2.bar;
        }).map(function(a2) {
          return a2.values.map(function(a3, b2) {
            return { x: A(a3, b2), y: B(a3, b2) };
          });
        });
        d.range([0, W]), e.domain(d3.extent(d3.merge(aa.concat(ba)), function(a2) {
          return a2.x;
        })).range([0, W]);
        var ca = V.selectAll("g.nv-wrap.nv-linePlusBar").data([v3]), da = ca.enter().append("g").attr("class", "nvd3 nv-wrap nv-linePlusBar").append("g"), ea = ca.select("g");
        da.append("g").attr("class", "nv-legendWrap");
        var fa = da.append("g").attr("class", "nv-focus");
        fa.append("g").attr("class", "nv-x nv-axis"), fa.append("g").attr("class", "nv-y1 nv-axis"), fa.append("g").attr("class", "nv-y2 nv-axis"), fa.append("g").attr("class", "nv-barsWrap"), fa.append("g").attr("class", "nv-linesWrap");
        var ga = da.append("g").attr("class", "nv-context");
        if (ga.append("g").attr("class", "nv-x nv-axis"), ga.append("g").attr("class", "nv-y1 nv-axis"), ga.append("g").attr("class", "nv-y2 nv-axis"), ga.append("g").attr("class", "nv-barsWrap"), ga.append("g").attr("class", "nv-linesWrap"), ga.append("g").attr("class", "nv-brushBackground"), ga.append("g").attr("class", "nv-x nv-brush"), D) {
          var ha = t.align() ? W / 2 : W, ia = t.align() ? ha : 0;
          t.width(ha), ea.select(".nv-legendWrap").datum(v3.map(function(a2) {
            return a2.originalKey = void 0 === a2.originalKey ? a2.key : a2.originalKey, a2.key = a2.originalKey + (a2.bar ? O : P), a2;
          })).call(t), w.top != t.height() && (w.top = t.height(), X = a.utils.availableHeight(z, V, w) - H), ea.select(".nv-legendWrap").attr("transform", "translate(" + ia + "," + -w.top + ")");
        }
        ca.attr("transform", "translate(" + w.left + "," + w.top + ")"), ea.select(".nv-context").style("display", E ? "initial" : "none"), m.width(W).height(Y).color(v3.map(function(a2, b2) {
          return a2.color || C(a2, b2);
        }).filter(function(a2, b2) {
          return !v3[b2].disabled && v3[b2].bar;
        })), k.width(W).height(Y).color(v3.map(function(a2, b2) {
          return a2.color || C(a2, b2);
        }).filter(function(a2, b2) {
          return !v3[b2].disabled && !v3[b2].bar;
        }));
        var ja = ea.select(".nv-context .nv-barsWrap").datum($.length ? $ : [{ values: [] }]), ka = ea.select(".nv-context .nv-linesWrap").datum(S(_5) ? [{ values: [] }] : _5.filter(function(a2) {
          return !a2.disabled;
        }));
        ea.select(".nv-context").attr("transform", "translate(0," + (X + w.bottom + x.top) + ")"), ja.transition().call(m), ka.transition().call(k), G && (o._ticks(a.utils.calcTicksX(W / 100, v3)).tickSize(-Y, 0), ea.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + h.range()[0] + ")"), ea.select(".nv-context .nv-x.nv-axis").transition().call(o)), F && (r.scale(h)._ticks(Y / 36).tickSize(-W, 0), s.scale(i)._ticks(Y / 36).tickSize($.length ? 0 : -W, 0), ea.select(".nv-context .nv-y3.nv-axis").style("opacity", $.length ? 1 : 0).attr("transform", "translate(0," + e.range()[0] + ")"), ea.select(".nv-context .nv-y2.nv-axis").style("opacity", _5.length ? 1 : 0).attr("transform", "translate(" + e.range()[1] + ",0)"), ea.select(".nv-context .nv-y1.nv-axis").transition().call(r), ea.select(".nv-context .nv-y2.nv-axis").transition().call(s)), u.x(e).on("brush", U), I && u.extent(I);
        var la = ea.select(".nv-brushBackground").selectAll("g").data([I || u.extent()]), ma = la.enter().append("g");
        ma.append("rect").attr("class", "left").attr("x", 0).attr("y", 0).attr("height", Y), ma.append("rect").attr("class", "right").attr("x", 0).attr("y", 0).attr("height", Y);
        var na = ea.select(".nv-x.nv-brush").call(u);
        na.selectAll("rect").attr("height", Y), na.selectAll(".resize").append("path").attr("d", J2), t.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) M[c2] = a2[c2];
          K.stateChange(M), b.update();
        }), K.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (v3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), M.disabled = a2.disabled), b.update();
        }), U();
      }), b;
    }
    var c, d, e, f, g, h, i, j = a.models.line(), k = a.models.line(), l = a.models.historicalBar(), m = a.models.historicalBar(), n = a.models.axis(), o = a.models.axis(), p = a.models.axis(), q = a.models.axis(), r = a.models.axis(), s = a.models.axis(), t = a.models.legend(), u = d3.svg.brush(), v = a.models.tooltip(), w = { top: 30, right: 30, bottom: 30, left: 60 }, x = { top: 0, right: 30, bottom: 20, left: 60 }, y = null, z = null, A = function(a2) {
      return a2.x;
    }, B = function(a2) {
      return a2.y;
    }, C = a.utils.defaultColor(), D = true, E = true, F = false, G = true, H = 50, I = null, J = null, K = d3.dispatch("brush", "stateChange", "changeState"), L = 0, M = a.utils.state(), N = null, O = " (left axis)", P = " (right axis)";
    j.clipEdge(true), k.interactive(false), k.pointActive(function(a2) {
      return false;
    }), n.orient("bottom").tickPadding(5), p.orient("left"), q.orient("right"), o.orient("bottom").tickPadding(5), r.orient("left"), s.orient("right"), v.headerEnabled(true).headerFormatter(function(a2, b2) {
      return n.tickFormat()(a2, b2);
    });
    var Q = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }) };
      };
    }, R = function(a2) {
      return function(b2) {
        void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    }, S = function(a2) {
      return a2.every(function(a3) {
        return a3.disabled;
      });
    };
    return j.dispatch.on("elementMouseover.tooltip", function(a2) {
      v.duration(100).valueFormatter(function(a3, b2) {
        return q.tickFormat()(a3, b2);
      }).data(a2).hidden(false);
    }), j.dispatch.on("elementMouseout.tooltip", function(a2) {
      v.hidden(true);
    }), l.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.value = b.x()(a2.data), a2.series = { value: b.y()(a2.data), color: a2.color }, v.duration(0).valueFormatter(function(a3, b2) {
        return p.tickFormat()(a3, b2);
      }).data(a2).hidden(false);
    }), l.dispatch.on("elementMouseout.tooltip", function(a2) {
      v.hidden(true);
    }), l.dispatch.on("elementMousemove.tooltip", function(a2) {
      v();
    }), b.dispatch = K, b.legend = t, b.lines = j, b.lines2 = k, b.bars = l, b.bars2 = m, b.xAxis = n, b.x2Axis = o, b.y1Axis = p, b.y2Axis = q, b.y3Axis = r, b.y4Axis = s, b.tooltip = v, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, height: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, showLegend: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2;
    } }, brushExtent: { get: function() {
      return I;
    }, set: function(a2) {
      I = a2;
    } }, noData: { get: function() {
      return J;
    }, set: function(a2) {
      J = a2;
    } }, focusEnable: { get: function() {
      return E;
    }, set: function(a2) {
      E = a2;
    } }, focusHeight: { get: function() {
      return H;
    }, set: function(a2) {
      H = a2;
    } }, focusShowAxisX: { get: function() {
      return G;
    }, set: function(a2) {
      G = a2;
    } }, focusShowAxisY: { get: function() {
      return F;
    }, set: function(a2) {
      F = a2;
    } }, legendLeftAxisHint: { get: function() {
      return O;
    }, set: function(a2) {
      O = a2;
    } }, legendRightAxisHint: { get: function() {
      return P;
    }, set: function(a2) {
      P = a2;
    } }, margin: { get: function() {
      return w;
    }, set: function(a2) {
      w.top = void 0 !== a2.top ? a2.top : w.top, w.right = void 0 !== a2.right ? a2.right : w.right, w.bottom = void 0 !== a2.bottom ? a2.bottom : w.bottom, w.left = void 0 !== a2.left ? a2.left : w.left;
    } }, focusMargin: { get: function() {
      return x;
    }, set: function(a2) {
      x.top = void 0 !== a2.top ? a2.top : x.top, x.right = void 0 !== a2.right ? a2.right : x.right, x.bottom = void 0 !== a2.bottom ? a2.bottom : x.bottom, x.left = void 0 !== a2.left ? a2.left : x.left;
    } }, duration: { get: function() {
      return L;
    }, set: function(a2) {
      L = a2;
    } }, color: { get: function() {
      return C;
    }, set: function(b2) {
      C = a.utils.getColor(b2), t.color(C);
    } }, x: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2, j.x(a2), k.x(a2), l.x(a2), m.x(a2);
    } }, y: { get: function() {
      return B;
    }, set: function(a2) {
      B = a2, j.y(a2), k.y(a2), l.y(a2), m.y(a2);
    } } }), a.utils.inheritOptions(b, j), a.utils.initOptions(b), b;
  }, a.models.lineWithFocusChart = function() {
    "use strict";
    function b(o2) {
      return o2.each(function(o3) {
        function z2(a2) {
          var b2 = +("e" == a2), c2 = b2 ? 1 : -1, d2 = M / 3;
          return "M" + 0.5 * c2 + "," + d2 + "A6,6 0 0 " + b2 + " " + 6.5 * c2 + "," + (d2 + 6) + "V" + (2 * d2 - 6) + "A6,6 0 0 " + b2 + " " + 0.5 * c2 + "," + 2 * d2 + "ZM" + 2.5 * c2 + "," + (d2 + 8) + "V" + (2 * d2 - 8) + "M" + 4.5 * c2 + "," + (d2 + 8) + "V" + (2 * d2 - 8);
        }
        function G() {
          n.empty() || n.extent(y), U.data([n.empty() ? e.domain() : y]).each(function(a2, b2) {
            var d2 = e(a2[0]) - c.range()[0], f2 = K - e(a2[1]);
            d3.select(this).select(".left").attr("width", 0 > d2 ? 0 : d2), d3.select(this).select(".right").attr("x", e(a2[1])).attr("width", 0 > f2 ? 0 : f2);
          });
        }
        function H() {
          y = n.empty() ? null : n.extent();
          var a2 = n.empty() ? e.domain() : n.extent();
          if (!(Math.abs(a2[0] - a2[1]) <= 1)) {
            A.brush({ extent: a2, brush: n }), G();
            var b2 = Q.select(".nv-focus .nv-linesWrap").datum(o3.filter(function(a3) {
              return !a3.disabled;
            }).map(function(b3, c2) {
              return { key: b3.key, area: b3.area, classed: b3.classed, values: b3.values.filter(function(b4, c3) {
                return g.x()(b4, c3) >= a2[0] && g.x()(b4, c3) <= a2[1];
              }) };
            }));
            b2.transition().duration(B).call(g), Q.select(".nv-focus .nv-x.nv-axis").transition().duration(B).call(i), Q.select(".nv-focus .nv-y.nv-axis").transition().duration(B).call(j);
          }
        }
        var I = d3.select(this), J = this;
        a.utils.initSVG(I);
        var K = a.utils.availableWidth(t, I, q), L = a.utils.availableHeight(u, I, q) - v, M = v - r.top - r.bottom;
        if (b.update = function() {
          I.transition().duration(B).call(b);
        }, b.container = this, C.setter(F(o3), b.update).getter(E(o3)).update(), C.disabled = o3.map(function(a2) {
          return !!a2.disabled;
        }), !D) {
          var N;
          D = {};
          for (N in C) C[N] instanceof Array ? D[N] = C[N].slice(0) : D[N] = C[N];
        }
        if (!(o3 && o3.length && o3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, I), b;
        I.selectAll(".nv-noData").remove(), c = g.xScale(), d = g.yScale(), e = h.xScale(), f = h.yScale();
        var O = I.selectAll("g.nv-wrap.nv-lineWithFocusChart").data([o3]), P = O.enter().append("g").attr("class", "nvd3 nv-wrap nv-lineWithFocusChart").append("g"), Q = O.select("g");
        P.append("g").attr("class", "nv-legendWrap");
        var R = P.append("g").attr("class", "nv-focus");
        R.append("g").attr("class", "nv-x nv-axis"), R.append("g").attr("class", "nv-y nv-axis"), R.append("g").attr("class", "nv-linesWrap"), R.append("g").attr("class", "nv-interactive");
        var S = P.append("g").attr("class", "nv-context");
        S.append("g").attr("class", "nv-x nv-axis"), S.append("g").attr("class", "nv-y nv-axis"), S.append("g").attr("class", "nv-linesWrap"), S.append("g").attr("class", "nv-brushBackground"), S.append("g").attr("class", "nv-x nv-brush"), x && (m.width(K), Q.select(".nv-legendWrap").datum(o3).call(m), q.top != m.height() && (q.top = m.height(), L = a.utils.availableHeight(u, I, q) - v), Q.select(".nv-legendWrap").attr("transform", "translate(0," + -q.top + ")")), O.attr("transform", "translate(" + q.left + "," + q.top + ")"), w && (p.width(K).height(L).margin({ left: q.left, top: q.top }).svgContainer(I).xScale(c), O.select(".nv-interactive").call(p)), g.width(K).height(L).color(o3.map(function(a2, b2) {
          return a2.color || s(a2, b2);
        }).filter(function(a2, b2) {
          return !o3[b2].disabled;
        })), h.defined(g.defined()).width(K).height(M).color(o3.map(function(a2, b2) {
          return a2.color || s(a2, b2);
        }).filter(function(a2, b2) {
          return !o3[b2].disabled;
        })), Q.select(".nv-context").attr("transform", "translate(0," + (L + q.bottom + r.top) + ")");
        var T = Q.select(".nv-context .nv-linesWrap").datum(o3.filter(function(a2) {
          return !a2.disabled;
        }));
        d3.transition(T).call(h), i.scale(c)._ticks(a.utils.calcTicksX(K / 100, o3)).tickSize(-L, 0), j.scale(d)._ticks(a.utils.calcTicksY(L / 36, o3)).tickSize(-K, 0), Q.select(".nv-focus .nv-x.nv-axis").attr("transform", "translate(0," + L + ")"), n.x(e).on("brush", function() {
          H();
        }), y && n.extent(y);
        var U = Q.select(".nv-brushBackground").selectAll("g").data([y || n.extent()]), V = U.enter().append("g");
        V.append("rect").attr("class", "left").attr("x", 0).attr("y", 0).attr("height", M), V.append("rect").attr("class", "right").attr("x", 0).attr("y", 0).attr("height", M);
        var W = Q.select(".nv-x.nv-brush").call(n);
        W.selectAll("rect").attr("height", M), W.selectAll(".resize").append("path").attr("d", z2), H(), k.scale(e)._ticks(a.utils.calcTicksX(K / 100, o3)).tickSize(-M, 0), Q.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + f.range()[0] + ")"), d3.transition(Q.select(".nv-context .nv-x.nv-axis")).call(k), l.scale(f)._ticks(a.utils.calcTicksY(M / 36, o3)).tickSize(-K, 0), d3.transition(Q.select(".nv-context .nv-y.nv-axis")).call(l), Q.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + f.range()[0] + ")"), m.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) C[c2] = a2[c2];
          A.stateChange(C), b.update();
        }), p.dispatch.on("elementMousemove", function(c2) {
          g.clearHighlights();
          var d2, f2, h2, k2 = [];
          if (o3.filter(function(a2, b2) {
            return a2.seriesIndex = b2, !a2.disabled;
          }).forEach(function(i2, j2) {
            var l3 = n.empty() ? e.domain() : n.extent(), m3 = i2.values.filter(function(a2, b2) {
              return g.x()(a2, b2) >= l3[0] && g.x()(a2, b2) <= l3[1];
            });
            f2 = a.interactiveBisect(m3, c2.pointXValue, g.x());
            var o4 = m3[f2], p2 = b.y()(o4, f2);
            null != p2 && g.highlightPoint(j2, f2, true), void 0 !== o4 && (void 0 === d2 && (d2 = o4), void 0 === h2 && (h2 = b.xScale()(b.x()(o4, f2))), k2.push({ key: i2.key, value: b.y()(o4, f2), color: s(i2, i2.seriesIndex) }));
          }), k2.length > 2) {
            var l2 = b.yScale().invert(c2.mouseY), m2 = Math.abs(b.yScale().domain()[0] - b.yScale().domain()[1]), q2 = 0.03 * m2, r2 = a.nearestValueIndex(k2.map(function(a2) {
              return a2.value;
            }), l2, q2);
            null !== r2 && (k2[r2].highlight = true);
          }
          var t2 = i.tickFormat()(b.x()(d2, f2));
          p.tooltip.chartContainer(J.parentNode).valueFormatter(function(a2, b2) {
            return null == a2 ? "N/A" : j.tickFormat()(a2);
          }).data({ value: t2, index: f2, series: k2 })(), p.renderGuideLine(h2);
        }), p.dispatch.on("elementMouseout", function(a2) {
          g.clearHighlights();
        }), A.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && o3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), b.update();
        });
      }), b;
    }
    var c, d, e, f, g = a.models.line(), h = a.models.line(), i = a.models.axis(), j = a.models.axis(), k = a.models.axis(), l = a.models.axis(), m = a.models.legend(), n = d3.svg.brush(), o = a.models.tooltip(), p = a.interactiveGuideline(), q = { top: 30, right: 30, bottom: 30, left: 60 }, r = { top: 0, right: 30, bottom: 20, left: 60 }, s = a.utils.defaultColor(), t = null, u = null, v = 50, w = false, x = true, y = null, z = null, A = d3.dispatch("brush", "stateChange", "changeState"), B = 250, C = a.utils.state(), D = null;
    g.clipEdge(true).duration(0), h.interactive(false), h.pointActive(function(a2) {
      return false;
    }), i.orient("bottom").tickPadding(5), j.orient("left"), k.orient("bottom").tickPadding(5), l.orient("left"), o.valueFormatter(function(a2, b2) {
      return j.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return i.tickFormat()(a2, b2);
    });
    var E = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }) };
      };
    }, F = function(a2) {
      return function(b2) {
        void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    return g.dispatch.on("elementMouseover.tooltip", function(a2) {
      o.data(a2).hidden(false);
    }), g.dispatch.on("elementMouseout.tooltip", function(a2) {
      o.hidden(true);
    }), b.dispatch = A, b.legend = m, b.lines = g, b.lines2 = h, b.xAxis = i, b.yAxis = j, b.x2Axis = k, b.y2Axis = l, b.interactiveLayer = p, b.tooltip = o, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, height: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, focusHeight: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, showLegend: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, brushExtent: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, defaultState: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2;
    } }, noData: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, margin: { get: function() {
      return q;
    }, set: function(a2) {
      q.top = void 0 !== a2.top ? a2.top : q.top, q.right = void 0 !== a2.right ? a2.right : q.right, q.bottom = void 0 !== a2.bottom ? a2.bottom : q.bottom, q.left = void 0 !== a2.left ? a2.left : q.left;
    } }, focusMargin: { get: function() {
      return r;
    }, set: function(a2) {
      r.top = void 0 !== a2.top ? a2.top : r.top, r.right = void 0 !== a2.right ? a2.right : r.right, r.bottom = void 0 !== a2.bottom ? a2.bottom : r.bottom, r.left = void 0 !== a2.left ? a2.left : r.left;
    } }, color: { get: function() {
      return s;
    }, set: function(b2) {
      s = a.utils.getColor(b2), m.color(s);
    } }, interpolate: { get: function() {
      return g.interpolate();
    }, set: function(a2) {
      g.interpolate(a2), h.interpolate(a2);
    } }, xTickFormat: { get: function() {
      return i.tickFormat();
    }, set: function(a2) {
      i.tickFormat(a2), k.tickFormat(a2);
    } }, yTickFormat: { get: function() {
      return j.tickFormat();
    }, set: function(a2) {
      j.tickFormat(a2), l.tickFormat(a2);
    } }, duration: { get: function() {
      return B;
    }, set: function(a2) {
      B = a2, j.duration(B), l.duration(B), i.duration(B), k.duration(B);
    } }, x: { get: function() {
      return g.x();
    }, set: function(a2) {
      g.x(a2), h.x(a2);
    } }, y: { get: function() {
      return g.y();
    }, set: function(a2) {
      g.y(a2), h.y(a2);
    } }, useInteractiveGuideline: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2, w && (g.interactive(false), g.useVoronoi(false));
    } } }), a.utils.inheritOptions(b, g), a.utils.initOptions(b), b;
  }, a.models.multiBar = function() {
    "use strict";
    function b(E) {
      return C.reset(), E.each(function(b2) {
        var E2 = k - j.left - j.right, F = l - j.top - j.bottom;
        p = d3.select(this), a.utils.initSVG(p);
        var G = 0;
        if (x && b2.length && (x = [{ values: b2[0].values.map(function(a2) {
          return { x: a2.x, y: 0, series: a2.series, size: 0.01 };
        }) }]), u) {
          var H = d3.layout.stack().offset(v).values(function(a2) {
            return a2.values;
          }).y(r)(!b2.length && x ? x : b2);
          H.forEach(function(a2, c2) {
            a2.nonStackable ? (b2[c2].nonStackableSeries = G++, H[c2] = b2[c2]) : c2 > 0 && H[c2 - 1].nonStackable && H[c2].values.map(function(a3, b3) {
              a3.y0 -= H[c2 - 1].values[b3].y, a3.y1 = a3.y0 + a3.y;
            });
          }), b2 = H;
        }
        b2.forEach(function(a2, b3) {
          a2.values.forEach(function(c2) {
            c2.series = b3, c2.key = a2.key;
          });
        }), u && b2[0].values.map(function(a2, c2) {
          var d2 = 0, e2 = 0;
          b2.map(function(a3, f2) {
            if (!b2[f2].nonStackable) {
              var g2 = a3.values[c2];
              g2.size = Math.abs(g2.y), g2.y < 0 ? (g2.y1 = e2, e2 -= g2.size) : (g2.y1 = g2.size + d2, d2 += g2.size);
            }
          });
        });
        var I = d && e ? [] : b2.map(function(a2, b3) {
          return a2.values.map(function(a3, c2) {
            return { x: q(a3, c2), y: r(a3, c2), y0: a3.y0, y1: a3.y1, idx: b3 };
          });
        });
        m.domain(d || d3.merge(I).map(function(a2) {
          return a2.x;
        })).rangeBands(f || [0, E2], A), n.domain(e || d3.extent(d3.merge(I).map(function(a2) {
          var c2 = a2.y;
          return u && !b2[a2.idx].nonStackable && (c2 = a2.y > 0 ? a2.y1 : a2.y1 + a2.y), c2;
        }).concat(s))).range(g || [F, 0]), m.domain()[0] === m.domain()[1] && (m.domain()[0] ? m.domain([m.domain()[0] - 0.01 * m.domain()[0], m.domain()[1] + 0.01 * m.domain()[1]]) : m.domain([-1, 1])), n.domain()[0] === n.domain()[1] && (n.domain()[0] ? n.domain([n.domain()[0] + 0.01 * n.domain()[0], n.domain()[1] - 0.01 * n.domain()[1]]) : n.domain([-1, 1])), h = h || m, i = i || n;
        var J = p.selectAll("g.nv-wrap.nv-multibar").data([b2]), K = J.enter().append("g").attr("class", "nvd3 nv-wrap nv-multibar"), L = K.append("defs"), M = K.append("g"), N = J.select("g");
        M.append("g").attr("class", "nv-groups"), J.attr("transform", "translate(" + j.left + "," + j.top + ")"), L.append("clipPath").attr("id", "nv-edge-clip-" + o).append("rect"), J.select("#nv-edge-clip-" + o + " rect").attr("width", E2).attr("height", F), N.attr("clip-path", t ? "url(#nv-edge-clip-" + o + ")" : "");
        var O = J.select(".nv-groups").selectAll(".nv-group").data(function(a2) {
          return a2;
        }, function(a2, b3) {
          return b3;
        });
        O.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
        var P = C.transition(O.exit().selectAll("rect.nv-bar"), "multibarExit", Math.min(100, z)).attr("y", function(a2, c2, d2) {
          var e2 = i(0) || 0;
          return u && b2[a2.series] && !b2[a2.series].nonStackable && (e2 = i(a2.y0)), e2;
        }).attr("height", 0).remove();
        P.delay && P.delay(function(a2, b3) {
          var c2 = b3 * (z / (D + 1)) - b3;
          return c2;
        }), O.attr("class", function(a2, b3) {
          return "nv-group nv-series-" + b3;
        }).classed("hover", function(a2) {
          return a2.hover;
        }).style("fill", function(a2, b3) {
          return w(a2, b3);
        }).style("stroke", function(a2, b3) {
          return w(a2, b3);
        }), O.style("stroke-opacity", 1).style("fill-opacity", 0.75);
        var Q = O.selectAll("rect.nv-bar").data(function(a2) {
          return x && !b2.length ? x.values : a2.values;
        });
        Q.exit().remove();
        Q.enter().append("rect").attr("class", function(a2, b3) {
          return r(a2, b3) < 0 ? "nv-bar negative" : "nv-bar positive";
        }).attr("x", function(a2, c2, d2) {
          return u && !b2[d2].nonStackable ? 0 : d2 * m.rangeBand() / b2.length;
        }).attr("y", function(a2, c2, d2) {
          return i(u && !b2[d2].nonStackable ? a2.y0 : 0) || 0;
        }).attr("height", 0).attr("width", function(a2, c2, d2) {
          return m.rangeBand() / (u && !b2[d2].nonStackable ? 1 : b2.length);
        }).attr("transform", function(a2, b3) {
          return "translate(" + m(q(a2, b3)) + ",0)";
        });
        Q.style("fill", function(a2, b3, c2) {
          return w(a2, c2, b3);
        }).style("stroke", function(a2, b3, c2) {
          return w(a2, c2, b3);
        }).on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), B.elementMouseover({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), B.elementMouseout({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mousemove", function(a2, b3) {
          B.elementMousemove({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("click", function(a2, b3) {
          B.elementClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        }).on("dblclick", function(a2, b3) {
          B.elementDblClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        }), Q.attr("class", function(a2, b3) {
          return r(a2, b3) < 0 ? "nv-bar negative" : "nv-bar positive";
        }).attr("transform", function(a2, b3) {
          return "translate(" + m(q(a2, b3)) + ",0)";
        }), y && (c || (c = b2.map(function() {
          return true;
        })), Q.style("fill", function(a2, b3, d2) {
          return d3.rgb(y(a2, b3)).darker(c.map(function(a3, b4) {
            return b4;
          }).filter(function(a3, b4) {
            return !c[b4];
          })[d2]).toString();
        }).style("stroke", function(a2, b3, d2) {
          return d3.rgb(y(a2, b3)).darker(c.map(function(a3, b4) {
            return b4;
          }).filter(function(a3, b4) {
            return !c[b4];
          })[d2]).toString();
        }));
        var R = Q.watchTransition(C, "multibar", Math.min(250, z)).delay(function(a2, c2) {
          return c2 * z / b2[0].values.length;
        });
        u ? R.attr("y", function(a2, c2, d2) {
          var e2 = 0;
          return e2 = b2[d2].nonStackable ? r(a2, c2) < 0 ? n(0) : n(0) - n(r(a2, c2)) < -1 ? n(0) - 1 : n(r(a2, c2)) || 0 : n(a2.y1);
        }).attr("height", function(a2, c2, d2) {
          return b2[d2].nonStackable ? Math.max(Math.abs(n(r(a2, c2)) - n(0)), 0) || 0 : Math.max(Math.abs(n(a2.y + a2.y0) - n(a2.y0)), 0);
        }).attr("x", function(a2, c2, d2) {
          var e2 = 0;
          return b2[d2].nonStackable && (e2 = a2.series * m.rangeBand() / b2.length, b2.length !== G && (e2 = b2[d2].nonStackableSeries * m.rangeBand() / (2 * G))), e2;
        }).attr("width", function(a2, c2, d2) {
          if (b2[d2].nonStackable) {
            var e2 = m.rangeBand() / G;
            return b2.length !== G && (e2 = m.rangeBand() / (2 * G)), e2;
          }
          return m.rangeBand();
        }) : R.attr("x", function(a2, c2) {
          return a2.series * m.rangeBand() / b2.length;
        }).attr("width", m.rangeBand() / b2.length).attr("y", function(a2, b3) {
          return r(a2, b3) < 0 ? n(0) : n(0) - n(r(a2, b3)) < 1 ? n(0) - 1 : n(r(a2, b3)) || 0;
        }).attr("height", function(a2, b3) {
          return Math.max(Math.abs(n(r(a2, b3)) - n(0)), 1) || 0;
        }), h = m.copy(), i = n.copy(), b2[0] && b2[0].values && (D = b2[0].values.length);
      }), C.renderEnd("multibar immediate"), b;
    }
    var c, d, e, f, g, h, i, j = { top: 0, right: 0, bottom: 0, left: 0 }, k = 960, l = 500, m = d3.scale.ordinal(), n = d3.scale.linear(), o = Math.floor(1e4 * Math.random()), p = null, q = function(a2) {
      return a2.x;
    }, r = function(a2) {
      return a2.y;
    }, s = [0], t = true, u = false, v = "zero", w = a.utils.defaultColor(), x = false, y = null, z = 500, A = 0.1, B = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), C = a.utils.renderWatch(B, z), D = 0;
    return b.dispatch = B, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, height: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, x: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, y: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, xScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, yScale: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, xDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, yDomain: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, xRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, yRange: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, forceY: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, stacked: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, stackOffset: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, clipEdge: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, disabled: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, id: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, hideable: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, groupSpacing: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, margin: { get: function() {
      return j;
    }, set: function(a2) {
      j.top = void 0 !== a2.top ? a2.top : j.top, j.right = void 0 !== a2.right ? a2.right : j.right, j.bottom = void 0 !== a2.bottom ? a2.bottom : j.bottom, j.left = void 0 !== a2.left ? a2.left : j.left;
    } }, duration: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2, C.reset(z);
    } }, color: { get: function() {
      return w;
    }, set: function(b2) {
      w = a.utils.getColor(b2);
    } }, barColor: { get: function() {
      return y;
    }, set: function(b2) {
      y = b2 ? a.utils.getColor(b2) : null;
    } } }), a.utils.initOptions(b), b;
  }, a.models.multiBarChart = function() {
    "use strict";
    function b(j2) {
      return E.reset(), E.models(e), r && E.models(f), s && E.models(g), j2.each(function(j3) {
        var A2 = d3.select(this);
        a.utils.initSVG(A2);
        var E2 = a.utils.availableWidth(l, A2, k), I = a.utils.availableHeight(m, A2, k);
        if (b.update = function() {
          0 === D ? A2.call(b) : A2.transition().duration(D).call(b);
        }, b.container = this, y.setter(H(j3), b.update).getter(G(j3)).update(), y.disabled = j3.map(function(a2) {
          return !!a2.disabled;
        }), !z) {
          var J;
          z = {};
          for (J in y) y[J] instanceof Array ? z[J] = y[J].slice(0) : z[J] = y[J];
        }
        if (!(j3 && j3.length && j3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, A2), b;
        A2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale();
        var K = A2.selectAll("g.nv-wrap.nv-multiBarWithLegend").data([j3]), L = K.enter().append("g").attr("class", "nvd3 nv-wrap nv-multiBarWithLegend").append("g"), M = K.select("g");
        if (L.append("g").attr("class", "nv-x nv-axis"), L.append("g").attr("class", "nv-y nv-axis"), L.append("g").attr("class", "nv-barsWrap"), L.append("g").attr("class", "nv-legendWrap"), L.append("g").attr("class", "nv-controlsWrap"), q && (h.width(E2 - C()), M.select(".nv-legendWrap").datum(j3).call(h), k.top != h.height() && (k.top = h.height(), I = a.utils.availableHeight(m, A2, k)), M.select(".nv-legendWrap").attr("transform", "translate(" + C() + "," + -k.top + ")")), o) {
          var N = [{ key: p.grouped || "Grouped", disabled: e.stacked() }, { key: p.stacked || "Stacked", disabled: !e.stacked() }];
          i.width(C()).color(["#444", "#444", "#444"]), M.select(".nv-controlsWrap").datum(N).attr("transform", "translate(0," + -k.top + ")").call(i);
        }
        K.attr("transform", "translate(" + k.left + "," + k.top + ")"), t && M.select(".nv-y.nv-axis").attr("transform", "translate(" + E2 + ",0)"), e.disabled(j3.map(function(a2) {
          return a2.disabled;
        })).width(E2).height(I).color(j3.map(function(a2, b2) {
          return a2.color || n(a2, b2);
        }).filter(function(a2, b2) {
          return !j3[b2].disabled;
        }));
        var O = M.select(".nv-barsWrap").datum(j3.filter(function(a2) {
          return !a2.disabled;
        }));
        if (O.call(e), r) {
          f.scale(c)._ticks(a.utils.calcTicksX(E2 / 100, j3)).tickSize(-I, 0), M.select(".nv-x.nv-axis").attr("transform", "translate(0," + d.range()[0] + ")"), M.select(".nv-x.nv-axis").call(f);
          var P = M.select(".nv-x.nv-axis > g").selectAll("g");
          if (P.selectAll("line, text").style("opacity", 1), v) {
            var Q = function(a2, b2) {
              return "translate(" + a2 + "," + b2 + ")";
            }, R = 5, S = 17;
            P.selectAll("text").attr("transform", function(a2, b2, c2) {
              return Q(0, c2 % 2 == 0 ? R : S);
            });
            var T = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
            M.selectAll(".nv-x.nv-axis .nv-axisMaxMin text").attr("transform", function(a2, b2) {
              return Q(0, 0 === b2 || T % 2 !== 0 ? S : R);
            });
          }
          w && M.selectAll(".tick text").call(a.utils.wrapTicks, b.xAxis.rangeBand()), u && P.filter(function(a2, b2) {
            return b2 % Math.ceil(j3[0].values.length / (E2 / 100)) !== 0;
          }).selectAll("text, line").style("opacity", 0), x && P.selectAll(".tick text").attr("transform", "rotate(" + x + " 0,0)").style("text-anchor", x > 0 ? "start" : "end"), M.select(".nv-x.nv-axis").selectAll("g.nv-axisMaxMin text").style("opacity", 1);
        }
        s && (g.scale(d)._ticks(a.utils.calcTicksY(I / 36, j3)).tickSize(-E2, 0), M.select(".nv-y.nv-axis").call(g)), h.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) y[c2] = a2[c2];
          B.stateChange(y), b.update();
        }), i.dispatch.on("legendClick", function(a2, c2) {
          if (a2.disabled) {
            switch (N = N.map(function(a3) {
              return a3.disabled = true, a3;
            }), a2.disabled = false, a2.key) {
              case "Grouped":
              case p.grouped:
                e.stacked(false);
                break;
              case "Stacked":
              case p.stacked:
                e.stacked(true);
            }
            y.stacked = e.stacked(), B.stateChange(y), b.update();
          }
        }), B.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (j3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), y.disabled = a2.disabled), "undefined" != typeof a2.stacked && (e.stacked(a2.stacked), y.stacked = a2.stacked, F = a2.stacked), b.update();
        });
      }), E.renderEnd("multibarchart immediate"), b;
    }
    var c, d, e = a.models.multiBar(), f = a.models.axis(), g = a.models.axis(), h = a.models.legend(), i = a.models.legend(), j = a.models.tooltip(), k = { top: 30, right: 20, bottom: 50, left: 60 }, l = null, m = null, n = a.utils.defaultColor(), o = true, p = {}, q = true, r = true, s = true, t = false, u = true, v = false, w = false, x = 0, y = a.utils.state(), z = null, A = null, B = d3.dispatch("stateChange", "changeState", "renderEnd"), C = function() {
      return o ? 180 : 0;
    }, D = 250;
    y.stacked = false, e.stacked(false), f.orient("bottom").tickPadding(7).showMaxMin(false).tickFormat(function(a2) {
      return a2;
    }), g.orient(t ? "right" : "left").tickFormat(d3.format(",.1f")), j.duration(0).valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    }), i.updateState(false);
    var E = a.utils.renderWatch(B), F = false, G = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }), stacked: F };
      };
    }, H = function(a2) {
      return function(b2) {
        void 0 !== b2.stacked && (F = b2.stacked), void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.value = b.x()(a2.data), a2.series = { key: a2.data.key, value: b.y()(a2.data), color: a2.color }, j.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      j.hidden(true);
    }), e.dispatch.on("elementMousemove.tooltip", function(a2) {
      j();
    }), b.dispatch = B, b.multibar = e, b.legend = h, b.controls = i, b.xAxis = f, b.yAxis = g, b.state = y, b.tooltip = j, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, height: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, showLegend: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, showControls: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, controlLabels: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, showXAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showYAxis: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, defaultState: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, noData: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, reduceXTicks: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, rotateLabels: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, staggerLabels: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, wrapLabels: { get: function() {
      return w;
    }, set: function(a2) {
      w = !!a2;
    } }, margin: { get: function() {
      return k;
    }, set: function(a2) {
      k.top = void 0 !== a2.top ? a2.top : k.top, k.right = void 0 !== a2.right ? a2.right : k.right, k.bottom = void 0 !== a2.bottom ? a2.bottom : k.bottom, k.left = void 0 !== a2.left ? a2.left : k.left;
    } }, duration: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2, e.duration(D), f.duration(D), g.duration(D), E.reset(D);
    } }, color: { get: function() {
      return n;
    }, set: function(b2) {
      n = a.utils.getColor(b2), h.color(n);
    } }, rightAlignYAxis: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2, g.orient(t ? "right" : "left");
    } }, barColor: { get: function() {
      return e.barColor;
    }, set: function(a2) {
      e.barColor(a2), h.color(function(a3, b2) {
        return d3.rgb("#ccc").darker(1.5 * b2).toString();
      });
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.multiBarHorizontal = function() {
    "use strict";
    function b(m2) {
      return E.reset(), m2.each(function(b2) {
        var m3 = k - j.left - j.right, C2 = l - j.top - j.bottom;
        n = d3.select(this), a.utils.initSVG(n), w && (b2 = d3.layout.stack().offset("zero").values(function(a2) {
          return a2.values;
        }).y(r)(b2)), b2.forEach(function(a2, b3) {
          a2.values.forEach(function(c2) {
            c2.series = b3, c2.key = a2.key;
          });
        }), w && b2[0].values.map(function(a2, c2) {
          var d2 = 0, e2 = 0;
          b2.map(function(a3) {
            var b3 = a3.values[c2];
            b3.size = Math.abs(b3.y), b3.y < 0 ? (b3.y1 = e2 - b3.size, e2 -= b3.size) : (b3.y1 = d2, d2 += b3.size);
          });
        });
        var F = d && e ? [] : b2.map(function(a2) {
          return a2.values.map(function(a3, b3) {
            return { x: q(a3, b3), y: r(a3, b3), y0: a3.y0, y1: a3.y1 };
          });
        });
        o.domain(d || d3.merge(F).map(function(a2) {
          return a2.x;
        })).rangeBands(f || [0, C2], A), p.domain(e || d3.extent(d3.merge(F).map(function(a2) {
          return w ? a2.y > 0 ? a2.y1 + a2.y : a2.y1 : a2.y;
        }).concat(t))), x && !w ? p.range(g || [p.domain()[0] < 0 ? z : 0, m3 - (p.domain()[1] > 0 ? z : 0)]) : p.range(g || [0, m3]), h = h || o, i = i || d3.scale.linear().domain(p.domain()).range([p(0), p(0)]);
        var G = d3.select(this).selectAll("g.nv-wrap.nv-multibarHorizontal").data([b2]), H = G.enter().append("g").attr("class", "nvd3 nv-wrap nv-multibarHorizontal"), I = (H.append("defs"), H.append("g"));
        G.select("g");
        I.append("g").attr("class", "nv-groups"), G.attr("transform", "translate(" + j.left + "," + j.top + ")");
        var J = G.select(".nv-groups").selectAll(".nv-group").data(function(a2) {
          return a2;
        }, function(a2, b3) {
          return b3;
        });
        J.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6), J.exit().watchTransition(E, "multibarhorizontal: exit groups").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove(), J.attr("class", function(a2, b3) {
          return "nv-group nv-series-" + b3;
        }).classed("hover", function(a2) {
          return a2.hover;
        }).style("fill", function(a2, b3) {
          return u(a2, b3);
        }).style("stroke", function(a2, b3) {
          return u(a2, b3);
        }), J.watchTransition(E, "multibarhorizontal: groups").style("stroke-opacity", 1).style("fill-opacity", 0.75);
        var K = J.selectAll("g.nv-bar").data(function(a2) {
          return a2.values;
        });
        K.exit().remove();
        var L = K.enter().append("g").attr("transform", function(a2, c2, d2) {
          return "translate(" + i(w ? a2.y0 : 0) + "," + (w ? 0 : d2 * o.rangeBand() / b2.length + o(q(a2, c2))) + ")";
        });
        L.append("rect").attr("width", 0).attr("height", o.rangeBand() / (w ? 1 : b2.length)), K.on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), D.elementMouseover({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), D.elementMouseout({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          D.elementMouseout({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("mousemove", function(a2, b3) {
          D.elementMousemove({ data: a2, index: b3, color: d3.select(this).style("fill") });
        }).on("click", function(a2, b3) {
          D.elementClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        }).on("dblclick", function(a2, b3) {
          D.elementDblClick({ data: a2, index: b3, color: d3.select(this).style("fill") }), d3.event.stopPropagation();
        }), s(b2[0], 0) && (L.append("polyline"), K.select("polyline").attr("fill", "none").attr("points", function(a2, c2) {
          var d2 = s(a2, c2), e2 = 0.8 * o.rangeBand() / (2 * (w ? 1 : b2.length));
          d2 = d2.length ? d2 : [-Math.abs(d2), Math.abs(d2)], d2 = d2.map(function(a3) {
            return p(a3) - p(0);
          });
          var f2 = [[d2[0], -e2], [d2[0], e2], [d2[0], 0], [d2[1], 0], [d2[1], -e2], [d2[1], e2]];
          return f2.map(function(a3) {
            return a3.join(",");
          }).join(" ");
        }).attr("transform", function(a2, c2) {
          var d2 = o.rangeBand() / (2 * (w ? 1 : b2.length));
          return "translate(" + (r(a2, c2) < 0 ? 0 : p(r(a2, c2)) - p(0)) + ", " + d2 + ")";
        })), L.append("text"), x && !w ? (K.select("text").attr("text-anchor", function(a2, b3) {
          return r(a2, b3) < 0 ? "end" : "start";
        }).attr("y", o.rangeBand() / (2 * b2.length)).attr("dy", ".32em").text(function(a2, b3) {
          var c2 = B(r(a2, b3)), d2 = s(a2, b3);
          return void 0 === d2 ? c2 : d2.length ? c2 + "+" + B(Math.abs(d2[1])) + "-" + B(Math.abs(d2[0])) : c2 + "\xB1" + B(Math.abs(d2));
        }), K.watchTransition(E, "multibarhorizontal: bars").select("text").attr("x", function(a2, b3) {
          return r(a2, b3) < 0 ? -4 : p(r(a2, b3)) - p(0) + 4;
        })) : K.selectAll("text").text(""), y && !w ? (L.append("text").classed("nv-bar-label", true), K.select("text.nv-bar-label").attr("text-anchor", function(a2, b3) {
          return r(a2, b3) < 0 ? "start" : "end";
        }).attr("y", o.rangeBand() / (2 * b2.length)).attr("dy", ".32em").text(function(a2, b3) {
          return q(a2, b3);
        }), K.watchTransition(E, "multibarhorizontal: bars").select("text.nv-bar-label").attr("x", function(a2, b3) {
          return r(a2, b3) < 0 ? p(0) - p(r(a2, b3)) + 4 : -4;
        })) : K.selectAll("text.nv-bar-label").text(""), K.attr("class", function(a2, b3) {
          return r(a2, b3) < 0 ? "nv-bar negative" : "nv-bar positive";
        }), v && (c || (c = b2.map(function() {
          return true;
        })), K.style("fill", function(a2, b3, d2) {
          return d3.rgb(v(a2, b3)).darker(c.map(function(a3, b4) {
            return b4;
          }).filter(function(a3, b4) {
            return !c[b4];
          })[d2]).toString();
        }).style("stroke", function(a2, b3, d2) {
          return d3.rgb(v(a2, b3)).darker(c.map(function(a3, b4) {
            return b4;
          }).filter(function(a3, b4) {
            return !c[b4];
          })[d2]).toString();
        })), w ? K.watchTransition(E, "multibarhorizontal: bars").attr("transform", function(a2, b3) {
          return "translate(" + p(a2.y1) + "," + o(q(a2, b3)) + ")";
        }).select("rect").attr("width", function(a2, b3) {
          return Math.abs(p(r(a2, b3) + a2.y0) - p(a2.y0)) || 0;
        }).attr("height", o.rangeBand()) : K.watchTransition(E, "multibarhorizontal: bars").attr("transform", function(a2, c2) {
          return "translate(" + p(r(a2, c2) < 0 ? r(a2, c2) : 0) + "," + (a2.series * o.rangeBand() / b2.length + o(q(a2, c2))) + ")";
        }).select("rect").attr("height", o.rangeBand() / b2.length).attr("width", function(a2, b3) {
          return Math.max(Math.abs(p(r(a2, b3)) - p(0)), 1) || 0;
        }), h = o.copy(), i = p.copy();
      }), E.renderEnd("multibarHorizontal immediate"), b;
    }
    var c, d, e, f, g, h, i, j = { top: 0, right: 0, bottom: 0, left: 0 }, k = 960, l = 500, m = Math.floor(1e4 * Math.random()), n = null, o = d3.scale.ordinal(), p = d3.scale.linear(), q = function(a2) {
      return a2.x;
    }, r = function(a2) {
      return a2.y;
    }, s = function(a2) {
      return a2.yErr;
    }, t = [0], u = a.utils.defaultColor(), v = null, w = false, x = false, y = false, z = 60, A = 0.1, B = d3.format(",.2f"), C = 250, D = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), E = a.utils.renderWatch(D, C);
    return b.dispatch = D, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, height: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, x: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, y: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, yErr: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, xScale: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, yScale: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, xDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, yDomain: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, xRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, yRange: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, forceY: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, stacked: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, showValues: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, disabled: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, id: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, valueFormat: { get: function() {
      return B;
    }, set: function(a2) {
      B = a2;
    } }, valuePadding: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, groupSpacing: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, margin: { get: function() {
      return j;
    }, set: function(a2) {
      j.top = void 0 !== a2.top ? a2.top : j.top, j.right = void 0 !== a2.right ? a2.right : j.right, j.bottom = void 0 !== a2.bottom ? a2.bottom : j.bottom, j.left = void 0 !== a2.left ? a2.left : j.left;
    } }, duration: { get: function() {
      return C;
    }, set: function(a2) {
      C = a2, E.reset(C);
    } }, color: { get: function() {
      return u;
    }, set: function(b2) {
      u = a.utils.getColor(b2);
    } }, barColor: { get: function() {
      return v;
    }, set: function(b2) {
      v = b2 ? a.utils.getColor(b2) : null;
    } } }), a.utils.initOptions(b), b;
  }, a.models.multiBarHorizontalChart = function() {
    "use strict";
    function b(j2) {
      return C.reset(), C.models(e), r && C.models(f), s && C.models(g), j2.each(function(j3) {
        var w2 = d3.select(this);
        a.utils.initSVG(w2);
        var C2 = a.utils.availableWidth(l, w2, k), D = a.utils.availableHeight(m, w2, k);
        if (b.update = function() {
          w2.transition().duration(z).call(b);
        }, b.container = this, t = e.stacked(), u.setter(B(j3), b.update).getter(A(j3)).update(), u.disabled = j3.map(function(a2) {
          return !!a2.disabled;
        }), !v) {
          var E;
          v = {};
          for (E in u) u[E] instanceof Array ? v[E] = u[E].slice(0) : v[E] = u[E];
        }
        if (!(j3 && j3.length && j3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, w2), b;
        w2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale();
        var F = w2.selectAll("g.nv-wrap.nv-multiBarHorizontalChart").data([j3]), G = F.enter().append("g").attr("class", "nvd3 nv-wrap nv-multiBarHorizontalChart").append("g"), H = F.select("g");
        if (G.append("g").attr("class", "nv-x nv-axis"), G.append("g").attr("class", "nv-y nv-axis").append("g").attr("class", "nv-zeroLine").append("line"), G.append("g").attr("class", "nv-barsWrap"), G.append("g").attr("class", "nv-legendWrap"), G.append("g").attr("class", "nv-controlsWrap"), q && (h.width(C2 - y()), H.select(".nv-legendWrap").datum(j3).call(h), k.top != h.height() && (k.top = h.height(), D = a.utils.availableHeight(m, w2, k)), H.select(".nv-legendWrap").attr("transform", "translate(" + y() + "," + -k.top + ")")), o) {
          var I = [{ key: p.grouped || "Grouped", disabled: e.stacked() }, { key: p.stacked || "Stacked", disabled: !e.stacked() }];
          i.width(y()).color(["#444", "#444", "#444"]), H.select(".nv-controlsWrap").datum(I).attr("transform", "translate(0," + -k.top + ")").call(i);
        }
        F.attr("transform", "translate(" + k.left + "," + k.top + ")"), e.disabled(j3.map(function(a2) {
          return a2.disabled;
        })).width(C2).height(D).color(j3.map(function(a2, b2) {
          return a2.color || n(a2, b2);
        }).filter(function(a2, b2) {
          return !j3[b2].disabled;
        }));
        var J = H.select(".nv-barsWrap").datum(j3.filter(function(a2) {
          return !a2.disabled;
        }));
        if (J.transition().call(e), r) {
          f.scale(c)._ticks(a.utils.calcTicksY(D / 24, j3)).tickSize(-C2, 0), H.select(".nv-x.nv-axis").call(f);
          var K = H.select(".nv-x.nv-axis").selectAll("g");
          K.selectAll("line, text");
        }
        s && (g.scale(d)._ticks(a.utils.calcTicksX(C2 / 100, j3)).tickSize(-D, 0), H.select(".nv-y.nv-axis").attr("transform", "translate(0," + D + ")"), H.select(".nv-y.nv-axis").call(g)), H.select(".nv-zeroLine line").attr("x1", d(0)).attr("x2", d(0)).attr("y1", 0).attr("y2", -D), h.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) u[c2] = a2[c2];
          x.stateChange(u), b.update();
        }), i.dispatch.on("legendClick", function(a2, c2) {
          if (a2.disabled) {
            switch (I = I.map(function(a3) {
              return a3.disabled = true, a3;
            }), a2.disabled = false, a2.key) {
              case "Grouped":
                e.stacked(false);
                break;
              case "Stacked":
                e.stacked(true);
            }
            u.stacked = e.stacked(), x.stateChange(u), t = e.stacked(), b.update();
          }
        }), x.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (j3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), u.disabled = a2.disabled), "undefined" != typeof a2.stacked && (e.stacked(a2.stacked), u.stacked = a2.stacked, t = a2.stacked), b.update();
        });
      }), C.renderEnd("multibar horizontal chart immediate"), b;
    }
    var c, d, e = a.models.multiBarHorizontal(), f = a.models.axis(), g = a.models.axis(), h = a.models.legend().height(30), i = a.models.legend().height(30), j = a.models.tooltip(), k = { top: 30, right: 20, bottom: 50, left: 60 }, l = null, m = null, n = a.utils.defaultColor(), o = true, p = {}, q = true, r = true, s = true, t = false, u = a.utils.state(), v = null, w = null, x = d3.dispatch("stateChange", "changeState", "renderEnd"), y = function() {
      return o ? 180 : 0;
    }, z = 250;
    u.stacked = false, e.stacked(t), f.orient("left").tickPadding(5).showMaxMin(false).tickFormat(function(a2) {
      return a2;
    }), g.orient("bottom").tickFormat(d3.format(",.1f")), j.duration(0).valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }).headerFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    }), i.updateState(false);
    var A = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }), stacked: t };
      };
    }, B = function(a2) {
      return function(b2) {
        void 0 !== b2.stacked && (t = b2.stacked), void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    }, C = a.utils.renderWatch(x, z);
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.value = b.x()(a2.data), a2.series = { key: a2.data.key, value: b.y()(a2.data), color: a2.color }, j.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      j.hidden(true);
    }), e.dispatch.on("elementMousemove.tooltip", function(a2) {
      j();
    }), b.dispatch = x, b.multibar = e, b.legend = h, b.controls = i, b.xAxis = f, b.yAxis = g, b.state = u, b.tooltip = j, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, height: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, showLegend: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, showControls: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, controlLabels: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, showXAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showYAxis: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, defaultState: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, noData: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, margin: { get: function() {
      return k;
    }, set: function(a2) {
      k.top = void 0 !== a2.top ? a2.top : k.top, k.right = void 0 !== a2.right ? a2.right : k.right, k.bottom = void 0 !== a2.bottom ? a2.bottom : k.bottom, k.left = void 0 !== a2.left ? a2.left : k.left;
    } }, duration: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2, C.reset(z), e.duration(z), f.duration(z), g.duration(z);
    } }, color: { get: function() {
      return n;
    }, set: function(b2) {
      n = a.utils.getColor(b2), h.color(n);
    } }, barColor: { get: function() {
      return e.barColor;
    }, set: function(a2) {
      e.barColor(a2), h.color(function(a3, b2) {
        return d3.rgb("#ccc").darker(1.5 * b2).toString();
      });
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.multiChart = function() {
    "use strict";
    function b(j2) {
      return j2.each(function(j3) {
        function n2(a2) {
          var b2 = 2 === j3[a2.seriesIndex].yAxis ? B : A;
          a2.value = a2.point.x, a2.series = { value: a2.point.y, color: a2.point.color, key: a2.series.key }, D.duration(0).valueFormatter(function(a3, c2) {
            return b2.tickFormat()(a3, c2);
          }).data(a2).hidden(false);
        }
        function E2(a2) {
          var b2 = 2 === j3[a2.seriesIndex].yAxis ? B : A;
          a2.value = a2.point.x, a2.series = { value: a2.point.y, color: a2.point.color, key: a2.series.key }, D.duration(100).valueFormatter(function(a3, c2) {
            return b2.tickFormat()(a3, c2);
          }).data(a2).hidden(false);
        }
        function F(a2) {
          var b2 = 2 === j3[a2.seriesIndex].yAxis ? B : A;
          a2.point.x = x.x()(a2.point), a2.point.y = x.y()(a2.point), D.duration(0).valueFormatter(function(a3, c2) {
            return b2.tickFormat()(a3, c2);
          }).data(a2).hidden(false);
        }
        function G(a2) {
          var b2 = 2 === j3[a2.data.series].yAxis ? B : A;
          a2.value = v.x()(a2.data), a2.series = { value: v.y()(a2.data), color: a2.color, key: a2.data.key }, D.duration(0).valueFormatter(function(a3, c2) {
            return b2.tickFormat()(a3, c2);
          }).data(a2).hidden(false);
        }
        var H = d3.select(this);
        a.utils.initSVG(H), b.update = function() {
          H.transition().call(b);
        }, b.container = this;
        var I = a.utils.availableWidth(g, H, e), J = a.utils.availableHeight(h, H, e), K = j3.filter(function(a2) {
          return "line" == a2.type && 1 == a2.yAxis;
        }), L = j3.filter(function(a2) {
          return "line" == a2.type && 2 == a2.yAxis;
        }), M = j3.filter(function(a2) {
          return "scatter" == a2.type && 1 == a2.yAxis;
        }), N = j3.filter(function(a2) {
          return "scatter" == a2.type && 2 == a2.yAxis;
        }), O = j3.filter(function(a2) {
          return "bar" == a2.type && 1 == a2.yAxis;
        }), P = j3.filter(function(a2) {
          return "bar" == a2.type && 2 == a2.yAxis;
        }), Q = j3.filter(function(a2) {
          return "area" == a2.type && 1 == a2.yAxis;
        }), R = j3.filter(function(a2) {
          return "area" == a2.type && 2 == a2.yAxis;
        });
        if (!(j3 && j3.length && j3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, H), b;
        H.selectAll(".nv-noData").remove();
        var S = j3.filter(function(a2) {
          return !a2.disabled && 1 == a2.yAxis;
        }).map(function(a2) {
          return a2.values.map(function(a3, b2) {
            return { x: k(a3), y: l(a3) };
          });
        }), T = j3.filter(function(a2) {
          return !a2.disabled && 2 == a2.yAxis;
        }).map(function(a2) {
          return a2.values.map(function(a3, b2) {
            return { x: k(a3), y: l(a3) };
          });
        });
        o.domain(d3.extent(d3.merge(S.concat(T)), function(a2) {
          return k(a2);
        })).range([0, I]);
        var U = H.selectAll("g.wrap.multiChart").data([j3]), V = U.enter().append("g").attr("class", "wrap nvd3 multiChart").append("g");
        V.append("g").attr("class", "nv-x nv-axis"), V.append("g").attr("class", "nv-y1 nv-axis"), V.append("g").attr("class", "nv-y2 nv-axis"), V.append("g").attr("class", "lines1Wrap"), V.append("g").attr("class", "lines2Wrap"), V.append("g").attr("class", "scatters1Wrap"), V.append("g").attr("class", "scatters2Wrap"), V.append("g").attr("class", "bars1Wrap"), V.append("g").attr("class", "bars2Wrap"), V.append("g").attr("class", "stack1Wrap"), V.append("g").attr("class", "stack2Wrap"), V.append("g").attr("class", "legendWrap");
        var W = U.select("g"), X = j3.map(function(a2, b2) {
          return j3[b2].color || f(a2, b2);
        });
        if (i) {
          var Y = C.align() ? I / 2 : I, Z = C.align() ? Y : 0;
          C.width(Y), C.color(X), W.select(".legendWrap").datum(j3.map(function(a2) {
            return a2.originalKey = void 0 === a2.originalKey ? a2.key : a2.originalKey, a2.key = a2.originalKey + (1 == a2.yAxis ? "" : " (right axis)"), a2;
          })).call(C), e.top != C.height() && (e.top = C.height(), J = a.utils.availableHeight(h, H, e)), W.select(".legendWrap").attr("transform", "translate(" + Z + "," + -e.top + ")");
        }
        r.width(I).height(J).interpolate(m).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 1 == j3[b2].yAxis && "line" == j3[b2].type;
        })), s.width(I).height(J).interpolate(m).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 2 == j3[b2].yAxis && "line" == j3[b2].type;
        })), t.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 1 == j3[b2].yAxis && "scatter" == j3[b2].type;
        })), u.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 2 == j3[b2].yAxis && "scatter" == j3[b2].type;
        })), v.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 1 == j3[b2].yAxis && "bar" == j3[b2].type;
        })), w.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 2 == j3[b2].yAxis && "bar" == j3[b2].type;
        })), x.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 1 == j3[b2].yAxis && "area" == j3[b2].type;
        })), y.width(I).height(J).color(X.filter(function(a2, b2) {
          return !j3[b2].disabled && 2 == j3[b2].yAxis && "area" == j3[b2].type;
        })), W.attr("transform", "translate(" + e.left + "," + e.top + ")");
        var $ = W.select(".lines1Wrap").datum(K.filter(function(a2) {
          return !a2.disabled;
        })), _5 = W.select(".scatters1Wrap").datum(M.filter(function(a2) {
          return !a2.disabled;
        })), aa = W.select(".bars1Wrap").datum(O.filter(function(a2) {
          return !a2.disabled;
        })), ba = W.select(".stack1Wrap").datum(Q.filter(function(a2) {
          return !a2.disabled;
        })), ca = W.select(".lines2Wrap").datum(L.filter(function(a2) {
          return !a2.disabled;
        })), da = W.select(".scatters2Wrap").datum(N.filter(function(a2) {
          return !a2.disabled;
        })), ea = W.select(".bars2Wrap").datum(P.filter(function(a2) {
          return !a2.disabled;
        })), fa = W.select(".stack2Wrap").datum(R.filter(function(a2) {
          return !a2.disabled;
        })), ga = Q.length ? Q.map(function(a2) {
          return a2.values;
        }).reduce(function(a2, b2) {
          return a2.map(function(a3, c2) {
            return { x: a3.x, y: a3.y + b2[c2].y };
          });
        }).concat([{ x: 0, y: 0 }]) : [], ha = R.length ? R.map(function(a2) {
          return a2.values;
        }).reduce(function(a2, b2) {
          return a2.map(function(a3, c2) {
            return { x: a3.x, y: a3.y + b2[c2].y };
          });
        }).concat([{ x: 0, y: 0 }]) : [];
        p.domain(c || d3.extent(d3.merge(S).concat(ga), function(a2) {
          return a2.y;
        })).range([0, J]), q.domain(d || d3.extent(d3.merge(T).concat(ha), function(a2) {
          return a2.y;
        })).range([0, J]), r.yDomain(p.domain()), t.yDomain(p.domain()), v.yDomain(p.domain()), x.yDomain(p.domain()), s.yDomain(q.domain()), u.yDomain(q.domain()), w.yDomain(q.domain()), y.yDomain(q.domain()), Q.length && d3.transition(ba).call(x), R.length && d3.transition(fa).call(y), O.length && d3.transition(aa).call(v), P.length && d3.transition(ea).call(w), K.length && d3.transition($).call(r), L.length && d3.transition(ca).call(s), M.length && d3.transition(_5).call(t), N.length && d3.transition(da).call(u), z._ticks(a.utils.calcTicksX(I / 100, j3)).tickSize(-J, 0), W.select(".nv-x.nv-axis").attr("transform", "translate(0," + J + ")"), d3.transition(W.select(".nv-x.nv-axis")).call(z), A._ticks(a.utils.calcTicksY(J / 36, j3)).tickSize(-I, 0), d3.transition(W.select(".nv-y1.nv-axis")).call(A), B._ticks(a.utils.calcTicksY(J / 36, j3)).tickSize(-I, 0), d3.transition(W.select(".nv-y2.nv-axis")).call(B), W.select(".nv-y1.nv-axis").classed("nv-disabled", S.length ? false : true).attr("transform", "translate(" + o.range()[0] + ",0)"), W.select(".nv-y2.nv-axis").classed("nv-disabled", T.length ? false : true).attr("transform", "translate(" + o.range()[1] + ",0)"), C.dispatch.on("stateChange", function(a2) {
          b.update();
        }), r.dispatch.on("elementMouseover.tooltip", n2), s.dispatch.on("elementMouseover.tooltip", n2), r.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), s.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), t.dispatch.on("elementMouseover.tooltip", E2), u.dispatch.on("elementMouseover.tooltip", E2), t.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), u.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), x.dispatch.on("elementMouseover.tooltip", F), y.dispatch.on("elementMouseover.tooltip", F), x.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), y.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), v.dispatch.on("elementMouseover.tooltip", G), w.dispatch.on("elementMouseover.tooltip", G), v.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), w.dispatch.on("elementMouseout.tooltip", function(a2) {
          D.hidden(true);
        }), v.dispatch.on("elementMousemove.tooltip", function(a2) {
          D();
        }), w.dispatch.on("elementMousemove.tooltip", function(a2) {
          D();
        });
      }), b;
    }
    var c, d, e = { top: 30, right: 20, bottom: 50, left: 60 }, f = a.utils.defaultColor(), g = null, h = null, i = true, j = null, k = function(a2) {
      return a2.x;
    }, l = function(a2) {
      return a2.y;
    }, m = "monotone", n = true, o = d3.scale.linear(), p = d3.scale.linear(), q = d3.scale.linear(), r = a.models.line().yScale(p), s = a.models.line().yScale(q), t = a.models.scatter().yScale(p), u = a.models.scatter().yScale(q), v = a.models.multiBar().stacked(false).yScale(p), w = a.models.multiBar().stacked(false).yScale(q), x = a.models.stackedArea().yScale(p), y = a.models.stackedArea().yScale(q), z = a.models.axis().scale(o).orient("bottom").tickPadding(5), A = a.models.axis().scale(p).orient("left"), B = a.models.axis().scale(q).orient("right"), C = a.models.legend().height(30), D = a.models.tooltip(), E = d3.dispatch();
    return b.dispatch = E, b.legend = C, b.lines1 = r, b.lines2 = s, b.scatters1 = t, b.scatters2 = u, b.bars1 = v, b.bars2 = w, b.stack1 = x, b.stack2 = y, b.xAxis = z, b.yAxis1 = A, b.yAxis2 = B, b.tooltip = D, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, height: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, showLegend: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, yDomain1: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, yDomain2: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, noData: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, interpolate: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, margin: { get: function() {
      return e;
    }, set: function(a2) {
      e.top = void 0 !== a2.top ? a2.top : e.top, e.right = void 0 !== a2.right ? a2.right : e.right, e.bottom = void 0 !== a2.bottom ? a2.bottom : e.bottom, e.left = void 0 !== a2.left ? a2.left : e.left;
    } }, color: { get: function() {
      return f;
    }, set: function(b2) {
      f = a.utils.getColor(b2);
    } }, x: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2, r.x(a2), s.x(a2), t.x(a2), u.x(a2), v.x(a2), w.x(a2), x.x(a2), y.x(a2);
    } }, y: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2, r.y(a2), s.y(a2), t.y(a2), u.y(a2), x.y(a2), y.y(a2), v.y(a2), w.y(a2);
    } }, useVoronoi: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2, r.useVoronoi(a2), s.useVoronoi(a2), x.useVoronoi(a2), y.useVoronoi(a2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.ohlcBar = function() {
    "use strict";
    function b(y2) {
      return y2.each(function(b2) {
        k = d3.select(this);
        var y3 = a.utils.availableWidth(h, k, g), A = a.utils.availableHeight(i, k, g);
        a.utils.initSVG(k);
        var B = y3 / b2[0].values.length * 0.9;
        l.domain(c || d3.extent(b2[0].values.map(n).concat(t))), v ? l.range(e || [0.5 * y3 / b2[0].values.length, y3 * (b2[0].values.length - 0.5) / b2[0].values.length]) : l.range(e || [5 + B / 2, y3 - B / 2 - 5]), m.domain(d || [d3.min(b2[0].values.map(s).concat(u)), d3.max(b2[0].values.map(r).concat(u))]).range(f || [A, 0]), l.domain()[0] === l.domain()[1] && (l.domain()[0] ? l.domain([l.domain()[0] - 0.01 * l.domain()[0], l.domain()[1] + 0.01 * l.domain()[1]]) : l.domain([-1, 1])), m.domain()[0] === m.domain()[1] && (m.domain()[0] ? m.domain([m.domain()[0] + 0.01 * m.domain()[0], m.domain()[1] - 0.01 * m.domain()[1]]) : m.domain([-1, 1]));
        var C = d3.select(this).selectAll("g.nv-wrap.nv-ohlcBar").data([b2[0].values]), D = C.enter().append("g").attr("class", "nvd3 nv-wrap nv-ohlcBar"), E = D.append("defs"), F = D.append("g"), G = C.select("g");
        F.append("g").attr("class", "nv-ticks"), C.attr("transform", "translate(" + g.left + "," + g.top + ")"), k.on("click", function(a2, b3) {
          z.chartClick({ data: a2, index: b3, pos: d3.event, id: j });
        }), E.append("clipPath").attr("id", "nv-chart-clip-path-" + j).append("rect"), C.select("#nv-chart-clip-path-" + j + " rect").attr("width", y3).attr("height", A), G.attr("clip-path", w ? "url(#nv-chart-clip-path-" + j + ")" : "");
        var H = C.select(".nv-ticks").selectAll(".nv-tick").data(function(a2) {
          return a2;
        });
        H.exit().remove(), H.enter().append("path").attr("class", function(a2, b3, c2) {
          return (p(a2, b3) > q(a2, b3) ? "nv-tick negative" : "nv-tick positive") + " nv-tick-" + c2 + "-" + b3;
        }).attr("d", function(a2, b3) {
          return "m0,0l0," + (m(p(a2, b3)) - m(r(a2, b3))) + "l" + -B / 2 + ",0l" + B / 2 + ",0l0," + (m(s(a2, b3)) - m(p(a2, b3))) + "l0," + (m(q(a2, b3)) - m(s(a2, b3))) + "l" + B / 2 + ",0l" + -B / 2 + ",0z";
        }).attr("transform", function(a2, b3) {
          return "translate(" + l(n(a2, b3)) + "," + m(r(a2, b3)) + ")";
        }).attr("fill", function(a2, b3) {
          return x[0];
        }).attr("stroke", function(a2, b3) {
          return x[0];
        }).attr("x", 0).attr("y", function(a2, b3) {
          return m(Math.max(0, o(a2, b3)));
        }).attr("height", function(a2, b3) {
          return Math.abs(m(o(a2, b3)) - m(0));
        }), H.attr("class", function(a2, b3, c2) {
          return (p(a2, b3) > q(a2, b3) ? "nv-tick negative" : "nv-tick positive") + " nv-tick-" + c2 + "-" + b3;
        }), d3.transition(H).attr("transform", function(a2, b3) {
          return "translate(" + l(n(a2, b3)) + "," + m(r(a2, b3)) + ")";
        }).attr("d", function(a2, c2) {
          var d2 = y3 / b2[0].values.length * 0.9;
          return "m0,0l0," + (m(p(a2, c2)) - m(r(a2, c2))) + "l" + -d2 / 2 + ",0l" + d2 / 2 + ",0l0," + (m(s(a2, c2)) - m(p(a2, c2))) + "l0," + (m(q(a2, c2)) - m(s(a2, c2))) + "l" + d2 / 2 + ",0l" + -d2 / 2 + ",0z";
        });
      }), b;
    }
    var c, d, e, f, g = { top: 0, right: 0, bottom: 0, left: 0 }, h = null, i = null, j = Math.floor(1e4 * Math.random()), k = null, l = d3.scale.linear(), m = d3.scale.linear(), n = function(a2) {
      return a2.x;
    }, o = function(a2) {
      return a2.y;
    }, p = function(a2) {
      return a2.open;
    }, q = function(a2) {
      return a2.close;
    }, r = function(a2) {
      return a2.high;
    }, s = function(a2) {
      return a2.low;
    }, t = [], u = [], v = false, w = true, x = a.utils.defaultColor(), y = false, z = d3.dispatch("stateChange", "changeState", "renderEnd", "chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove");
    return b.highlightPoint = function(a2, c2) {
      b.clearHighlights(), k.select(".nv-ohlcBar .nv-tick-0-" + a2).classed("hover", c2);
    }, b.clearHighlights = function() {
      k.select(".nv-ohlcBar .nv-tick.hover").classed("hover", false);
    }, b.dispatch = z, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, height: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, xScale: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, yScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, xDomain: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, yDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, xRange: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, yRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, forceX: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, forceY: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, padData: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, clipEdge: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, id: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, interactive: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, x: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, y: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, open: { get: function() {
      return p();
    }, set: function(a2) {
      p = a2;
    } }, close: { get: function() {
      return q();
    }, set: function(a2) {
      q = a2;
    } }, high: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, low: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, margin: { get: function() {
      return g;
    }, set: function(a2) {
      g.top = void 0 != a2.top ? a2.top : g.top, g.right = void 0 != a2.right ? a2.right : g.right, g.bottom = void 0 != a2.bottom ? a2.bottom : g.bottom, g.left = void 0 != a2.left ? a2.left : g.left;
    } }, color: { get: function() {
      return x;
    }, set: function(b2) {
      x = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.parallelCoordinates = function() {
    "use strict";
    function b(p) {
      return p.each(function(b2) {
        function p2(a2) {
          return F(h.map(function(b3) {
            if (isNaN(a2[b3]) || isNaN(parseFloat(a2[b3]))) {
              var c2 = g[b3].domain(), d2 = g[b3].range(), e2 = c2[0] - (c2[1] - c2[0]) / 9;
              if (J.indexOf(b3) < 0) {
                var h2 = d3.scale.linear().domain([e2, c2[1]]).range([x - 12, d2[1]]);
                g[b3].brush.y(h2), J.push(b3);
              }
              return [f(b3), g[b3](e2)];
            }
            return J.length > 0 ? (D.style("display", "inline"), E.style("display", "inline")) : (D.style("display", "none"), E.style("display", "none")), [f(b3), g[b3](a2[b3])];
          }));
        }
        function q() {
          var a2 = h.filter(function(a3) {
            return !g[a3].brush.empty();
          }), b3 = a2.map(function(a3) {
            return g[a3].brush.extent();
          });
          k = [], a2.forEach(function(a3, c2) {
            k[c2] = { dimension: a3, extent: b3[c2] };
          }), l = [], M.style("display", function(c2) {
            var d2 = a2.every(function(a3, d4) {
              return isNaN(c2[a3]) && b3[d4][0] == g[a3].brush.y().domain()[0] ? true : b3[d4][0] <= c2[a3] && c2[a3] <= b3[d4][1];
            });
            return d2 && l.push(c2), d2 ? null : "none";
          }), o.brush({ filters: k, active: l });
        }
        function r(a2, b3) {
          m[a2] = this.parentNode.__origin__ = f(a2), L.attr("visibility", "hidden");
        }
        function s(a2, b3) {
          m[a2] = Math.min(w, Math.max(0, this.parentNode.__origin__ += d3.event.x)), M.attr("d", p2), h.sort(function(a3, b4) {
            return u(a3) - u(b4);
          }), f.domain(h), N.attr("transform", function(a3) {
            return "translate(" + u(a3) + ")";
          });
        }
        function t(a2, b3) {
          delete this.parentNode.__origin__, delete m[a2], d3.select(this.parentNode).attr("transform", "translate(" + f(a2) + ")"), M.attr("d", p2), L.attr("d", p2).attr("visibility", null);
        }
        function u(a2) {
          var b3 = m[a2];
          return null == b3 ? f(a2) : b3;
        }
        var v = d3.select(this), w = a.utils.availableWidth(d, v, c), x = a.utils.availableHeight(e, v, c);
        a.utils.initSVG(v), l = b2, f.rangePoints([0, w], 1).domain(h);
        var y = {};
        h.forEach(function(a2) {
          var c2 = d3.extent(b2, function(b3) {
            return +b3[a2];
          });
          return y[a2] = false, void 0 === c2[0] && (y[a2] = true, c2[0] = 0, c2[1] = 0), c2[0] === c2[1] && (c2[0] = c2[0] - 1, c2[1] = c2[1] + 1), g[a2] = d3.scale.linear().domain(c2).range([0.9 * (x - 12), 0]), g[a2].brush = d3.svg.brush().y(g[a2]).on("brush", q), "name" != a2;
        });
        var z = v.selectAll("g.nv-wrap.nv-parallelCoordinates").data([b2]), A = z.enter().append("g").attr("class", "nvd3 nv-wrap nv-parallelCoordinates"), B = A.append("g"), C = z.select("g");
        B.append("g").attr("class", "nv-parallelCoordinates background"), B.append("g").attr("class", "nv-parallelCoordinates foreground"), B.append("g").attr("class", "nv-parallelCoordinates missingValuesline"), z.attr("transform", "translate(" + c.left + "," + c.top + ")");
        var D, E, F = d3.svg.line().interpolate("cardinal").tension(n), G = d3.svg.axis().orient("left"), H = d3.behavior.drag().on("dragstart", r).on("drag", s).on("dragend", t), I = f.range()[1] - f.range()[0], J = [], K = [0 + I / 2, x - 12, w - I / 2, x - 12];
        D = z.select(".missingValuesline").selectAll("line").data([K]), D.enter().append("line"), D.exit().remove(), D.attr("x1", function(a2) {
          return a2[0];
        }).attr("y1", function(a2) {
          return a2[1];
        }).attr("x2", function(a2) {
          return a2[2];
        }).attr("y2", function(a2) {
          return a2[3];
        }), E = z.select(".missingValuesline").selectAll("text").data(["undefined values"]), E.append("text").data(["undefined values"]), E.enter().append("text"), E.exit().remove(), E.attr("y", x).attr("x", w - 92 - I / 2).text(function(a2) {
          return a2;
        });
        var L = z.select(".background").selectAll("path").data(b2);
        L.enter().append("path"), L.exit().remove(), L.attr("d", p2);
        var M = z.select(".foreground").selectAll("path").data(b2);
        M.enter().append("path"), M.exit().remove(), M.attr("d", p2).attr("stroke", j), M.on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), o.elementMouseover({ label: a2.name, data: a2.data, index: b3, pos: [d3.mouse(this.parentNode)[0], d3.mouse(this.parentNode)[1]] });
        }), M.on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), o.elementMouseout({ label: a2.name, data: a2.data, index: b3 });
        });
        var N = C.selectAll(".dimension").data(h), O = N.enter().append("g").attr("class", "nv-parallelCoordinates dimension");
        O.append("g").attr("class", "nv-parallelCoordinates nv-axis"), O.append("g").attr("class", "nv-parallelCoordinates-brush"), O.append("text").attr("class", "nv-parallelCoordinates nv-label"), N.attr("transform", function(a2) {
          return "translate(" + f(a2) + ",0)";
        }), N.exit().remove(), N.select(".nv-label").style("cursor", "move").attr("dy", "-1em").attr("text-anchor", "middle").text(String).on("mouseover", function(a2, b3) {
          o.elementMouseover({ dim: a2, pos: [d3.mouse(this.parentNode.parentNode)[0], d3.mouse(this.parentNode.parentNode)[1]] });
        }).on("mouseout", function(a2, b3) {
          o.elementMouseout({ dim: a2 });
        }).call(H), N.select(".nv-axis").each(function(a2, b3) {
          d3.select(this).call(G.scale(g[a2]).tickFormat(d3.format(i[b3])));
        }), N.select(".nv-parallelCoordinates-brush").each(function(a2) {
          d3.select(this).call(g[a2].brush);
        }).selectAll("rect").attr("x", -8).attr("width", 16);
      }), b;
    }
    var c = { top: 30, right: 0, bottom: 10, left: 0 }, d = null, e = null, f = d3.scale.ordinal(), g = {}, h = [], i = [], j = a.utils.defaultColor(), k = [], l = [], m = [], n = 1, o = d3.dispatch("brush", "elementMouseover", "elementMouseout");
    return b.dispatch = o, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, height: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, dimensionNames: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, dimensionFormats: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, lineTension: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, dimensions: { get: function() {
      return h;
    }, set: function(b2) {
      a.deprecated("dimensions", "use dimensionNames instead"), h = b2;
    } }, margin: { get: function() {
      return c;
    }, set: function(a2) {
      c.top = void 0 !== a2.top ? a2.top : c.top, c.right = void 0 !== a2.right ? a2.right : c.right, c.bottom = void 0 !== a2.bottom ? a2.bottom : c.bottom, c.left = void 0 !== a2.left ? a2.left : c.left;
    } }, color: { get: function() {
      return j;
    }, set: function(b2) {
      j = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.pie = function() {
    "use strict";
    function b(E) {
      return D.reset(), E.each(function(b2) {
        function E2(a2, b3) {
          a2.endAngle = isNaN(a2.endAngle) ? 0 : a2.endAngle, a2.startAngle = isNaN(a2.startAngle) ? 0 : a2.startAngle, p || (a2.innerRadius = 0);
          var c2 = d3.interpolate(this._current, a2);
          return this._current = c2(0), function(a3) {
            return B[b3](c2(a3));
          };
        }
        var F = d - c.left - c.right, G = e - c.top - c.bottom, H = Math.min(F, G) / 2, I = [], J = [];
        if (i = d3.select(this), 0 === z.length) for (var K = H - H / 5, L = y * H, M = 0; M < b2[0].length; M++) I.push(K), J.push(L);
        else I = z.map(function(a2) {
          return (a2.outer - a2.outer / 5) * H;
        }), J = z.map(function(a2) {
          return (a2.inner - a2.inner / 5) * H;
        }), y = d3.min(z.map(function(a2) {
          return a2.inner - a2.inner / 5;
        }));
        a.utils.initSVG(i);
        var N = i.selectAll(".nv-wrap.nv-pie").data(b2), O = N.enter().append("g").attr("class", "nvd3 nv-wrap nv-pie nv-chart-" + h), P = O.append("g"), Q = N.select("g"), R = P.append("g").attr("class", "nv-pie");
        P.append("g").attr("class", "nv-pieLabels"), N.attr("transform", "translate(" + c.left + "," + c.top + ")"), Q.select(".nv-pie").attr("transform", "translate(" + F / 2 + "," + G / 2 + ")"), Q.select(".nv-pieLabels").attr("transform", "translate(" + F / 2 + "," + G / 2 + ")"), i.on("click", function(a2, b3) {
          A.chartClick({ data: a2, index: b3, pos: d3.event, id: h });
        }), B = [], C = [];
        for (var M = 0; M < b2[0].length; M++) {
          var S = d3.svg.arc().outerRadius(I[M]), T = d3.svg.arc().outerRadius(I[M] + 5);
          u !== false && (S.startAngle(u), T.startAngle(u)), w !== false && (S.endAngle(w), T.endAngle(w)), p && (S.innerRadius(J[M]), T.innerRadius(J[M])), S.cornerRadius && x && (S.cornerRadius(x), T.cornerRadius(x)), B.push(S), C.push(T);
        }
        var U = d3.layout.pie().sort(null).value(function(a2) {
          return a2.disabled ? 0 : g(a2);
        });
        U.padAngle && v && U.padAngle(v), p && q && (R.append("text").attr("class", "nv-pie-title"), N.select(".nv-pie-title").style("text-anchor", "middle").text(function(a2) {
          return q;
        }).style("font-size", Math.min(F, G) * y * 2 / (q.length + 2) + "px").attr("dy", "0.35em").attr("transform", function(a2, b3) {
          return "translate(0, " + s + ")";
        }));
        var V = N.select(".nv-pie").selectAll(".nv-slice").data(U), W = N.select(".nv-pieLabels").selectAll(".nv-label").data(U);
        V.exit().remove(), W.exit().remove();
        var X = V.enter().append("g");
        X.attr("class", "nv-slice"), X.on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true), r && d3.select(this).select("path").transition().duration(70).attr("d", C[b3]), A.elementMouseover({ data: a2.data, index: b3, color: d3.select(this).style("fill") });
        }), X.on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false), r && d3.select(this).select("path").transition().duration(50).attr("d", B[b3]), A.elementMouseout({ data: a2.data, index: b3 });
        }), X.on("mousemove", function(a2, b3) {
          A.elementMousemove({ data: a2.data, index: b3 });
        }), X.on("click", function(a2, b3) {
          A.elementClick({ data: a2.data, index: b3, color: d3.select(this).style("fill") });
        }), X.on("dblclick", function(a2, b3) {
          A.elementDblClick({ data: a2.data, index: b3, color: d3.select(this).style("fill") });
        }), V.attr("fill", function(a2, b3) {
          return j(a2.data, b3);
        }), V.attr("stroke", function(a2, b3) {
          return j(a2.data, b3);
        });
        X.append("path").each(function(a2) {
          this._current = a2;
        });
        if (V.select("path").transition().attr("d", function(a2, b3) {
          return B[b3](a2);
        }).attrTween("d", E2), l) {
          for (var Y = [], M = 0; M < b2[0].length; M++) Y.push(B[M]), m ? p && (Y[M] = d3.svg.arc().outerRadius(B[M].outerRadius()), u !== false && Y[M].startAngle(u), w !== false && Y[M].endAngle(w)) : p || Y[M].innerRadius(0);
          W.enter().append("g").classed("nv-label", true).each(function(a2, b3) {
            var c2 = d3.select(this);
            c2.attr("transform", function(a3, b4) {
              if (t) {
                a3.outerRadius = I[b4] + 10, a3.innerRadius = I[b4] + 15;
                var c3 = (a3.startAngle + a3.endAngle) / 2 * (180 / Math.PI);
                return (a3.startAngle + a3.endAngle) / 2 < Math.PI ? c3 -= 90 : c3 += 90, "translate(" + Y[b4].centroid(a3) + ") rotate(" + c3 + ")";
              }
              return a3.outerRadius = H + 10, a3.innerRadius = H + 15, "translate(" + Y[b4].centroid(a3) + ")";
            }), c2.append("rect").style("stroke", "#fff").style("fill", "#fff").attr("rx", 3).attr("ry", 3), c2.append("text").style("text-anchor", t ? (a2.startAngle + a2.endAngle) / 2 < Math.PI ? "start" : "end" : "middle").style("fill", "#000");
          });
          var Z = {}, $ = 14, _5 = 140, aa = function(a2) {
            return Math.floor(a2[0] / _5) * _5 + "," + Math.floor(a2[1] / $) * $;
          };
          W.watchTransition(D, "pie labels").attr("transform", function(a2, b3) {
            if (t) {
              a2.outerRadius = I[b3] + 10, a2.innerRadius = I[b3] + 15;
              var c2 = (a2.startAngle + a2.endAngle) / 2 * (180 / Math.PI);
              return (a2.startAngle + a2.endAngle) / 2 < Math.PI ? c2 -= 90 : c2 += 90, "translate(" + Y[b3].centroid(a2) + ") rotate(" + c2 + ")";
            }
            a2.outerRadius = H + 10, a2.innerRadius = H + 15;
            var d2 = Y[b3].centroid(a2);
            if (a2.value) {
              var e2 = aa(d2);
              Z[e2] && (d2[1] -= $), Z[aa(d2)] = true;
            }
            return "translate(" + d2 + ")";
          }), W.select(".nv-label text").style("text-anchor", function(a2, b3) {
            return t ? (a2.startAngle + a2.endAngle) / 2 < Math.PI ? "start" : "end" : "middle";
          }).text(function(a2, b3) {
            var c2 = (a2.endAngle - a2.startAngle) / (2 * Math.PI), d2 = "";
            if (!a2.value || o > c2) return "";
            if ("function" == typeof n) d2 = n(a2, b3, { key: f(a2.data), value: g(a2.data), percent: k(c2) });
            else switch (n) {
              case "key":
                d2 = f(a2.data);
                break;
              case "value":
                d2 = k(g(a2.data));
                break;
              case "percent":
                d2 = d3.format("%")(c2);
            }
            return d2;
          });
        }
      }), D.renderEnd("pie immediate"), b;
    }
    var c = { top: 0, right: 0, bottom: 0, left: 0 }, d = 500, e = 500, f = function(a2) {
      return a2.x;
    }, g = function(a2) {
      return a2.y;
    }, h = Math.floor(1e4 * Math.random()), i = null, j = a.utils.defaultColor(), k = d3.format(",.2f"), l = true, m = false, n = "key", o = 0.02, p = false, q = false, r = true, s = 0, t = false, u = false, v = false, w = false, x = 0, y = 0.5, z = [], A = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "elementMousemove", "renderEnd"), B = [], C = [], D = a.utils.renderWatch(A);
    return b.dispatch = A, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { arcsRadius: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, width: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, height: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, showLabels: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, title: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, titleOffset: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, labelThreshold: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, valueFormat: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, x: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, id: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, endAngle: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, startAngle: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, padAngle: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, cornerRadius: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, donutRatio: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, labelsOutside: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, labelSunbeamLayout: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, donut: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, growOnHover: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, pieLabelsOutside: { get: function() {
      return m;
    }, set: function(b2) {
      m = b2, a.deprecated("pieLabelsOutside", "use labelsOutside instead");
    } }, donutLabelsOutside: { get: function() {
      return m;
    }, set: function(b2) {
      m = b2, a.deprecated("donutLabelsOutside", "use labelsOutside instead");
    } }, labelFormat: { get: function() {
      return k;
    }, set: function(b2) {
      k = b2, a.deprecated("labelFormat", "use valueFormat instead");
    } }, margin: { get: function() {
      return c;
    }, set: function(a2) {
      c.top = "undefined" != typeof a2.top ? a2.top : c.top, c.right = "undefined" != typeof a2.right ? a2.right : c.right, c.bottom = "undefined" != typeof a2.bottom ? a2.bottom : c.bottom, c.left = "undefined" != typeof a2.left ? a2.left : c.left;
    } }, y: { get: function() {
      return g;
    }, set: function(a2) {
      g = d3.functor(a2);
    } }, color: { get: function() {
      return j;
    }, set: function(b2) {
      j = a.utils.getColor(b2);
    } }, labelType: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2 || "key";
    } } }), a.utils.initOptions(b), b;
  }, a.models.pieChart = function() {
    "use strict";
    function b(e2) {
      return q.reset(), q.models(c), e2.each(function(e3) {
        var k2 = d3.select(this);
        a.utils.initSVG(k2);
        var n2 = a.utils.availableWidth(g, k2, f), o2 = a.utils.availableHeight(h, k2, f);
        if (b.update = function() {
          k2.transition().call(b);
        }, b.container = this, l.setter(s(e3), b.update).getter(r(e3)).update(), l.disabled = e3.map(function(a2) {
          return !!a2.disabled;
        }), !m) {
          var q2;
          m = {};
          for (q2 in l) l[q2] instanceof Array ? m[q2] = l[q2].slice(0) : m[q2] = l[q2];
        }
        if (!e3 || !e3.length) return a.utils.noData(b, k2), b;
        k2.selectAll(".nv-noData").remove();
        var t = k2.selectAll("g.nv-wrap.nv-pieChart").data([e3]), u = t.enter().append("g").attr("class", "nvd3 nv-wrap nv-pieChart").append("g"), v = t.select("g");
        if (u.append("g").attr("class", "nv-pieWrap"), u.append("g").attr("class", "nv-legendWrap"), i) {
          if ("top" === j) d.width(n2).key(c.x()), t.select(".nv-legendWrap").datum(e3).call(d), f.top != d.height() && (f.top = d.height(), o2 = a.utils.availableHeight(h, k2, f)), t.select(".nv-legendWrap").attr("transform", "translate(0," + -f.top + ")");
          else if ("right" === j) {
            var w = a.models.legend().width();
            w > n2 / 2 && (w = n2 / 2), d.height(o2).key(c.x()), d.width(w), n2 -= d.width(), t.select(".nv-legendWrap").datum(e3).call(d).attr("transform", "translate(" + n2 + ",0)");
          }
        }
        t.attr("transform", "translate(" + f.left + "," + f.top + ")"), c.width(n2).height(o2);
        var x = v.select(".nv-pieWrap").datum([e3]);
        d3.transition(x).call(c), d.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) l[c2] = a2[c2];
          p.stateChange(l), b.update();
        }), p.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (e3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), l.disabled = a2.disabled), b.update();
        });
      }), q.renderEnd("pieChart immediate"), b;
    }
    var c = a.models.pie(), d = a.models.legend(), e = a.models.tooltip(), f = { top: 30, right: 20, bottom: 20, left: 20 }, g = null, h = null, i = true, j = "top", k = a.utils.defaultColor(), l = a.utils.state(), m = null, n = null, o = 250, p = d3.dispatch("stateChange", "changeState", "renderEnd");
    e.duration(0).headerEnabled(false).valueFormatter(function(a2, b2) {
      return c.valueFormat()(a2, b2);
    });
    var q = a.utils.renderWatch(p), r = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }) };
      };
    }, s = function(a2) {
      return function(b2) {
        void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    return c.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.series = { key: b.x()(a2.data), value: b.y()(a2.data), color: a2.color }, e.data(a2).hidden(false);
    }), c.dispatch.on("elementMouseout.tooltip", function(a2) {
      e.hidden(true);
    }), c.dispatch.on("elementMousemove.tooltip", function(a2) {
      e();
    }), b.legend = d, b.dispatch = p, b.pie = c, b.tooltip = e, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { noData: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, showLegend: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, legendPosition: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, defaultState: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, color: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2, d.color(k), c.color(k);
    } }, duration: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2, q.reset(o);
    } }, margin: { get: function() {
      return f;
    }, set: function(a2) {
      f.top = void 0 !== a2.top ? a2.top : f.top, f.right = void 0 !== a2.right ? a2.right : f.right, f.bottom = void 0 !== a2.bottom ? a2.bottom : f.bottom, f.left = void 0 !== a2.left ? a2.left : f.left;
    } } }), a.utils.inheritOptions(b, c), a.utils.initOptions(b), b;
  }, a.models.scatter = function() {
    "use strict";
    function b(N2) {
      return P.reset(), N2.each(function(b2) {
        function N3() {
          if (O = false, !w) return false;
          if (M === true) {
            var a2 = d3.merge(b2.map(function(a3, b3) {
              return a3.values.map(function(a4, c3) {
                var d4 = p(a4, c3), e3 = q(a4, c3);
                return [m(d4) + 1e-4 * Math.random(), n(e3) + 1e-4 * Math.random(), b3, c3, a4];
              }).filter(function(a4, b4) {
                return x(a4[4], b4);
              });
            }));
            if (0 == a2.length) return false;
            a2.length < 3 && (a2.push([m.range()[0] - 20, n.range()[0] - 20, null, null]), a2.push([m.range()[1] + 20, n.range()[1] + 20, null, null]), a2.push([m.range()[0] - 20, n.range()[0] + 20, null, null]), a2.push([m.range()[1] + 20, n.range()[1] - 20, null, null]));
            var c2 = d3.geom.polygon([[-10, -10], [-10, i + 10], [h + 10, i + 10], [h + 10, -10]]), d2 = d3.geom.voronoi(a2).map(function(b3, d4) {
              return { data: c2.clip(b3), series: a2[d4][2], point: a2[d4][3] };
            });
            U.select(".nv-point-paths").selectAll("path").remove();
            var e2 = U.select(".nv-point-paths").selectAll("path").data(d2), f2 = e2.enter().append("svg:path").attr("d", function(a3) {
              return a3 && a3.data && 0 !== a3.data.length ? "M" + a3.data.join(",") + "Z" : "M 0 0";
            }).attr("id", function(a3, b3) {
              return "nv-path-" + b3;
            }).attr("clip-path", function(a3, b3) {
              return "url(#nv-clip-" + k + "-" + b3 + ")";
            });
            if (C && f2.style("fill", d3.rgb(230, 230, 230)).style("fill-opacity", 0.4).style("stroke-opacity", 1).style("stroke", d3.rgb(200, 200, 200)), B) {
              U.select(".nv-point-clips").selectAll("*").remove();
              var o2 = U.select(".nv-point-clips").selectAll("clipPath").data(a2);
              o2.enter().append("svg:clipPath").attr("id", function(a3, b3) {
                return "nv-clip-" + k + "-" + b3;
              }).append("svg:circle").attr("cx", function(a3) {
                return a3[0];
              }).attr("cy", function(a3) {
                return a3[1];
              }).attr("r", D);
            }
            var r2 = function(a3, c3) {
              if (O) return 0;
              var d4 = b2[a3.series];
              if (void 0 !== d4) {
                var e3 = d4.values[a3.point];
                e3.color = j(d4, a3.series), e3.x = p(e3), e3.y = q(e3);
                var f3 = l.node().getBoundingClientRect(), h2 = window.pageYOffset || document.documentElement.scrollTop, i2 = window.pageXOffset || document.documentElement.scrollLeft, k2 = { left: m(p(e3, a3.point)) + f3.left + i2 + g.left + 10, top: n(q(e3, a3.point)) + f3.top + h2 + g.top + 10 };
                c3({ point: e3, series: d4, pos: k2, relativePos: [m(p(e3, a3.point)) + g.left, n(q(e3, a3.point)) + g.top], seriesIndex: a3.series, pointIndex: a3.point });
              }
            };
            e2.on("click", function(a3) {
              r2(a3, L.elementClick);
            }).on("dblclick", function(a3) {
              r2(a3, L.elementDblClick);
            }).on("mouseover", function(a3) {
              r2(a3, L.elementMouseover);
            }).on("mouseout", function(a3, b3) {
              r2(a3, L.elementMouseout);
            });
          } else U.select(".nv-groups").selectAll(".nv-group").selectAll(".nv-point").on("click", function(a3, c3) {
            if (O || !b2[a3.series]) return 0;
            var d4 = b2[a3.series], e3 = d4.values[c3];
            L.elementClick({ point: e3, series: d4, pos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], relativePos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], seriesIndex: a3.series, pointIndex: c3 });
          }).on("dblclick", function(a3, c3) {
            if (O || !b2[a3.series]) return 0;
            var d4 = b2[a3.series], e3 = d4.values[c3];
            L.elementDblClick({ point: e3, series: d4, pos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], relativePos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], seriesIndex: a3.series, pointIndex: c3 });
          }).on("mouseover", function(a3, c3) {
            if (O || !b2[a3.series]) return 0;
            var d4 = b2[a3.series], e3 = d4.values[c3];
            L.elementMouseover({ point: e3, series: d4, pos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], relativePos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], seriesIndex: a3.series, pointIndex: c3, color: j(a3, c3) });
          }).on("mouseout", function(a3, c3) {
            if (O || !b2[a3.series]) return 0;
            var d4 = b2[a3.series], e3 = d4.values[c3];
            L.elementMouseout({ point: e3, series: d4, pos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], relativePos: [m(p(e3, c3)) + g.left, n(q(e3, c3)) + g.top], seriesIndex: a3.series, pointIndex: c3, color: j(a3, c3) });
          });
        }
        l = d3.select(this);
        var R = a.utils.availableWidth(h, l, g), S = a.utils.availableHeight(i, l, g);
        a.utils.initSVG(l), b2.forEach(function(a2, b3) {
          a2.values.forEach(function(a3) {
            a3.series = b3;
          });
        });
        var T = E && F && I ? [] : d3.merge(b2.map(function(a2) {
          return a2.values.map(function(a3, b3) {
            return { x: p(a3, b3), y: q(a3, b3), size: r(a3, b3) };
          });
        }));
        m.domain(E || d3.extent(T.map(function(a2) {
          return a2.x;
        }).concat(t))), y && b2[0] ? m.range(G || [(R * z + R) / (2 * b2[0].values.length), R - R * (1 + z) / (2 * b2[0].values.length)]) : m.range(G || [0, R]), n.domain(F || d3.extent(T.map(function(a2) {
          return a2.y;
        }).concat(u))).range(H || [S, 0]), o.domain(I || d3.extent(T.map(function(a2) {
          return a2.size;
        }).concat(v))).range(J || Q), K = m.domain()[0] === m.domain()[1] || n.domain()[0] === n.domain()[1], m.domain()[0] === m.domain()[1] && (m.domain()[0] ? m.domain([m.domain()[0] - 0.01 * m.domain()[0], m.domain()[1] + 0.01 * m.domain()[1]]) : m.domain([-1, 1])), n.domain()[0] === n.domain()[1] && (n.domain()[0] ? n.domain([n.domain()[0] - 0.01 * n.domain()[0], n.domain()[1] + 0.01 * n.domain()[1]]) : n.domain([-1, 1])), isNaN(m.domain()[0]) && m.domain([-1, 1]), isNaN(n.domain()[0]) && n.domain([-1, 1]), c = c || m, d = d || n, e = e || o;
        var U = l.selectAll("g.nv-wrap.nv-scatter").data([b2]), V = U.enter().append("g").attr("class", "nvd3 nv-wrap nv-scatter nv-chart-" + k), W = V.append("defs"), X = V.append("g"), Y = U.select("g");
        U.classed("nv-single-point", K), X.append("g").attr("class", "nv-groups"), X.append("g").attr("class", "nv-point-paths"), V.append("g").attr("class", "nv-point-clips"), U.attr("transform", "translate(" + g.left + "," + g.top + ")"), W.append("clipPath").attr("id", "nv-edge-clip-" + k).append("rect"), U.select("#nv-edge-clip-" + k + " rect").attr("width", R).attr("height", S > 0 ? S : 0), Y.attr("clip-path", A ? "url(#nv-edge-clip-" + k + ")" : ""), O = true;
        var Z = U.select(".nv-groups").selectAll(".nv-group").data(function(a2) {
          return a2;
        }, function(a2) {
          return a2.key;
        });
        Z.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6), Z.exit().remove(), Z.attr("class", function(a2, b3) {
          return "nv-group nv-series-" + b3;
        }).classed("hover", function(a2) {
          return a2.hover;
        }), Z.watchTransition(P, "scatter: groups").style("fill", function(a2, b3) {
          return j(a2, b3);
        }).style("stroke", function(a2, b3) {
          return j(a2, b3);
        }).style("stroke-opacity", 1).style("fill-opacity", 0.5);
        var $ = Z.selectAll("path.nv-point").data(function(a2) {
          return a2.values.map(function(a3, b3) {
            return [a3, b3];
          }).filter(function(a3, b3) {
            return x(a3[0], b3);
          });
        });
        $.enter().append("path").style("fill", function(a2) {
          return a2.color;
        }).style("stroke", function(a2) {
          return a2.color;
        }).attr("transform", function(a2) {
          return "translate(" + c(p(a2[0], a2[1])) + "," + d(q(a2[0], a2[1])) + ")";
        }).attr("d", a.utils.symbol().type(function(a2) {
          return s(a2[0]);
        }).size(function(a2) {
          return o(r(a2[0], a2[1]));
        })), $.exit().remove(), Z.exit().selectAll("path.nv-point").watchTransition(P, "scatter exit").attr("transform", function(a2) {
          return "translate(" + m(p(a2[0], a2[1])) + "," + n(q(a2[0], a2[1])) + ")";
        }).remove(), $.each(function(a2) {
          d3.select(this).classed("nv-point", true).classed("nv-point-" + a2[1], true).classed("nv-noninteractive", !w).classed("hover", false);
        }), $.watchTransition(P, "scatter points").attr("transform", function(a2) {
          return "translate(" + m(p(a2[0], a2[1])) + "," + n(q(a2[0], a2[1])) + ")";
        }).attr("d", a.utils.symbol().type(function(a2) {
          return s(a2[0]);
        }).size(function(a2) {
          return o(r(a2[0], a2[1]));
        })), clearTimeout(f), f = setTimeout(N3, 300), c = m.copy(), d = n.copy(), e = o.copy();
      }), P.renderEnd("scatter immediate"), b;
    }
    var c, d, e, f, g = { top: 0, right: 0, bottom: 0, left: 0 }, h = null, i = null, j = a.utils.defaultColor(), k = Math.floor(1e5 * Math.random()), l = null, m = d3.scale.linear(), n = d3.scale.linear(), o = d3.scale.linear(), p = function(a2) {
      return a2.x;
    }, q = function(a2) {
      return a2.y;
    }, r = function(a2) {
      return a2.size || 1;
    }, s = function(a2) {
      return a2.shape || "circle";
    }, t = [], u = [], v = [], w = true, x = function(a2) {
      return !a2.notActive;
    }, y = false, z = 0.1, A = false, B = true, C = false, D = function() {
      return 25;
    }, E = null, F = null, G = null, H = null, I = null, J = null, K = false, L = d3.dispatch("elementClick", "elementDblClick", "elementMouseover", "elementMouseout", "renderEnd"), M = true, N = 250, O = false, P = a.utils.renderWatch(L, N), Q = [16, 256];
    return b.dispatch = L, b.options = a.utils.optionsFunc.bind(b), b._calls = new function() {
      this.clearHighlights = function() {
        return a.dom.write(function() {
          l.selectAll(".nv-point.hover").classed("hover", false);
        }), null;
      }, this.highlightPoint = function(b2, c2, d2) {
        a.dom.write(function() {
          l.select(".nv-groups").selectAll(".nv-series-" + b2).selectAll(".nv-point-" + c2).classed("hover", d2);
        });
      };
    }(), L.on("elementMouseover.point", function(a2) {
      w && b._calls.highlightPoint(a2.seriesIndex, a2.pointIndex, true);
    }), L.on("elementMouseout.point", function(a2) {
      w && b._calls.highlightPoint(a2.seriesIndex, a2.pointIndex, false);
    }), b._options = Object.create({}, { width: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, height: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, xScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, yScale: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, pointScale: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, xDomain: { get: function() {
      return E;
    }, set: function(a2) {
      E = a2;
    } }, yDomain: { get: function() {
      return F;
    }, set: function(a2) {
      F = a2;
    } }, pointDomain: { get: function() {
      return I;
    }, set: function(a2) {
      I = a2;
    } }, xRange: { get: function() {
      return G;
    }, set: function(a2) {
      G = a2;
    } }, yRange: { get: function() {
      return H;
    }, set: function(a2) {
      H = a2;
    } }, pointRange: { get: function() {
      return J;
    }, set: function(a2) {
      J = a2;
    } }, forceX: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, forceY: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, forcePoint: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, interactive: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, pointActive: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, padDataOuter: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, padData: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, clipEdge: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, clipVoronoi: { get: function() {
      return B;
    }, set: function(a2) {
      B = a2;
    } }, clipRadius: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2;
    } }, showVoronoi: { get: function() {
      return C;
    }, set: function(a2) {
      C = a2;
    } }, id: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, x: { get: function() {
      return p;
    }, set: function(a2) {
      p = d3.functor(a2);
    } }, y: { get: function() {
      return q;
    }, set: function(a2) {
      q = d3.functor(a2);
    } }, pointSize: { get: function() {
      return r;
    }, set: function(a2) {
      r = d3.functor(a2);
    } }, pointShape: { get: function() {
      return s;
    }, set: function(a2) {
      s = d3.functor(a2);
    } }, margin: { get: function() {
      return g;
    }, set: function(a2) {
      g.top = void 0 !== a2.top ? a2.top : g.top, g.right = void 0 !== a2.right ? a2.right : g.right, g.bottom = void 0 !== a2.bottom ? a2.bottom : g.bottom, g.left = void 0 !== a2.left ? a2.left : g.left;
    } }, duration: { get: function() {
      return N;
    }, set: function(a2) {
      N = a2, P.reset(N);
    } }, color: { get: function() {
      return j;
    }, set: function(b2) {
      j = a.utils.getColor(b2);
    } }, useVoronoi: { get: function() {
      return M;
    }, set: function(a2) {
      M = a2, M === false && (B = false);
    } } }), a.utils.initOptions(b), b;
  }, a.models.scatterChart = function() {
    "use strict";
    function b(z2) {
      return D.reset(), D.models(c), t && D.models(d), u && D.models(e), q && D.models(g), r && D.models(h), z2.each(function(z3) {
        m = d3.select(this), a.utils.initSVG(m);
        var G = a.utils.availableWidth(k, m, j), H = a.utils.availableHeight(l, m, j);
        if (b.update = function() {
          0 === A ? m.call(b) : m.transition().duration(A).call(b);
        }, b.container = this, w.setter(F(z3), b.update).getter(E(z3)).update(), w.disabled = z3.map(function(a2) {
          return !!a2.disabled;
        }), !x) {
          var I;
          x = {};
          for (I in w) w[I] instanceof Array ? x[I] = w[I].slice(0) : x[I] = w[I];
        }
        if (!(z3 && z3.length && z3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, m), D.renderEnd("scatter immediate"), b;
        m.selectAll(".nv-noData").remove(), o = c.xScale(), p = c.yScale();
        var J = m.selectAll("g.nv-wrap.nv-scatterChart").data([z3]), K = J.enter().append("g").attr("class", "nvd3 nv-wrap nv-scatterChart nv-chart-" + c.id()), L = K.append("g"), M = J.select("g");
        if (L.append("rect").attr("class", "nvd3 nv-background").style("pointer-events", "none"), L.append("g").attr("class", "nv-x nv-axis"), L.append("g").attr("class", "nv-y nv-axis"), L.append("g").attr("class", "nv-scatterWrap"), L.append("g").attr("class", "nv-regressionLinesWrap"), L.append("g").attr("class", "nv-distWrap"), L.append("g").attr("class", "nv-legendWrap"), v && M.select(".nv-y.nv-axis").attr("transform", "translate(" + G + ",0)"), s) {
          var N = G;
          f.width(N), J.select(".nv-legendWrap").datum(z3).call(f), j.top != f.height() && (j.top = f.height(), H = a.utils.availableHeight(l, m, j)), J.select(".nv-legendWrap").attr("transform", "translate(0," + -j.top + ")");
        }
        J.attr("transform", "translate(" + j.left + "," + j.top + ")"), c.width(G).height(H).color(z3.map(function(a2, b2) {
          return a2.color = a2.color || n(a2, b2), a2.color;
        }).filter(function(a2, b2) {
          return !z3[b2].disabled;
        })), J.select(".nv-scatterWrap").datum(z3.filter(function(a2) {
          return !a2.disabled;
        })).call(c), J.select(".nv-regressionLinesWrap").attr("clip-path", "url(#nv-edge-clip-" + c.id() + ")");
        var O = J.select(".nv-regressionLinesWrap").selectAll(".nv-regLines").data(function(a2) {
          return a2;
        });
        O.enter().append("g").attr("class", "nv-regLines");
        var P = O.selectAll(".nv-regLine").data(function(a2) {
          return [a2];
        });
        P.enter().append("line").attr("class", "nv-regLine").style("stroke-opacity", 0), P.filter(function(a2) {
          return a2.intercept && a2.slope;
        }).watchTransition(D, "scatterPlusLineChart: regline").attr("x1", o.range()[0]).attr("x2", o.range()[1]).attr("y1", function(a2, b2) {
          return p(o.domain()[0] * a2.slope + a2.intercept);
        }).attr("y2", function(a2, b2) {
          return p(o.domain()[1] * a2.slope + a2.intercept);
        }).style("stroke", function(a2, b2, c2) {
          return n(a2, c2);
        }).style("stroke-opacity", function(a2, b2) {
          return a2.disabled || "undefined" == typeof a2.slope || "undefined" == typeof a2.intercept ? 0 : 1;
        }), t && (d.scale(o)._ticks(a.utils.calcTicksX(G / 100, z3)).tickSize(-H, 0), M.select(".nv-x.nv-axis").attr("transform", "translate(0," + p.range()[0] + ")").call(d)), u && (e.scale(p)._ticks(a.utils.calcTicksY(H / 36, z3)).tickSize(-G, 0), M.select(".nv-y.nv-axis").call(e)), q && (g.getData(c.x()).scale(o).width(G).color(z3.map(function(a2, b2) {
          return a2.color || n(a2, b2);
        }).filter(function(a2, b2) {
          return !z3[b2].disabled;
        })), L.select(".nv-distWrap").append("g").attr("class", "nv-distributionX"), M.select(".nv-distributionX").attr("transform", "translate(0," + p.range()[0] + ")").datum(z3.filter(function(a2) {
          return !a2.disabled;
        })).call(g)), r && (h.getData(c.y()).scale(p).width(H).color(z3.map(function(a2, b2) {
          return a2.color || n(a2, b2);
        }).filter(function(a2, b2) {
          return !z3[b2].disabled;
        })), L.select(".nv-distWrap").append("g").attr("class", "nv-distributionY"), M.select(".nv-distributionY").attr("transform", "translate(" + (v ? G : -h.size()) + ",0)").datum(z3.filter(function(a2) {
          return !a2.disabled;
        })).call(h)), f.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) w[c2] = a2[c2];
          y.stateChange(w), b.update();
        }), y.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && (z3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), w.disabled = a2.disabled), b.update();
        }), c.dispatch.on("elementMouseout.tooltip", function(a2) {
          i.hidden(true), m.select(".nv-chart-" + c.id() + " .nv-series-" + a2.seriesIndex + " .nv-distx-" + a2.pointIndex).attr("y1", 0), m.select(".nv-chart-" + c.id() + " .nv-series-" + a2.seriesIndex + " .nv-disty-" + a2.pointIndex).attr("x2", h.size());
        }), c.dispatch.on("elementMouseover.tooltip", function(a2) {
          m.select(".nv-series-" + a2.seriesIndex + " .nv-distx-" + a2.pointIndex).attr("y1", a2.relativePos[1] - H), m.select(".nv-series-" + a2.seriesIndex + " .nv-disty-" + a2.pointIndex).attr("x2", a2.relativePos[0] + g.size()), i.data(a2).hidden(false);
        }), B = o.copy(), C = p.copy();
      }), D.renderEnd("scatter with line immediate"), b;
    }
    var c = a.models.scatter(), d = a.models.axis(), e = a.models.axis(), f = a.models.legend(), g = a.models.distribution(), h = a.models.distribution(), i = a.models.tooltip(), j = { top: 30, right: 20, bottom: 50, left: 75 }, k = null, l = null, m = null, n = a.utils.defaultColor(), o = c.xScale(), p = c.yScale(), q = false, r = false, s = true, t = true, u = true, v = false, w = a.utils.state(), x = null, y = d3.dispatch("stateChange", "changeState", "renderEnd"), z = null, A = 250;
    c.xScale(o).yScale(p), d.orient("bottom").tickPadding(10), e.orient(v ? "right" : "left").tickPadding(10), g.axis("x"), h.axis("y"), i.headerFormatter(function(a2, b2) {
      return d.tickFormat()(a2, b2);
    }).valueFormatter(function(a2, b2) {
      return e.tickFormat()(a2, b2);
    });
    var B, C, D = a.utils.renderWatch(y, A), E = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }) };
      };
    }, F = function(a2) {
      return function(b2) {
        void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    };
    return b.dispatch = y, b.scatter = c, b.legend = f, b.xAxis = d, b.yAxis = e, b.distX = g, b.distY = h, b.tooltip = i, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, height: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, container: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, showDistX: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, showDistY: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showLegend: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, showXAxis: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2;
    } }, showYAxis: { get: function() {
      return u;
    }, set: function(a2) {
      u = a2;
    } }, defaultState: { get: function() {
      return x;
    }, set: function(a2) {
      x = a2;
    } }, noData: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, duration: { get: function() {
      return A;
    }, set: function(a2) {
      A = a2;
    } }, margin: { get: function() {
      return j;
    }, set: function(a2) {
      j.top = void 0 !== a2.top ? a2.top : j.top, j.right = void 0 !== a2.right ? a2.right : j.right, j.bottom = void 0 !== a2.bottom ? a2.bottom : j.bottom, j.left = void 0 !== a2.left ? a2.left : j.left;
    } }, rightAlignYAxis: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2, e.orient(a2 ? "right" : "left");
    } }, color: { get: function() {
      return n;
    }, set: function(b2) {
      n = a.utils.getColor(b2), f.color(n), g.color(n), h.color(n);
    } } }), a.utils.inheritOptions(b, c), a.utils.initOptions(b), b;
  }, a.models.sparkline = function() {
    "use strict";
    function b(k2) {
      return k2.each(function(b2) {
        var k3 = h - g.left - g.right, q = i - g.top - g.bottom;
        j = d3.select(this), a.utils.initSVG(j), l.domain(c || d3.extent(b2, n)).range(e || [0, k3]), m.domain(d || d3.extent(b2, o)).range(f || [q, 0]);
        var r = j.selectAll("g.nv-wrap.nv-sparkline").data([b2]), s = r.enter().append("g").attr("class", "nvd3 nv-wrap nv-sparkline");
        s.append("g"), r.select("g");
        r.attr("transform", "translate(" + g.left + "," + g.top + ")");
        var t = r.selectAll("path").data(function(a2) {
          return [a2];
        });
        t.enter().append("path"), t.exit().remove(), t.style("stroke", function(a2, b3) {
          return a2.color || p(a2, b3);
        }).attr("d", d3.svg.line().x(function(a2, b3) {
          return l(n(a2, b3));
        }).y(function(a2, b3) {
          return m(o(a2, b3));
        }));
        var u = r.selectAll("circle.nv-point").data(function(a2) {
          function b3(b4) {
            if (-1 != b4) {
              var c3 = a2[b4];
              return c3.pointIndex = b4, c3;
            }
            return null;
          }
          var c2 = a2.map(function(a3, b4) {
            return o(a3, b4);
          }), d2 = b3(c2.lastIndexOf(m.domain()[1])), e2 = b3(c2.indexOf(m.domain()[0])), f2 = b3(c2.length - 1);
          return [e2, d2, f2].filter(function(a3) {
            return null != a3;
          });
        });
        u.enter().append("circle"), u.exit().remove(), u.attr("cx", function(a2, b3) {
          return l(n(a2, a2.pointIndex));
        }).attr("cy", function(a2, b3) {
          return m(o(a2, a2.pointIndex));
        }).attr("r", 2).attr("class", function(a2, b3) {
          return n(a2, a2.pointIndex) == l.domain()[1] ? "nv-point nv-currentValue" : o(a2, a2.pointIndex) == m.domain()[0] ? "nv-point nv-minValue" : "nv-point nv-maxValue";
        });
      }), b;
    }
    var c, d, e, f, g = { top: 2, right: 0, bottom: 2, left: 0 }, h = 400, i = 32, j = null, k = true, l = d3.scale.linear(), m = d3.scale.linear(), n = function(a2) {
      return a2.x;
    }, o = function(a2) {
      return a2.y;
    }, p = a.utils.getColor(["#000"]);
    return b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, height: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, xDomain: { get: function() {
      return c;
    }, set: function(a2) {
      c = a2;
    } }, yDomain: { get: function() {
      return d;
    }, set: function(a2) {
      d = a2;
    } }, xRange: { get: function() {
      return e;
    }, set: function(a2) {
      e = a2;
    } }, yRange: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, xScale: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, yScale: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, animate: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, x: { get: function() {
      return n;
    }, set: function(a2) {
      n = d3.functor(a2);
    } }, y: { get: function() {
      return o;
    }, set: function(a2) {
      o = d3.functor(a2);
    } }, margin: { get: function() {
      return g;
    }, set: function(a2) {
      g.top = void 0 !== a2.top ? a2.top : g.top, g.right = void 0 !== a2.right ? a2.right : g.right, g.bottom = void 0 !== a2.bottom ? a2.bottom : g.bottom, g.left = void 0 !== a2.left ? a2.left : g.left;
    } }, color: { get: function() {
      return p;
    }, set: function(b2) {
      p = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.sparklinePlus = function() {
    "use strict";
    function b(p2) {
      return p2.each(function(p3) {
        function q() {
          if (!j) {
            var a2 = z.selectAll(".nv-hoverValue").data(i), b2 = a2.enter().append("g").attr("class", "nv-hoverValue").style("stroke-opacity", 0).style("fill-opacity", 0);
            a2.exit().transition().duration(250).style("stroke-opacity", 0).style("fill-opacity", 0).remove(), a2.attr("transform", function(a3) {
              return "translate(" + c(e.x()(p3[a3], a3)) + ",0)";
            }).transition().duration(250).style("stroke-opacity", 1).style("fill-opacity", 1), i.length && (b2.append("line").attr("x1", 0).attr("y1", -f.top).attr("x2", 0).attr("y2", u), b2.append("text").attr("class", "nv-xValue").attr("x", -6).attr("y", -f.top).attr("text-anchor", "end").attr("dy", ".9em"), z.select(".nv-hoverValue .nv-xValue").text(k(e.x()(p3[i[0]], i[0]))), b2.append("text").attr("class", "nv-yValue").attr("x", 6).attr("y", -f.top).attr("text-anchor", "start").attr("dy", ".9em"), z.select(".nv-hoverValue .nv-yValue").text(l(e.y()(p3[i[0]], i[0]))));
          }
        }
        function r() {
          function a2(a3, b3) {
            for (var c2 = Math.abs(e.x()(a3[0], 0) - b3), d2 = 0, f2 = 0; f2 < a3.length; f2++) Math.abs(e.x()(a3[f2], f2) - b3) < c2 && (c2 = Math.abs(e.x()(a3[f2], f2) - b3), d2 = f2);
            return d2;
          }
          if (!j) {
            var b2 = d3.mouse(this)[0] - f.left;
            i = [a2(p3, Math.round(c.invert(b2)))], q();
          }
        }
        var s = d3.select(this);
        a.utils.initSVG(s);
        var t = a.utils.availableWidth(g, s, f), u = a.utils.availableHeight(h, s, f);
        if (b.update = function() {
          s.call(b);
        }, b.container = this, !p3 || !p3.length) return a.utils.noData(b, s), b;
        s.selectAll(".nv-noData").remove();
        var v = e.y()(p3[p3.length - 1], p3.length - 1);
        c = e.xScale(), d = e.yScale();
        var w = s.selectAll("g.nv-wrap.nv-sparklineplus").data([p3]), x = w.enter().append("g").attr("class", "nvd3 nv-wrap nv-sparklineplus"), y = x.append("g"), z = w.select("g");
        y.append("g").attr("class", "nv-sparklineWrap"), y.append("g").attr("class", "nv-valueWrap"), y.append("g").attr("class", "nv-hoverArea"), w.attr("transform", "translate(" + f.left + "," + f.top + ")");
        var A = z.select(".nv-sparklineWrap");
        if (e.width(t).height(u), A.call(e), m) {
          var B = z.select(".nv-valueWrap"), C = B.selectAll(".nv-currentValue").data([v]);
          C.enter().append("text").attr("class", "nv-currentValue").attr("dx", o ? -8 : 8).attr("dy", ".9em").style("text-anchor", o ? "end" : "start"), C.attr("x", t + (o ? f.right : 0)).attr("y", n ? function(a2) {
            return d(a2);
          } : 0).style("fill", e.color()(p3[p3.length - 1], p3.length - 1)).text(l(v));
        }
        y.select(".nv-hoverArea").append("rect").on("mousemove", r).on("click", function() {
          j = !j;
        }).on("mouseout", function() {
          i = [], q();
        }), z.select(".nv-hoverArea rect").attr("transform", function(a2) {
          return "translate(" + -f.left + "," + -f.top + ")";
        }).attr("width", t + f.left + f.right).attr("height", u + f.top);
      }), b;
    }
    var c, d, e = a.models.sparkline(), f = { top: 15, right: 100, bottom: 10, left: 50 }, g = null, h = null, i = [], j = false, k = d3.format(",r"), l = d3.format(",.2f"), m = true, n = true, o = false, p = null;
    return b.sparkline = e, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, height: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, xTickFormat: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, yTickFormat: { get: function() {
      return l;
    }, set: function(a2) {
      l = a2;
    } }, showLastValue: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, alignValue: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, rightAlignValue: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, noData: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, margin: { get: function() {
      return f;
    }, set: function(a2) {
      f.top = void 0 !== a2.top ? a2.top : f.top, f.right = void 0 !== a2.right ? a2.right : f.right, f.bottom = void 0 !== a2.bottom ? a2.bottom : f.bottom, f.left = void 0 !== a2.left ? a2.left : f.left;
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.stackedArea = function() {
    "use strict";
    function b(m2) {
      return u.reset(), u.models(r), m2.each(function(m3) {
        var s2 = f - e.left - e.right, v = g - e.top - e.bottom;
        j = d3.select(this), a.utils.initSVG(j), c = r.xScale(), d = r.yScale();
        var w = m3;
        m3.forEach(function(a2, b2) {
          a2.seriesIndex = b2, a2.values = a2.values.map(function(a3, c2) {
            return a3.index = c2, a3.seriesIndex = b2, a3;
          });
        });
        var x = m3.filter(function(a2) {
          return !a2.disabled;
        });
        m3 = d3.layout.stack().order(o).offset(n).values(function(a2) {
          return a2.values;
        }).x(k).y(l).out(function(a2, b2, c2) {
          a2.display = { y: c2, y0: b2 };
        })(x);
        var y = j.selectAll("g.nv-wrap.nv-stackedarea").data([m3]), z = y.enter().append("g").attr("class", "nvd3 nv-wrap nv-stackedarea"), A = z.append("defs"), B = z.append("g"), C = y.select("g");
        B.append("g").attr("class", "nv-areaWrap"), B.append("g").attr("class", "nv-scatterWrap"), y.attr("transform", "translate(" + e.left + "," + e.top + ")"), 0 == r.forceY().length && r.forceY().push(0), r.width(s2).height(v).x(k).y(function(a2) {
          return void 0 !== a2.display ? a2.display.y + a2.display.y0 : void 0;
        }).forceY([0]).color(m3.map(function(a2, b2) {
          return a2.color || h(a2, a2.seriesIndex);
        }));
        var D = C.select(".nv-scatterWrap").datum(m3);
        D.call(r), A.append("clipPath").attr("id", "nv-edge-clip-" + i).append("rect"), y.select("#nv-edge-clip-" + i + " rect").attr("width", s2).attr("height", v), C.attr("clip-path", q ? "url(#nv-edge-clip-" + i + ")" : "");
        var E = d3.svg.area().x(function(a2, b2) {
          return c(k(a2, b2));
        }).y0(function(a2) {
          return d(a2.display.y0);
        }).y1(function(a2) {
          return d(a2.display.y + a2.display.y0);
        }).interpolate(p), F = d3.svg.area().x(function(a2, b2) {
          return c(k(a2, b2));
        }).y0(function(a2) {
          return d(a2.display.y0);
        }).y1(function(a2) {
          return d(a2.display.y0);
        }), G = C.select(".nv-areaWrap").selectAll("path.nv-area").data(function(a2) {
          return a2;
        });
        G.enter().append("path").attr("class", function(a2, b2) {
          return "nv-area nv-area-" + b2;
        }).attr("d", function(a2, b2) {
          return F(a2.values, a2.seriesIndex);
        }).on("mouseover", function(a2, b2) {
          d3.select(this).classed("hover", true), t.areaMouseover({ point: a2, series: a2.key, pos: [d3.event.pageX, d3.event.pageY], seriesIndex: a2.seriesIndex });
        }).on("mouseout", function(a2, b2) {
          d3.select(this).classed("hover", false), t.areaMouseout({ point: a2, series: a2.key, pos: [d3.event.pageX, d3.event.pageY], seriesIndex: a2.seriesIndex });
        }).on("click", function(a2, b2) {
          d3.select(this).classed("hover", false), t.areaClick({ point: a2, series: a2.key, pos: [d3.event.pageX, d3.event.pageY], seriesIndex: a2.seriesIndex });
        }), G.exit().remove(), G.style("fill", function(a2, b2) {
          return a2.color || h(a2, a2.seriesIndex);
        }).style("stroke", function(a2, b2) {
          return a2.color || h(a2, a2.seriesIndex);
        }), G.watchTransition(u, "stackedArea path").attr("d", function(a2, b2) {
          return E(a2.values, b2);
        }), r.dispatch.on("elementMouseover.area", function(a2) {
          C.select(".nv-chart-" + i + " .nv-area-" + a2.seriesIndex).classed("hover", true);
        }), r.dispatch.on("elementMouseout.area", function(a2) {
          C.select(".nv-chart-" + i + " .nv-area-" + a2.seriesIndex).classed("hover", false);
        }), b.d3_stackedOffset_stackPercent = function(a2) {
          var b2, c2, d2, e2 = a2.length, f2 = a2[0].length, g2 = [];
          for (c2 = 0; f2 > c2; ++c2) {
            for (b2 = 0, d2 = 0; b2 < w.length; b2++) d2 += l(w[b2].values[c2]);
            if (d2) for (b2 = 0; e2 > b2; b2++) a2[b2][c2][1] /= d2;
            else for (b2 = 0; e2 > b2; b2++) a2[b2][c2][1] = 0;
          }
          for (c2 = 0; f2 > c2; ++c2) g2[c2] = 0;
          return g2;
        };
      }), u.renderEnd("stackedArea immediate"), b;
    }
    var c, d, e = { top: 0, right: 0, bottom: 0, left: 0 }, f = 960, g = 500, h = a.utils.defaultColor(), i = Math.floor(1e5 * Math.random()), j = null, k = function(a2) {
      return a2.x;
    }, l = function(a2) {
      return a2.y;
    }, m = "stack", n = "zero", o = "default", p = "linear", q = false, r = a.models.scatter(), s = 250, t = d3.dispatch("areaClick", "areaMouseover", "areaMouseout", "renderEnd", "elementClick", "elementMouseover", "elementMouseout");
    r.pointSize(2.2).pointDomain([2.2, 2.2]);
    var u = a.utils.renderWatch(t, s);
    return b.dispatch = t, b.scatter = r, r.dispatch.on("elementClick", function() {
      t.elementClick.apply(this, arguments);
    }), r.dispatch.on("elementMouseover", function() {
      t.elementMouseover.apply(this, arguments);
    }), r.dispatch.on("elementMouseout", function() {
      t.elementMouseout.apply(this, arguments);
    }), b.interpolate = function(a2) {
      return arguments.length ? (p = a2, b) : p;
    }, b.duration = function(a2) {
      return arguments.length ? (s = a2, u.reset(s), r.duration(s), b) : s;
    }, b.dispatch = t, b.scatter = r, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return f;
    }, set: function(a2) {
      f = a2;
    } }, height: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, clipEdge: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, offset: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, order: { get: function() {
      return o;
    }, set: function(a2) {
      o = a2;
    } }, interpolate: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, x: { get: function() {
      return k;
    }, set: function(a2) {
      k = d3.functor(a2);
    } }, y: { get: function() {
      return l;
    }, set: function(a2) {
      l = d3.functor(a2);
    } }, margin: { get: function() {
      return e;
    }, set: function(a2) {
      e.top = void 0 !== a2.top ? a2.top : e.top, e.right = void 0 !== a2.right ? a2.right : e.right, e.bottom = void 0 !== a2.bottom ? a2.bottom : e.bottom, e.left = void 0 !== a2.left ? a2.left : e.left;
    } }, color: { get: function() {
      return h;
    }, set: function(b2) {
      h = a.utils.getColor(b2);
    } }, style: { get: function() {
      return m;
    }, set: function(a2) {
      switch (m = a2) {
        case "stack":
          b.offset("zero"), b.order("default");
          break;
        case "stream":
          b.offset("wiggle"), b.order("inside-out");
          break;
        case "stream-center":
          b.offset("silhouette"), b.order("inside-out");
          break;
        case "expand":
          b.offset("expand"), b.order("default");
          break;
        case "stack_percent":
          b.offset(b.d3_stackedOffset_stackPercent), b.order("default");
      }
    } }, duration: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2, u.reset(s), r.duration(s);
    } } }), a.utils.inheritOptions(b, r), a.utils.initOptions(b), b;
  }, a.models.stackedAreaChart = function() {
    "use strict";
    function b(k2) {
      return H.reset(), H.models(e), r && H.models(f), s && H.models(g), k2.each(function(k3) {
        var z2 = d3.select(this), H2 = this;
        a.utils.initSVG(z2);
        var M = a.utils.availableWidth(m, z2, l), N = a.utils.availableHeight(n, z2, l);
        if (b.update = function() {
          z2.transition().duration(E).call(b);
        }, b.container = this, x.setter(K(k3), b.update).getter(J(k3)).update(), x.disabled = k3.map(function(a2) {
          return !!a2.disabled;
        }), !y) {
          var O;
          y = {};
          for (O in x) x[O] instanceof Array ? y[O] = x[O].slice(0) : y[O] = x[O];
        }
        if (!(k3 && k3.length && k3.filter(function(a2) {
          return a2.values.length;
        }).length)) return a.utils.noData(b, z2), b;
        z2.selectAll(".nv-noData").remove(), c = e.xScale(), d = e.yScale();
        var P = z2.selectAll("g.nv-wrap.nv-stackedAreaChart").data([k3]), Q = P.enter().append("g").attr("class", "nvd3 nv-wrap nv-stackedAreaChart").append("g"), R = P.select("g");
        if (Q.append("rect").style("opacity", 0), Q.append("g").attr("class", "nv-x nv-axis"), Q.append("g").attr("class", "nv-y nv-axis"), Q.append("g").attr("class", "nv-stackedWrap"), Q.append("g").attr("class", "nv-legendWrap"), Q.append("g").attr("class", "nv-controlsWrap"), Q.append("g").attr("class", "nv-interactive"), R.select("rect").attr("width", M).attr("height", N), q) {
          var S = p ? M - B : M;
          h.width(S), R.select(".nv-legendWrap").datum(k3).call(h), l.top != h.height() && (l.top = h.height(), N = a.utils.availableHeight(n, z2, l)), R.select(".nv-legendWrap").attr("transform", "translate(" + (M - S) + "," + -l.top + ")");
        }
        if (p) {
          var T = [{ key: D.stacked || "Stacked", metaKey: "Stacked", disabled: "stack" != e.style(), style: "stack" }, { key: D.stream || "Stream", metaKey: "Stream", disabled: "stream" != e.style(), style: "stream" }, { key: D.expanded || "Expanded", metaKey: "Expanded", disabled: "expand" != e.style(), style: "expand" }, { key: D.stack_percent || "Stack %", metaKey: "Stack_Percent", disabled: "stack_percent" != e.style(), style: "stack_percent" }];
          B = C.length / 3 * 260, T = T.filter(function(a2) {
            return -1 !== C.indexOf(a2.metaKey);
          }), i.width(B).color(["#444", "#444", "#444"]), R.select(".nv-controlsWrap").datum(T).call(i), l.top != Math.max(i.height(), h.height()) && (l.top = Math.max(i.height(), h.height()), N = a.utils.availableHeight(n, z2, l)), R.select(".nv-controlsWrap").attr("transform", "translate(0," + -l.top + ")");
        }
        P.attr("transform", "translate(" + l.left + "," + l.top + ")"), t && R.select(".nv-y.nv-axis").attr("transform", "translate(" + M + ",0)"), u && (j.width(M).height(N).margin({ left: l.left, top: l.top }).svgContainer(z2).xScale(c), P.select(".nv-interactive").call(j)), e.width(M).height(N);
        var U = R.select(".nv-stackedWrap").datum(k3);
        if (U.transition().call(e), r && (f.scale(c)._ticks(a.utils.calcTicksX(M / 100, k3)).tickSize(-N, 0), R.select(".nv-x.nv-axis").attr("transform", "translate(0," + N + ")"), R.select(".nv-x.nv-axis").transition().duration(0).call(f)), s) {
          var V;
          if (V = "wiggle" === e.offset() ? 0 : a.utils.calcTicksY(N / 36, k3), g.scale(d)._ticks(V).tickSize(-M, 0), "expand" === e.style() || "stack_percent" === e.style()) {
            var W = g.tickFormat();
            F && W === L || (F = W), g.tickFormat(L);
          } else F && (g.tickFormat(F), F = null);
          R.select(".nv-y.nv-axis").transition().duration(0).call(g);
        }
        e.dispatch.on("areaClick.toggle", function(a2) {
          1 === k3.filter(function(a3) {
            return !a3.disabled;
          }).length ? k3.forEach(function(a3) {
            a3.disabled = false;
          }) : k3.forEach(function(b2, c2) {
            b2.disabled = c2 != a2.seriesIndex;
          }), x.disabled = k3.map(function(a3) {
            return !!a3.disabled;
          }), A.stateChange(x), b.update();
        }), h.dispatch.on("stateChange", function(a2) {
          for (var c2 in a2) x[c2] = a2[c2];
          A.stateChange(x), b.update();
        }), i.dispatch.on("legendClick", function(a2, c2) {
          a2.disabled && (T = T.map(function(a3) {
            return a3.disabled = true, a3;
          }), a2.disabled = false, e.style(a2.style), x.style = e.style(), A.stateChange(x), b.update());
        }), j.dispatch.on("elementMousemove", function(c2) {
          e.clearHighlights();
          var d2, g2, h2, i2 = [], l2 = 0;
          if (k3.filter(function(a2, b2) {
            return a2.seriesIndex = b2, !a2.disabled;
          }).forEach(function(f2, j2) {
            g2 = a.interactiveBisect(f2.values, c2.pointXValue, b.x());
            var k4 = f2.values[g2], m3 = b.y()(k4, g2);
            if (null != m3 && e.highlightPoint(j2, g2, true), "undefined" != typeof k4) {
              "undefined" == typeof d2 && (d2 = k4), "undefined" == typeof h2 && (h2 = b.xScale()(b.x()(k4, g2)));
              var n3 = "expand" == e.style() ? k4.display.y : b.y()(k4, g2);
              i2.push({ key: f2.key, value: n3, color: o(f2, f2.seriesIndex), stackedValue: k4.display }), v && "expand" != e.style() && (l2 += n3);
            }
          }), i2.reverse(), i2.length > 2) {
            var m2 = b.yScale().invert(c2.mouseY), n2 = null;
            i2.forEach(function(a2, b2) {
              m2 = Math.abs(m2);
              var c3 = Math.abs(a2.stackedValue.y0), d4 = Math.abs(a2.stackedValue.y);
              return m2 >= c3 && d4 + c3 >= m2 ? void (n2 = b2) : void 0;
            }), null != n2 && (i2[n2].highlight = true);
          }
          v && "expand" != e.style() && i2.length >= 2 && i2.push({ key: w, value: l2, total: true });
          var p2 = f.tickFormat()(b.x()(d2, g2)), q2 = j.tooltip.valueFormatter();
          "expand" === e.style() || "stack_percent" === e.style() ? (G || (G = q2), q2 = d3.format(".1%")) : G && (q2 = G, G = null), j.tooltip.chartContainer(H2.parentNode).valueFormatter(q2).data({ value: p2, series: i2 })(), j.renderGuideLine(h2);
        }), j.dispatch.on("elementMouseout", function(a2) {
          e.clearHighlights();
        }), A.on("changeState", function(a2) {
          "undefined" != typeof a2.disabled && k3.length === a2.disabled.length && (k3.forEach(function(b2, c2) {
            b2.disabled = a2.disabled[c2];
          }), x.disabled = a2.disabled), "undefined" != typeof a2.style && (e.style(a2.style), I = a2.style), b.update();
        });
      }), H.renderEnd("stacked Area chart immediate"), b;
    }
    var c, d, e = a.models.stackedArea(), f = a.models.axis(), g = a.models.axis(), h = a.models.legend(), i = a.models.legend(), j = a.interactiveGuideline(), k = a.models.tooltip(), l = { top: 30, right: 25, bottom: 50, left: 60 }, m = null, n = null, o = a.utils.defaultColor(), p = true, q = true, r = true, s = true, t = false, u = false, v = true, w = "TOTAL", x = a.utils.state(), y = null, z = null, A = d3.dispatch("stateChange", "changeState", "renderEnd"), B = 250, C = ["Stacked", "Stream", "Expanded"], D = {}, E = 250;
    x.style = e.style(), f.orient("bottom").tickPadding(7), g.orient(t ? "right" : "left"), k.headerFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    }).valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    }), j.tooltip.headerFormatter(function(a2, b2) {
      return f.tickFormat()(a2, b2);
    }).valueFormatter(function(a2, b2) {
      return g.tickFormat()(a2, b2);
    });
    var F = null, G = null;
    i.updateState(false);
    var H = a.utils.renderWatch(A), I = e.style(), J = function(a2) {
      return function() {
        return { active: a2.map(function(a3) {
          return !a3.disabled;
        }), style: e.style() };
      };
    }, K = function(a2) {
      return function(b2) {
        void 0 !== b2.style && (I = b2.style), void 0 !== b2.active && a2.forEach(function(a3, c2) {
          a3.disabled = !b2.active[c2];
        });
      };
    }, L = d3.format("%");
    return e.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.point.x = e.x()(a2.point), a2.point.y = e.y()(a2.point), k.data(a2).hidden(false);
    }), e.dispatch.on("elementMouseout.tooltip", function(a2) {
      k.hidden(true);
    }), b.dispatch = A, b.stacked = e, b.legend = h, b.controls = i, b.xAxis = f, b.yAxis = g, b.interactiveLayer = j, b.tooltip = k, b.dispatch = A, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return m;
    }, set: function(a2) {
      m = a2;
    } }, height: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, showLegend: { get: function() {
      return q;
    }, set: function(a2) {
      q = a2;
    } }, showXAxis: { get: function() {
      return r;
    }, set: function(a2) {
      r = a2;
    } }, showYAxis: { get: function() {
      return s;
    }, set: function(a2) {
      s = a2;
    } }, defaultState: { get: function() {
      return y;
    }, set: function(a2) {
      y = a2;
    } }, noData: { get: function() {
      return z;
    }, set: function(a2) {
      z = a2;
    } }, showControls: { get: function() {
      return p;
    }, set: function(a2) {
      p = a2;
    } }, controlLabels: { get: function() {
      return D;
    }, set: function(a2) {
      D = a2;
    } }, controlOptions: { get: function() {
      return C;
    }, set: function(a2) {
      C = a2;
    } }, showTotalInTooltip: { get: function() {
      return v;
    }, set: function(a2) {
      v = a2;
    } }, totalLabel: { get: function() {
      return w;
    }, set: function(a2) {
      w = a2;
    } }, margin: { get: function() {
      return l;
    }, set: function(a2) {
      l.top = void 0 !== a2.top ? a2.top : l.top, l.right = void 0 !== a2.right ? a2.right : l.right, l.bottom = void 0 !== a2.bottom ? a2.bottom : l.bottom, l.left = void 0 !== a2.left ? a2.left : l.left;
    } }, duration: { get: function() {
      return E;
    }, set: function(a2) {
      E = a2, H.reset(E), e.duration(E), f.duration(E), g.duration(E);
    } }, color: { get: function() {
      return o;
    }, set: function(b2) {
      o = a.utils.getColor(b2), h.color(o), e.color(o);
    } }, rightAlignYAxis: { get: function() {
      return t;
    }, set: function(a2) {
      t = a2, g.orient(t ? "right" : "left");
    } }, useInteractiveGuideline: { get: function() {
      return u;
    }, set: function(a2) {
      u = !!a2, b.interactive(!a2), b.useVoronoi(!a2), e.scatter.interactive(!a2);
    } } }), a.utils.inheritOptions(b, e), a.utils.initOptions(b), b;
  }, a.models.sunburst = function() {
    "use strict";
    function b(u) {
      return t.reset(), u.each(function(b2) {
        function t2(a2) {
          a2.x0 = a2.x, a2.dx0 = a2.dx;
        }
        function u2(a2) {
          var b3 = d3.interpolate(p.domain(), [a2.x, a2.x + a2.dx]), c2 = d3.interpolate(q.domain(), [a2.y, 1]), d2 = d3.interpolate(q.range(), [a2.y ? 20 : 0, y]);
          return function(a3, e2) {
            return e2 ? function(b4) {
              return s(a3);
            } : function(e3) {
              return p.domain(b3(e3)), q.domain(c2(e3)).range(d2(e3)), s(a3);
            };
          };
        }
        l = d3.select(this);
        var v, w = a.utils.availableWidth(g, l, f), x = a.utils.availableHeight(h, l, f), y = Math.min(w, x) / 2;
        a.utils.initSVG(l);
        var z = l.selectAll(".nv-wrap.nv-sunburst").data(b2), A = z.enter().append("g").attr("class", "nvd3 nv-wrap nv-sunburst nv-chart-" + k), B = A.selectAll("nv-sunburst");
        z.attr("transform", "translate(" + w / 2 + "," + x / 2 + ")"), l.on("click", function(a2, b3) {
          o.chartClick({ data: a2, index: b3, pos: d3.event, id: k });
        }), q.range([0, y]), c = c || b2, e = b2[0], r.value(j[i] || j.count), v = B.data(r.nodes).enter().append("path").attr("d", s).style("fill", function(a2) {
          return m((a2.children ? a2 : a2.parent).name);
        }).style("stroke", "#FFF").on("click", function(a2) {
          d !== c && c !== a2 && (d = c), c = a2, v.transition().duration(n).attrTween("d", u2(a2));
        }).each(t2).on("dblclick", function(a2) {
          d.parent == a2 && v.transition().duration(n).attrTween("d", u2(e));
        }).each(t2).on("mouseover", function(a2, b3) {
          d3.select(this).classed("hover", true).style("opacity", 0.8), o.elementMouseover({ data: a2, color: d3.select(this).style("fill") });
        }).on("mouseout", function(a2, b3) {
          d3.select(this).classed("hover", false).style("opacity", 1), o.elementMouseout({ data: a2 });
        }).on("mousemove", function(a2, b3) {
          o.elementMousemove({ data: a2 });
        });
      }), t.renderEnd("sunburst immediate"), b;
    }
    var c, d, e, f = { top: 0, right: 0, bottom: 0, left: 0 }, g = null, h = null, i = "count", j = { count: function(a2) {
      return 1;
    }, size: function(a2) {
      return a2.size;
    } }, k = Math.floor(1e4 * Math.random()), l = null, m = a.utils.defaultColor(), n = 500, o = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMousemove", "elementMouseover", "elementMouseout", "renderEnd"), p = d3.scale.linear().range([0, 2 * Math.PI]), q = d3.scale.sqrt(), r = d3.layout.partition().sort(null).value(function(a2) {
      return 1;
    }), s = d3.svg.arc().startAngle(function(a2) {
      return Math.max(0, Math.min(2 * Math.PI, p(a2.x)));
    }).endAngle(function(a2) {
      return Math.max(0, Math.min(2 * Math.PI, p(a2.x + a2.dx)));
    }).innerRadius(function(a2) {
      return Math.max(0, q(a2.y));
    }).outerRadius(function(a2) {
      return Math.max(0, q(a2.y + a2.dy));
    }), t = a.utils.renderWatch(o);
    return b.dispatch = o, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { width: { get: function() {
      return g;
    }, set: function(a2) {
      g = a2;
    } }, height: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2;
    } }, mode: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, id: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2;
    } }, duration: { get: function() {
      return n;
    }, set: function(a2) {
      n = a2;
    } }, margin: { get: function() {
      return f;
    }, set: function(a2) {
      f.top = void 0 != a2.top ? a2.top : f.top, f.right = void 0 != a2.right ? a2.right : f.right, f.bottom = void 0 != a2.bottom ? a2.bottom : f.bottom, f.left = void 0 != a2.left ? a2.left : f.left;
    } }, color: { get: function() {
      return m;
    }, set: function(b2) {
      m = a.utils.getColor(b2);
    } } }), a.utils.initOptions(b), b;
  }, a.models.sunburstChart = function() {
    "use strict";
    function b(d2) {
      return m.reset(), m.models(c), d2.each(function(d4) {
        var h2 = d3.select(this);
        a.utils.initSVG(h2);
        var i2 = a.utils.availableWidth(f, h2, e), j2 = a.utils.availableHeight(g, h2, e);
        if (b.update = function() {
          0 === k ? h2.call(b) : h2.transition().duration(k).call(b);
        }, b.container = this, !d4 || !d4.length) return a.utils.noData(b, h2), b;
        h2.selectAll(".nv-noData").remove();
        var l2 = h2.selectAll("g.nv-wrap.nv-sunburstChart").data(d4), m2 = l2.enter().append("g").attr("class", "nvd3 nv-wrap nv-sunburstChart").append("g"), n = l2.select("g");
        m2.append("g").attr("class", "nv-sunburstWrap"), l2.attr("transform", "translate(" + e.left + "," + e.top + ")"), c.width(i2).height(j2);
        var o = n.select(".nv-sunburstWrap").datum(d4);
        d3.transition(o).call(c);
      }), m.renderEnd("sunburstChart immediate"), b;
    }
    var c = a.models.sunburst(), d = a.models.tooltip(), e = { top: 30, right: 20, bottom: 20, left: 20 }, f = null, g = null, h = a.utils.defaultColor(), i = (Math.round(1e5 * Math.random()), null), j = null, k = 250, l = d3.dispatch("stateChange", "changeState", "renderEnd");
    d.duration(0);
    var m = a.utils.renderWatch(l);
    return d.headerEnabled(false).valueFormatter(function(a2, b2) {
      return a2;
    }), c.dispatch.on("elementMouseover.tooltip", function(a2) {
      a2.series = { key: a2.data.name, value: a2.data.size, color: a2.color }, d.data(a2).hidden(false);
    }), c.dispatch.on("elementMouseout.tooltip", function(a2) {
      d.hidden(true);
    }), c.dispatch.on("elementMousemove.tooltip", function(a2) {
      d();
    }), b.dispatch = l, b.sunburst = c, b.tooltip = d, b.options = a.utils.optionsFunc.bind(b), b._options = Object.create({}, { noData: { get: function() {
      return j;
    }, set: function(a2) {
      j = a2;
    } }, defaultState: { get: function() {
      return i;
    }, set: function(a2) {
      i = a2;
    } }, color: { get: function() {
      return h;
    }, set: function(a2) {
      h = a2, c.color(h);
    } }, duration: { get: function() {
      return k;
    }, set: function(a2) {
      k = a2, m.reset(k), c.duration(k);
    } }, margin: { get: function() {
      return e;
    }, set: function(a2) {
      e.top = void 0 !== a2.top ? a2.top : e.top, e.right = void 0 !== a2.right ? a2.right : e.right, e.bottom = void 0 !== a2.bottom ? a2.bottom : e.bottom, e.left = void 0 !== a2.left ? a2.left : e.left;
    } } }), a.utils.inheritOptions(b, c), a.utils.initOptions(b), b;
  }, a.version = "1.8.1-dev";
}();

// src/helpers/pptx/Style.ts
var StyleTable = class {
  constructor() {
    this.map = {};
  }
  get(key) {
    return this.map[key];
  }
  update(key, item) {
    this.map[key] = item;
  }
  nextIndex() {
    return Object.keys(this.map).length + 1;
  }
  has(key) {
    return key in this.map;
  }
  genGlobalCSS() {
    let cssText = "";
    for (var key in this.map) {
      let tagname = "";
      cssText += tagname + " ." + this.map[key]["name"] + "{" + this.map[key]["text"] + "}\n";
    }
    return cssText;
  }
};

// src/helpers/pptx/Slide.ts
var _uuid = require('uuid');

var _tinycolor2 = require('tinycolor2'); var _tinycolor22 = _interopRequireDefault(_tinycolor2);

// src/helpers/pptx/utils/dingbatUnicode.ts
var dingbatUnicode = [
  { "f": "Webdings", "code": "33", "unicode": "128375" },
  { "f": "Webdings", "code": "34", "unicode": "128376" },
  { "f": "Webdings", "code": "35", "unicode": "128370" },
  { "f": "Webdings", "code": "36", "unicode": "128374" },
  { "f": "Webdings", "code": "37", "unicode": "127942" },
  { "f": "Webdings", "code": "38", "unicode": "127894" },
  { "f": "Webdings", "code": "39", "unicode": "128391" },
  { "f": "Webdings", "code": "40", "unicode": "128488" },
  { "f": "Webdings", "code": "41", "unicode": "128489" },
  { "f": "Webdings", "code": "42", "unicode": "128496" },
  { "f": "Webdings", "code": "43", "unicode": "128497" },
  { "f": "Webdings", "code": "44", "unicode": "127798" },
  { "f": "Webdings", "code": "45", "unicode": "127895" },
  { "f": "Webdings", "code": "46", "unicode": "128638" },
  { "f": "Webdings", "code": "47", "unicode": "128636" },
  { "f": "Webdings", "code": "48", "unicode": "128469" },
  { "f": "Webdings", "code": "49", "unicode": "128470" },
  { "f": "Webdings", "code": "50", "unicode": "128471" },
  { "f": "Webdings", "code": "51", "unicode": "9204" },
  { "f": "Webdings", "code": "52", "unicode": "9205" },
  { "f": "Webdings", "code": "53", "unicode": "9206" },
  { "f": "Webdings", "code": "54", "unicode": "9207" },
  { "f": "Webdings", "code": "55", "unicode": "9194" },
  { "f": "Webdings", "code": "56", "unicode": "9193" },
  { "f": "Webdings", "code": "57", "unicode": "9198" },
  { "f": "Webdings", "code": "58", "unicode": "9197" },
  { "f": "Webdings", "code": "59", "unicode": "9208" },
  { "f": "Webdings", "code": "60", "unicode": "9209" },
  { "f": "Webdings", "code": "61", "unicode": "9210" },
  { "f": "Webdings", "code": "62", "unicode": "128474" },
  { "f": "Webdings", "code": "63", "unicode": "128499" },
  { "f": "Webdings", "code": "64", "unicode": "128736" },
  { "f": "Webdings", "code": "65", "unicode": "127959" },
  { "f": "Webdings", "code": "66", "unicode": "127960" },
  { "f": "Webdings", "code": "67", "unicode": "127961" },
  { "f": "Webdings", "code": "68", "unicode": "127962" },
  { "f": "Webdings", "code": "69", "unicode": "127964" },
  { "f": "Webdings", "code": "70", "unicode": "127981" },
  { "f": "Webdings", "code": "71", "unicode": "127963" },
  { "f": "Webdings", "code": "72", "unicode": "127968" },
  { "f": "Webdings", "code": "73", "unicode": "127958" },
  { "f": "Webdings", "code": "74", "unicode": "127965" },
  { "f": "Webdings", "code": "75", "unicode": "128739" },
  { "f": "Webdings", "code": "76", "unicode": "128269" },
  { "f": "Webdings", "code": "77", "unicode": "127956" },
  { "f": "Webdings", "code": "78", "unicode": "128065" },
  { "f": "Webdings", "code": "79", "unicode": "128066" },
  { "f": "Webdings", "code": "80", "unicode": "127966" },
  { "f": "Webdings", "code": "81", "unicode": "127957" },
  { "f": "Webdings", "code": "82", "unicode": "128740" },
  { "f": "Webdings", "code": "83", "unicode": "127967" },
  { "f": "Webdings", "code": "84", "unicode": "128755" },
  { "f": "Webdings", "code": "85", "unicode": "128364" },
  { "f": "Webdings", "code": "86", "unicode": "128363" },
  { "f": "Webdings", "code": "87", "unicode": "128360" },
  { "f": "Webdings", "code": "88", "unicode": "128264" },
  { "f": "Webdings", "code": "89", "unicode": "127892" },
  { "f": "Webdings", "code": "90", "unicode": "127893" },
  { "f": "Webdings", "code": "91", "unicode": "128492" },
  { "f": "Webdings", "code": "92", "unicode": "128637" },
  { "f": "Webdings", "code": "93", "unicode": "128493" },
  { "f": "Webdings", "code": "94", "unicode": "128490" },
  { "f": "Webdings", "code": "95", "unicode": "128491" },
  { "f": "Webdings", "code": "96", "unicode": "11156" },
  { "f": "Webdings", "code": "97", "unicode": "10004" },
  { "f": "Webdings", "code": "98", "unicode": "128690" },
  { "f": "Webdings", "code": "99", "unicode": "11036" },
  { "f": "Webdings", "code": "100", "unicode": "128737" },
  { "f": "Webdings", "code": "101", "unicode": "128230" },
  { "f": "Webdings", "code": "102", "unicode": "128753" },
  { "f": "Webdings", "code": "103", "unicode": "11035" },
  { "f": "Webdings", "code": "104", "unicode": "128657" },
  { "f": "Webdings", "code": "105", "unicode": "128712" },
  { "f": "Webdings", "code": "106", "unicode": "128745" },
  { "f": "Webdings", "code": "107", "unicode": "128752" },
  { "f": "Webdings", "code": "108", "unicode": "128968" },
  { "f": "Webdings", "code": "109", "unicode": "128372" },
  { "f": "Webdings", "code": "110", "unicode": "11044" },
  { "f": "Webdings", "code": "111", "unicode": "128741" },
  { "f": "Webdings", "code": "112", "unicode": "128660" },
  { "f": "Webdings", "code": "113", "unicode": "128472" },
  { "f": "Webdings", "code": "114", "unicode": "128473" },
  { "f": "Webdings", "code": "115", "unicode": "10067" },
  { "f": "Webdings", "code": "116", "unicode": "128754" },
  { "f": "Webdings", "code": "117", "unicode": "128647" },
  { "f": "Webdings", "code": "118", "unicode": "128653" },
  { "f": "Webdings", "code": "119", "unicode": "9971" },
  { "f": "Webdings", "code": "120", "unicode": "10680" },
  { "f": "Webdings", "code": "121", "unicode": "8854" },
  { "f": "Webdings", "code": "122", "unicode": "128685" },
  { "f": "Webdings", "code": "123", "unicode": "128494" },
  { "f": "Webdings", "code": "124", "unicode": "9168" },
  { "f": "Webdings", "code": "125", "unicode": "128495" },
  { "f": "Webdings", "code": "126", "unicode": "128498" },
  { "f": "Webdings", "code": "128", "unicode": "128697" },
  { "f": "Webdings", "code": "129", "unicode": "128698" },
  { "f": "Webdings", "code": "130", "unicode": "128713" },
  { "f": "Webdings", "code": "131", "unicode": "128714" },
  { "f": "Webdings", "code": "132", "unicode": "128700" },
  { "f": "Webdings", "code": "133", "unicode": "128125" },
  { "f": "Webdings", "code": "134", "unicode": "127947" },
  { "f": "Webdings", "code": "135", "unicode": "9975" },
  { "f": "Webdings", "code": "136", "unicode": "127938" },
  { "f": "Webdings", "code": "137", "unicode": "127948" },
  { "f": "Webdings", "code": "138", "unicode": "127946" },
  { "f": "Webdings", "code": "139", "unicode": "127940" },
  { "f": "Webdings", "code": "140", "unicode": "127949" },
  { "f": "Webdings", "code": "141", "unicode": "127950" },
  { "f": "Webdings", "code": "142", "unicode": "128664" },
  { "f": "Webdings", "code": "143", "unicode": "128480" },
  { "f": "Webdings", "code": "144", "unicode": "128738" },
  { "f": "Webdings", "code": "145", "unicode": "128176" },
  { "f": "Webdings", "code": "146", "unicode": "127991" },
  { "f": "Webdings", "code": "147", "unicode": "128179" },
  { "f": "Webdings", "code": "148", "unicode": "128106" },
  { "f": "Webdings", "code": "149", "unicode": "128481" },
  { "f": "Webdings", "code": "150", "unicode": "128482" },
  { "f": "Webdings", "code": "151", "unicode": "128483" },
  { "f": "Webdings", "code": "152", "unicode": "10031" },
  { "f": "Webdings", "code": "153", "unicode": "128388" },
  { "f": "Webdings", "code": "154", "unicode": "128389" },
  { "f": "Webdings", "code": "155", "unicode": "128387" },
  { "f": "Webdings", "code": "156", "unicode": "128390" },
  { "f": "Webdings", "code": "157", "unicode": "128441" },
  { "f": "Webdings", "code": "158", "unicode": "128442" },
  { "f": "Webdings", "code": "159", "unicode": "128443" },
  { "f": "Webdings", "code": "160", "unicode": "128373" },
  { "f": "Webdings", "code": "161", "unicode": "128368" },
  { "f": "Webdings", "code": "162", "unicode": "128445" },
  { "f": "Webdings", "code": "163", "unicode": "128446" },
  { "f": "Webdings", "code": "164", "unicode": "128203" },
  { "f": "Webdings", "code": "165", "unicode": "128466" },
  { "f": "Webdings", "code": "166", "unicode": "128467" },
  { "f": "Webdings", "code": "167", "unicode": "128366" },
  { "f": "Webdings", "code": "168", "unicode": "128218" },
  { "f": "Webdings", "code": "169", "unicode": "128478" },
  { "f": "Webdings", "code": "170", "unicode": "128479" },
  { "f": "Webdings", "code": "171", "unicode": "128451" },
  { "f": "Webdings", "code": "172", "unicode": "128450" },
  { "f": "Webdings", "code": "173", "unicode": "128444" },
  { "f": "Webdings", "code": "174", "unicode": "127917" },
  { "f": "Webdings", "code": "175", "unicode": "127900" },
  { "f": "Webdings", "code": "176", "unicode": "127896" },
  { "f": "Webdings", "code": "177", "unicode": "127897" },
  { "f": "Webdings", "code": "178", "unicode": "127911" },
  { "f": "Webdings", "code": "179", "unicode": "128191" },
  { "f": "Webdings", "code": "180", "unicode": "127902" },
  { "f": "Webdings", "code": "181", "unicode": "128247" },
  { "f": "Webdings", "code": "182", "unicode": "127903" },
  { "f": "Webdings", "code": "183", "unicode": "127916" },
  { "f": "Webdings", "code": "184", "unicode": "128253" },
  { "f": "Webdings", "code": "185", "unicode": "128249" },
  { "f": "Webdings", "code": "186", "unicode": "128254" },
  { "f": "Webdings", "code": "187", "unicode": "128251" },
  { "f": "Webdings", "code": "188", "unicode": "127898" },
  { "f": "Webdings", "code": "189", "unicode": "127899" },
  { "f": "Webdings", "code": "190", "unicode": "128250" },
  { "f": "Webdings", "code": "191", "unicode": "128187" },
  { "f": "Webdings", "code": "192", "unicode": "128421" },
  { "f": "Webdings", "code": "193", "unicode": "128422" },
  { "f": "Webdings", "code": "194", "unicode": "128423" },
  { "f": "Webdings", "code": "195", "unicode": "128377" },
  { "f": "Webdings", "code": "196", "unicode": "127918" },
  { "f": "Webdings", "code": "197", "unicode": "128379" },
  { "f": "Webdings", "code": "198", "unicode": "128380" },
  { "f": "Webdings", "code": "199", "unicode": "128223" },
  { "f": "Webdings", "code": "200", "unicode": "128385" },
  { "f": "Webdings", "code": "201", "unicode": "128384" },
  { "f": "Webdings", "code": "202", "unicode": "128424" },
  { "f": "Webdings", "code": "203", "unicode": "128425" },
  { "f": "Webdings", "code": "204", "unicode": "128447" },
  { "f": "Webdings", "code": "205", "unicode": "128426" },
  { "f": "Webdings", "code": "206", "unicode": "128476" },
  { "f": "Webdings", "code": "207", "unicode": "128274" },
  { "f": "Webdings", "code": "208", "unicode": "128275" },
  { "f": "Webdings", "code": "209", "unicode": "128477" },
  { "f": "Webdings", "code": "210", "unicode": "128229" },
  { "f": "Webdings", "code": "211", "unicode": "128228" },
  { "f": "Webdings", "code": "212", "unicode": "128371" },
  { "f": "Webdings", "code": "213", "unicode": "127779" },
  { "f": "Webdings", "code": "214", "unicode": "127780" },
  { "f": "Webdings", "code": "215", "unicode": "127781" },
  { "f": "Webdings", "code": "216", "unicode": "127782" },
  { "f": "Webdings", "code": "217", "unicode": "9729" },
  { "f": "Webdings", "code": "218", "unicode": "127784" },
  { "f": "Webdings", "code": "219", "unicode": "127783" },
  { "f": "Webdings", "code": "220", "unicode": "127785" },
  { "f": "Webdings", "code": "221", "unicode": "127786" },
  { "f": "Webdings", "code": "222", "unicode": "127788" },
  { "f": "Webdings", "code": "223", "unicode": "127787" },
  { "f": "Webdings", "code": "224", "unicode": "127772" },
  { "f": "Webdings", "code": "225", "unicode": "127777" },
  { "f": "Webdings", "code": "226", "unicode": "128715" },
  { "f": "Webdings", "code": "227", "unicode": "128719" },
  { "f": "Webdings", "code": "228", "unicode": "127869" },
  { "f": "Webdings", "code": "229", "unicode": "127864" },
  { "f": "Webdings", "code": "230", "unicode": "128718" },
  { "f": "Webdings", "code": "231", "unicode": "128717" },
  { "f": "Webdings", "code": "232", "unicode": "9413" },
  { "f": "Webdings", "code": "233", "unicode": "9855" },
  { "f": "Webdings", "code": "234", "unicode": "128710" },
  { "f": "Webdings", "code": "235", "unicode": "128392" },
  { "f": "Webdings", "code": "236", "unicode": "127891" },
  { "f": "Webdings", "code": "237", "unicode": "128484" },
  { "f": "Webdings", "code": "238", "unicode": "128485" },
  { "f": "Webdings", "code": "239", "unicode": "128486" },
  { "f": "Webdings", "code": "240", "unicode": "128487" },
  { "f": "Webdings", "code": "241", "unicode": "128746" },
  { "f": "Webdings", "code": "242", "unicode": "128063" },
  { "f": "Webdings", "code": "243", "unicode": "128038" },
  { "f": "Webdings", "code": "244", "unicode": "128031" },
  { "f": "Webdings", "code": "245", "unicode": "128021" },
  { "f": "Webdings", "code": "246", "unicode": "128008" },
  { "f": "Webdings", "code": "247", "unicode": "128620" },
  { "f": "Webdings", "code": "248", "unicode": "128622" },
  { "f": "Webdings", "code": "249", "unicode": "128621" },
  { "f": "Webdings", "code": "250", "unicode": "128623" },
  { "f": "Webdings", "code": "251", "unicode": "128506" },
  { "f": "Webdings", "code": "252", "unicode": "127757" },
  { "f": "Webdings", "code": "253", "unicode": "127759" },
  { "f": "Webdings", "code": "254", "unicode": "127758" },
  { "f": "Webdings", "code": "255", "unicode": "128330" },
  { "f": "Wingdings", "code": "32", "unicode": "32" },
  { "f": "Wingdings", "code": "33", "unicode": "128393" },
  { "f": "Wingdings", "code": "34", "unicode": "9986" },
  { "f": "Wingdings", "code": "35", "unicode": "9985" },
  { "f": "Wingdings", "code": "36", "unicode": "128083" },
  { "f": "Wingdings", "code": "37", "unicode": "128365" },
  { "f": "Wingdings", "code": "38", "unicode": "128366" },
  { "f": "Wingdings", "code": "39", "unicode": "128367" },
  { "f": "Wingdings", "code": "40", "unicode": "128383" },
  { "f": "Wingdings", "code": "41", "unicode": "9990" },
  { "f": "Wingdings", "code": "42", "unicode": "128386" },
  { "f": "Wingdings", "code": "43", "unicode": "128387" },
  { "f": "Wingdings", "code": "44", "unicode": "128234" },
  { "f": "Wingdings", "code": "45", "unicode": "128235" },
  { "f": "Wingdings", "code": "46", "unicode": "128236" },
  { "f": "Wingdings", "code": "47", "unicode": "128237" },
  { "f": "Wingdings", "code": "48", "unicode": "128448" },
  { "f": "Wingdings", "code": "49", "unicode": "128449" },
  { "f": "Wingdings", "code": "50", "unicode": "128462" },
  { "f": "Wingdings", "code": "51", "unicode": "128463" },
  { "f": "Wingdings", "code": "52", "unicode": "128464" },
  { "f": "Wingdings", "code": "53", "unicode": "128452" },
  { "f": "Wingdings", "code": "54", "unicode": "8987" },
  { "f": "Wingdings", "code": "55", "unicode": "128430" },
  { "f": "Wingdings", "code": "56", "unicode": "128432" },
  { "f": "Wingdings", "code": "57", "unicode": "128434" },
  { "f": "Wingdings", "code": "58", "unicode": "128435" },
  { "f": "Wingdings", "code": "59", "unicode": "128436" },
  { "f": "Wingdings", "code": "60", "unicode": "128427" },
  { "f": "Wingdings", "code": "61", "unicode": "128428" },
  { "f": "Wingdings", "code": "62", "unicode": "9991" },
  { "f": "Wingdings", "code": "63", "unicode": "9997" },
  { "f": "Wingdings", "code": "64", "unicode": "128398" },
  { "f": "Wingdings", "code": "65", "unicode": "9996" },
  { "f": "Wingdings", "code": "66", "unicode": "128399" },
  { "f": "Wingdings", "code": "67", "unicode": "128077" },
  { "f": "Wingdings", "code": "68", "unicode": "128078" },
  { "f": "Wingdings", "code": "69", "unicode": "9756" },
  { "f": "Wingdings", "code": "70", "unicode": "9758" },
  { "f": "Wingdings", "code": "71", "unicode": "9757" },
  { "f": "Wingdings", "code": "72", "unicode": "9759" },
  { "f": "Wingdings", "code": "73", "unicode": "128400" },
  { "f": "Wingdings", "code": "74", "unicode": "9786" },
  { "f": "Wingdings", "code": "75", "unicode": "128528" },
  { "f": "Wingdings", "code": "76", "unicode": "9785" },
  { "f": "Wingdings", "code": "77", "unicode": "128163" },
  { "f": "Wingdings", "code": "78", "unicode": "128369" },
  { "f": "Wingdings", "code": "79", "unicode": "127987" },
  { "f": "Wingdings", "code": "80", "unicode": "127985" },
  { "f": "Wingdings", "code": "81", "unicode": "9992" },
  { "f": "Wingdings", "code": "82", "unicode": "9788" },
  { "f": "Wingdings", "code": "83", "unicode": "127778" },
  { "f": "Wingdings", "code": "84", "unicode": "10052" },
  { "f": "Wingdings", "code": "85", "unicode": "128326" },
  { "f": "Wingdings", "code": "86", "unicode": "10014" },
  { "f": "Wingdings", "code": "87", "unicode": "128328" },
  { "f": "Wingdings", "code": "88", "unicode": "10016" },
  { "f": "Wingdings", "code": "89", "unicode": "10017" },
  { "f": "Wingdings", "code": "90", "unicode": "9770" },
  { "f": "Wingdings", "code": "91", "unicode": "9775" },
  { "f": "Wingdings", "code": "92", "unicode": "128329" },
  { "f": "Wingdings", "code": "93", "unicode": "9784" },
  { "f": "Wingdings", "code": "94", "unicode": "9800" },
  { "f": "Wingdings", "code": "95", "unicode": "9801" },
  { "f": "Wingdings", "code": "96", "unicode": "9802" },
  { "f": "Wingdings", "code": "97", "unicode": "9803" },
  { "f": "Wingdings", "code": "98", "unicode": "9804" },
  { "f": "Wingdings", "code": "99", "unicode": "9805" },
  { "f": "Wingdings", "code": "100", "unicode": "9806" },
  { "f": "Wingdings", "code": "101", "unicode": "9807" },
  { "f": "Wingdings", "code": "102", "unicode": "9808" },
  { "f": "Wingdings", "code": "103", "unicode": "9809" },
  { "f": "Wingdings", "code": "104", "unicode": "9810" },
  { "f": "Wingdings", "code": "105", "unicode": "9811" },
  { "f": "Wingdings", "code": "106", "unicode": "128624" },
  { "f": "Wingdings", "code": "107", "unicode": "128629" },
  { "f": "Wingdings", "code": "108", "unicode": "9899" },
  { "f": "Wingdings", "code": "109", "unicode": "128318" },
  { "f": "Wingdings", "code": "110", "unicode": "9724" },
  { "f": "Wingdings", "code": "111", "unicode": "128911" },
  { "f": "Wingdings", "code": "112", "unicode": "128912" },
  { "f": "Wingdings", "code": "113", "unicode": "10065" },
  { "f": "Wingdings", "code": "114", "unicode": "10066" },
  { "f": "Wingdings", "code": "115", "unicode": "128927" },
  { "f": "Wingdings", "code": "116", "unicode": "10731" },
  { "f": "Wingdings", "code": "117", "unicode": "9670" },
  { "f": "Wingdings", "code": "118", "unicode": "10070" },
  { "f": "Wingdings", "code": "119", "unicode": "11049" },
  { "f": "Wingdings", "code": "120", "unicode": "8999" },
  { "f": "Wingdings", "code": "121", "unicode": "11193" },
  { "f": "Wingdings", "code": "122", "unicode": "8984" },
  { "f": "Wingdings", "code": "123", "unicode": "127989" },
  { "f": "Wingdings", "code": "124", "unicode": "127990" },
  { "f": "Wingdings", "code": "125", "unicode": "128630" },
  { "f": "Wingdings", "code": "126", "unicode": "128631" },
  { "f": "Wingdings", "code": "127", "unicode": "9647" },
  { "f": "Wingdings", "code": "128", "unicode": "127243" },
  { "f": "Wingdings", "code": "129", "unicode": "10112" },
  { "f": "Wingdings", "code": "130", "unicode": "10113" },
  { "f": "Wingdings", "code": "131", "unicode": "10114" },
  { "f": "Wingdings", "code": "132", "unicode": "10115" },
  { "f": "Wingdings", "code": "133", "unicode": "10116" },
  { "f": "Wingdings", "code": "134", "unicode": "10117" },
  { "f": "Wingdings", "code": "135", "unicode": "10118" },
  { "f": "Wingdings", "code": "136", "unicode": "10119" },
  { "f": "Wingdings", "code": "137", "unicode": "10120" },
  { "f": "Wingdings", "code": "138", "unicode": "10121" },
  { "f": "Wingdings", "code": "139", "unicode": "127244" },
  { "f": "Wingdings", "code": "140", "unicode": "10122" },
  { "f": "Wingdings", "code": "141", "unicode": "10123" },
  { "f": "Wingdings", "code": "142", "unicode": "10124" },
  { "f": "Wingdings", "code": "143", "unicode": "10125" },
  { "f": "Wingdings", "code": "144", "unicode": "10126" },
  { "f": "Wingdings", "code": "145", "unicode": "10127" },
  { "f": "Wingdings", "code": "146", "unicode": "10128" },
  { "f": "Wingdings", "code": "147", "unicode": "10129" },
  { "f": "Wingdings", "code": "148", "unicode": "10130" },
  { "f": "Wingdings", "code": "149", "unicode": "10131" },
  { "f": "Wingdings", "code": "150", "unicode": "128610" },
  { "f": "Wingdings", "code": "151", "unicode": "128608" },
  { "f": "Wingdings", "code": "152", "unicode": "128609" },
  { "f": "Wingdings", "code": "153", "unicode": "128611" },
  { "f": "Wingdings", "code": "154", "unicode": "128606" },
  { "f": "Wingdings", "code": "155", "unicode": "128604" },
  { "f": "Wingdings", "code": "156", "unicode": "128605" },
  { "f": "Wingdings", "code": "157", "unicode": "128607" },
  { "f": "Wingdings", "code": "158", "unicode": "8729" },
  { "f": "Wingdings", "code": "159", "unicode": "8226" },
  { "f": "Wingdings", "code": "160", "unicode": "11037" },
  { "f": "Wingdings", "code": "161", "unicode": "11096" },
  { "f": "Wingdings", "code": "162", "unicode": "128902" },
  { "f": "Wingdings", "code": "163", "unicode": "128904" },
  { "f": "Wingdings", "code": "164", "unicode": "128906" },
  { "f": "Wingdings", "code": "165", "unicode": "128907" },
  { "f": "Wingdings", "code": "166", "unicode": "128319" },
  { "f": "Wingdings", "code": "167", "unicode": "9642" },
  { "f": "Wingdings", "code": "168", "unicode": "128910" },
  { "f": "Wingdings", "code": "169", "unicode": "128961" },
  { "f": "Wingdings", "code": "170", "unicode": "128965" },
  { "f": "Wingdings", "code": "171", "unicode": "9733" },
  { "f": "Wingdings", "code": "172", "unicode": "128971" },
  { "f": "Wingdings", "code": "173", "unicode": "128975" },
  { "f": "Wingdings", "code": "174", "unicode": "128979" },
  { "f": "Wingdings", "code": "175", "unicode": "128977" },
  { "f": "Wingdings", "code": "176", "unicode": "11216" },
  { "f": "Wingdings", "code": "177", "unicode": "8982" },
  { "f": "Wingdings", "code": "178", "unicode": "11214" },
  { "f": "Wingdings", "code": "179", "unicode": "11215" },
  { "f": "Wingdings", "code": "180", "unicode": "11217" },
  { "f": "Wingdings", "code": "181", "unicode": "10026" },
  { "f": "Wingdings", "code": "182", "unicode": "10032" },
  { "f": "Wingdings", "code": "183", "unicode": "128336" },
  { "f": "Wingdings", "code": "184", "unicode": "128337" },
  { "f": "Wingdings", "code": "185", "unicode": "128338" },
  { "f": "Wingdings", "code": "186", "unicode": "128339" },
  { "f": "Wingdings", "code": "187", "unicode": "128340" },
  { "f": "Wingdings", "code": "188", "unicode": "128341" },
  { "f": "Wingdings", "code": "189", "unicode": "128342" },
  { "f": "Wingdings", "code": "190", "unicode": "128343" },
  { "f": "Wingdings", "code": "191", "unicode": "128344" },
  { "f": "Wingdings", "code": "192", "unicode": "128345" },
  { "f": "Wingdings", "code": "193", "unicode": "128346" },
  { "f": "Wingdings", "code": "194", "unicode": "128347" },
  { "f": "Wingdings", "code": "195", "unicode": "11184" },
  { "f": "Wingdings", "code": "196", "unicode": "11185" },
  { "f": "Wingdings", "code": "197", "unicode": "11186" },
  { "f": "Wingdings", "code": "198", "unicode": "11187" },
  { "f": "Wingdings", "code": "199", "unicode": "11188" },
  { "f": "Wingdings", "code": "200", "unicode": "11189" },
  { "f": "Wingdings", "code": "201", "unicode": "11190" },
  { "f": "Wingdings", "code": "202", "unicode": "11191" },
  { "f": "Wingdings", "code": "203", "unicode": "128618" },
  { "f": "Wingdings", "code": "204", "unicode": "128619" },
  { "f": "Wingdings", "code": "205", "unicode": "128597" },
  { "f": "Wingdings", "code": "206", "unicode": "128596" },
  { "f": "Wingdings", "code": "207", "unicode": "128599" },
  { "f": "Wingdings", "code": "208", "unicode": "128598" },
  { "f": "Wingdings", "code": "209", "unicode": "128592" },
  { "f": "Wingdings", "code": "210", "unicode": "128593" },
  { "f": "Wingdings", "code": "211", "unicode": "128594" },
  { "f": "Wingdings", "code": "212", "unicode": "128595" },
  { "f": "Wingdings", "code": "213", "unicode": "9003" },
  { "f": "Wingdings", "code": "214", "unicode": "8998" },
  { "f": "Wingdings", "code": "215", "unicode": "11160" },
  { "f": "Wingdings", "code": "216", "unicode": "11162" },
  { "f": "Wingdings", "code": "217", "unicode": "11161" },
  { "f": "Wingdings", "code": "218", "unicode": "11163" },
  { "f": "Wingdings", "code": "219", "unicode": "11144" },
  { "f": "Wingdings", "code": "220", "unicode": "11146" },
  { "f": "Wingdings", "code": "221", "unicode": "11145" },
  { "f": "Wingdings", "code": "222", "unicode": "11147" },
  { "f": "Wingdings", "code": "223", "unicode": "129128" },
  { "f": "Wingdings", "code": "224", "unicode": "129130" },
  { "f": "Wingdings", "code": "225", "unicode": "129129" },
  { "f": "Wingdings", "code": "226", "unicode": "129131" },
  { "f": "Wingdings", "code": "227", "unicode": "129132" },
  { "f": "Wingdings", "code": "228", "unicode": "129133" },
  { "f": "Wingdings", "code": "229", "unicode": "129135" },
  { "f": "Wingdings", "code": "230", "unicode": "129134" },
  { "f": "Wingdings", "code": "231", "unicode": "129144" },
  { "f": "Wingdings", "code": "232", "unicode": "129146" },
  { "f": "Wingdings", "code": "233", "unicode": "129145" },
  { "f": "Wingdings", "code": "234", "unicode": "129147" },
  { "f": "Wingdings", "code": "235", "unicode": "129148" },
  { "f": "Wingdings", "code": "236", "unicode": "129149" },
  { "f": "Wingdings", "code": "237", "unicode": "129151" },
  { "f": "Wingdings", "code": "238", "unicode": "129150" },
  { "f": "Wingdings", "code": "239", "unicode": "8678" },
  { "f": "Wingdings", "code": "240", "unicode": "8680" },
  { "f": "Wingdings", "code": "241", "unicode": "8679" },
  { "f": "Wingdings", "code": "242", "unicode": "8681" },
  { "f": "Wingdings", "code": "243", "unicode": "11012" },
  { "f": "Wingdings", "code": "244", "unicode": "8691" },
  { "f": "Wingdings", "code": "245", "unicode": "11009" },
  { "f": "Wingdings", "code": "246", "unicode": "11008" },
  { "f": "Wingdings", "code": "247", "unicode": "11011" },
  { "f": "Wingdings", "code": "248", "unicode": "11010" },
  { "f": "Wingdings", "code": "249", "unicode": "129196" },
  { "f": "Wingdings", "code": "250", "unicode": "129197" },
  { "f": "Wingdings", "code": "251", "unicode": "128502" },
  { "f": "Wingdings", "code": "252", "unicode": "10003" },
  { "f": "Wingdings", "code": "253", "unicode": "128503" },
  { "f": "Wingdings", "code": "254", "unicode": "128505" },
  { "f": "Wingdings 2", "code": "32", "unicode": "32" },
  { "f": "Wingdings 2", "code": "33", "unicode": "128394" },
  { "f": "Wingdings 2", "code": "34", "unicode": "128395" },
  { "f": "Wingdings 2", "code": "35", "unicode": "128396" },
  { "f": "Wingdings 2", "code": "36", "unicode": "128397" },
  { "f": "Wingdings 2", "code": "37", "unicode": "9988" },
  { "f": "Wingdings 2", "code": "38", "unicode": "9984" },
  { "f": "Wingdings 2", "code": "39", "unicode": "128382" },
  { "f": "Wingdings 2", "code": "40", "unicode": "128381" },
  { "f": "Wingdings 2", "code": "41", "unicode": "128453" },
  { "f": "Wingdings 2", "code": "42", "unicode": "128454" },
  { "f": "Wingdings 2", "code": "43", "unicode": "128455" },
  { "f": "Wingdings 2", "code": "44", "unicode": "128456" },
  { "f": "Wingdings 2", "code": "45", "unicode": "128457" },
  { "f": "Wingdings 2", "code": "46", "unicode": "128458" },
  { "f": "Wingdings 2", "code": "47", "unicode": "128459" },
  { "f": "Wingdings 2", "code": "48", "unicode": "128460" },
  { "f": "Wingdings 2", "code": "49", "unicode": "128461" },
  { "f": "Wingdings 2", "code": "50", "unicode": "128203" },
  { "f": "Wingdings 2", "code": "51", "unicode": "128465" },
  { "f": "Wingdings 2", "code": "52", "unicode": "128468" },
  { "f": "Wingdings 2", "code": "53", "unicode": "128437" },
  { "f": "Wingdings 2", "code": "54", "unicode": "128438" },
  { "f": "Wingdings 2", "code": "55", "unicode": "128439" },
  { "f": "Wingdings 2", "code": "56", "unicode": "128440" },
  { "f": "Wingdings 2", "code": "57", "unicode": "128429" },
  { "f": "Wingdings 2", "code": "58", "unicode": "128431" },
  { "f": "Wingdings 2", "code": "59", "unicode": "128433" },
  { "f": "Wingdings 2", "code": "60", "unicode": "128402" },
  { "f": "Wingdings 2", "code": "61", "unicode": "128403" },
  { "f": "Wingdings 2", "code": "62", "unicode": "128408" },
  { "f": "Wingdings 2", "code": "63", "unicode": "128409" },
  { "f": "Wingdings 2", "code": "64", "unicode": "128410" },
  { "f": "Wingdings 2", "code": "65", "unicode": "128411" },
  { "f": "Wingdings 2", "code": "66", "unicode": "128072" },
  { "f": "Wingdings 2", "code": "67", "unicode": "128073" },
  { "f": "Wingdings 2", "code": "68", "unicode": "128412" },
  { "f": "Wingdings 2", "code": "69", "unicode": "128413" },
  { "f": "Wingdings 2", "code": "70", "unicode": "128414" },
  { "f": "Wingdings 2", "code": "71", "unicode": "128415" },
  { "f": "Wingdings 2", "code": "72", "unicode": "128416" },
  { "f": "Wingdings 2", "code": "73", "unicode": "128417" },
  { "f": "Wingdings 2", "code": "74", "unicode": "128070" },
  { "f": "Wingdings 2", "code": "75", "unicode": "128071" },
  { "f": "Wingdings 2", "code": "76", "unicode": "128418" },
  { "f": "Wingdings 2", "code": "77", "unicode": "128419" },
  { "f": "Wingdings 2", "code": "78", "unicode": "128401" },
  { "f": "Wingdings 2", "code": "79", "unicode": "128500" },
  { "f": "Wingdings 2", "code": "80", "unicode": "128504" },
  { "f": "Wingdings 2", "code": "81", "unicode": "128501" },
  { "f": "Wingdings 2", "code": "82", "unicode": "9745" },
  { "f": "Wingdings 2", "code": "83", "unicode": "11197" },
  { "f": "Wingdings 2", "code": "84", "unicode": "9746" },
  { "f": "Wingdings 2", "code": "85", "unicode": "11198" },
  { "f": "Wingdings 2", "code": "86", "unicode": "11199" },
  { "f": "Wingdings 2", "code": "87", "unicode": "128711" },
  { "f": "Wingdings 2", "code": "88", "unicode": "10680" },
  { "f": "Wingdings 2", "code": "89", "unicode": "128625" },
  { "f": "Wingdings 2", "code": "90", "unicode": "128628" },
  { "f": "Wingdings 2", "code": "91", "unicode": "128626" },
  { "f": "Wingdings 2", "code": "92", "unicode": "128627" },
  { "f": "Wingdings 2", "code": "93", "unicode": "8253" },
  { "f": "Wingdings 2", "code": "94", "unicode": "128633" },
  { "f": "Wingdings 2", "code": "95", "unicode": "128634" },
  { "f": "Wingdings 2", "code": "96", "unicode": "128635" },
  { "f": "Wingdings 2", "code": "97", "unicode": "128614" },
  { "f": "Wingdings 2", "code": "98", "unicode": "128612" },
  { "f": "Wingdings 2", "code": "99", "unicode": "128613" },
  { "f": "Wingdings 2", "code": "100", "unicode": "128615" },
  { "f": "Wingdings 2", "code": "101", "unicode": "128602" },
  { "f": "Wingdings 2", "code": "102", "unicode": "128600" },
  { "f": "Wingdings 2", "code": "103", "unicode": "128601" },
  { "f": "Wingdings 2", "code": "104", "unicode": "128603" },
  { "f": "Wingdings 2", "code": "105", "unicode": "9450" },
  { "f": "Wingdings 2", "code": "106", "unicode": "9312" },
  { "f": "Wingdings 2", "code": "107", "unicode": "9313" },
  { "f": "Wingdings 2", "code": "108", "unicode": "9314" },
  { "f": "Wingdings 2", "code": "109", "unicode": "9315" },
  { "f": "Wingdings 2", "code": "110", "unicode": "9316" },
  { "f": "Wingdings 2", "code": "111", "unicode": "9317" },
  { "f": "Wingdings 2", "code": "112", "unicode": "9318" },
  { "f": "Wingdings 2", "code": "113", "unicode": "9319" },
  { "f": "Wingdings 2", "code": "114", "unicode": "9320" },
  { "f": "Wingdings 2", "code": "115", "unicode": "9321" },
  { "f": "Wingdings 2", "code": "116", "unicode": "9471" },
  { "f": "Wingdings 2", "code": "117", "unicode": "10102" },
  { "f": "Wingdings 2", "code": "118", "unicode": "10103" },
  { "f": "Wingdings 2", "code": "119", "unicode": "10104" },
  { "f": "Wingdings 2", "code": "120", "unicode": "10105" },
  { "f": "Wingdings 2", "code": "121", "unicode": "10106" },
  { "f": "Wingdings 2", "code": "122", "unicode": "10107" },
  { "f": "Wingdings 2", "code": "123", "unicode": "10108" },
  { "f": "Wingdings 2", "code": "124", "unicode": "10109" },
  { "f": "Wingdings 2", "code": "125", "unicode": "10110" },
  { "f": "Wingdings 2", "code": "126", "unicode": "10111" },
  { "f": "Wingdings 2", "code": "128", "unicode": "9737" },
  { "f": "Wingdings 2", "code": "129", "unicode": "127765" },
  { "f": "Wingdings 2", "code": "130", "unicode": "9789" },
  { "f": "Wingdings 2", "code": "131", "unicode": "9790" },
  { "f": "Wingdings 2", "code": "132", "unicode": "11839" },
  { "f": "Wingdings 2", "code": "133", "unicode": "10013" },
  { "f": "Wingdings 2", "code": "134", "unicode": "128327" },
  { "f": "Wingdings 2", "code": "135", "unicode": "128348" },
  { "f": "Wingdings 2", "code": "136", "unicode": "128349" },
  { "f": "Wingdings 2", "code": "137", "unicode": "128350" },
  { "f": "Wingdings 2", "code": "138", "unicode": "128351" },
  { "f": "Wingdings 2", "code": "139", "unicode": "128352" },
  { "f": "Wingdings 2", "code": "140", "unicode": "128353" },
  { "f": "Wingdings 2", "code": "141", "unicode": "128354" },
  { "f": "Wingdings 2", "code": "142", "unicode": "128355" },
  { "f": "Wingdings 2", "code": "143", "unicode": "128356" },
  { "f": "Wingdings 2", "code": "144", "unicode": "128357" },
  { "f": "Wingdings 2", "code": "145", "unicode": "128358" },
  { "f": "Wingdings 2", "code": "146", "unicode": "128359" },
  { "f": "Wingdings 2", "code": "147", "unicode": "128616" },
  { "f": "Wingdings 2", "code": "148", "unicode": "128617" },
  { "f": "Wingdings 2", "code": "149", "unicode": "8901" },
  { "f": "Wingdings 2", "code": "150", "unicode": "128900" },
  { "f": "Wingdings 2", "code": "151", "unicode": "10625" },
  { "f": "Wingdings 2", "code": "152", "unicode": "9679" },
  { "f": "Wingdings 2", "code": "153", "unicode": "9675" },
  { "f": "Wingdings 2", "code": "154", "unicode": "128901" },
  { "f": "Wingdings 2", "code": "155", "unicode": "128903" },
  { "f": "Wingdings 2", "code": "156", "unicode": "128905" },
  { "f": "Wingdings 2", "code": "157", "unicode": "8857" },
  { "f": "Wingdings 2", "code": "158", "unicode": "10687" },
  { "f": "Wingdings 2", "code": "159", "unicode": "128908" },
  { "f": "Wingdings 2", "code": "160", "unicode": "128909" },
  { "f": "Wingdings 2", "code": "161", "unicode": "9726" },
  { "f": "Wingdings 2", "code": "162", "unicode": "9632" },
  { "f": "Wingdings 2", "code": "163", "unicode": "9633" },
  { "f": "Wingdings 2", "code": "164", "unicode": "128913" },
  { "f": "Wingdings 2", "code": "165", "unicode": "128914" },
  { "f": "Wingdings 2", "code": "166", "unicode": "128915" },
  { "f": "Wingdings 2", "code": "167", "unicode": "128916" },
  { "f": "Wingdings 2", "code": "168", "unicode": "9635" },
  { "f": "Wingdings 2", "code": "169", "unicode": "128917" },
  { "f": "Wingdings 2", "code": "170", "unicode": "128918" },
  { "f": "Wingdings 2", "code": "171", "unicode": "128919" },
  { "f": "Wingdings 2", "code": "172", "unicode": "128920" },
  { "f": "Wingdings 2", "code": "173", "unicode": "11049" },
  { "f": "Wingdings 2", "code": "174", "unicode": "11045" },
  { "f": "Wingdings 2", "code": "175", "unicode": "9671" },
  { "f": "Wingdings 2", "code": "176", "unicode": "128922" },
  { "f": "Wingdings 2", "code": "177", "unicode": "9672" },
  { "f": "Wingdings 2", "code": "178", "unicode": "128923" },
  { "f": "Wingdings 2", "code": "179", "unicode": "128924" },
  { "f": "Wingdings 2", "code": "180", "unicode": "128925" },
  { "f": "Wingdings 2", "code": "181", "unicode": "128926" },
  { "f": "Wingdings 2", "code": "182", "unicode": "11050" },
  { "f": "Wingdings 2", "code": "183", "unicode": "11047" },
  { "f": "Wingdings 2", "code": "184", "unicode": "9674" },
  { "f": "Wingdings 2", "code": "185", "unicode": "128928" },
  { "f": "Wingdings 2", "code": "186", "unicode": "9686" },
  { "f": "Wingdings 2", "code": "187", "unicode": "9687" },
  { "f": "Wingdings 2", "code": "188", "unicode": "11210" },
  { "f": "Wingdings 2", "code": "189", "unicode": "11211" },
  { "f": "Wingdings 2", "code": "190", "unicode": "11200" },
  { "f": "Wingdings 2", "code": "191", "unicode": "11201" },
  { "f": "Wingdings 2", "code": "192", "unicode": "11039" },
  { "f": "Wingdings 2", "code": "193", "unicode": "11202" },
  { "f": "Wingdings 2", "code": "194", "unicode": "11043" },
  { "f": "Wingdings 2", "code": "195", "unicode": "11042" },
  { "f": "Wingdings 2", "code": "196", "unicode": "11203" },
  { "f": "Wingdings 2", "code": "197", "unicode": "11204" },
  { "f": "Wingdings 2", "code": "198", "unicode": "128929" },
  { "f": "Wingdings 2", "code": "199", "unicode": "128930" },
  { "f": "Wingdings 2", "code": "200", "unicode": "128931" },
  { "f": "Wingdings 2", "code": "201", "unicode": "128932" },
  { "f": "Wingdings 2", "code": "202", "unicode": "128933" },
  { "f": "Wingdings 2", "code": "203", "unicode": "128934" },
  { "f": "Wingdings 2", "code": "204", "unicode": "128935" },
  { "f": "Wingdings 2", "code": "205", "unicode": "128936" },
  { "f": "Wingdings 2", "code": "206", "unicode": "128937" },
  { "f": "Wingdings 2", "code": "207", "unicode": "128938" },
  { "f": "Wingdings 2", "code": "208", "unicode": "128939" },
  { "f": "Wingdings 2", "code": "209", "unicode": "128940" },
  { "f": "Wingdings 2", "code": "210", "unicode": "128941" },
  { "f": "Wingdings 2", "code": "211", "unicode": "128942" },
  { "f": "Wingdings 2", "code": "212", "unicode": "128943" },
  { "f": "Wingdings 2", "code": "213", "unicode": "128944" },
  { "f": "Wingdings 2", "code": "214", "unicode": "128945" },
  { "f": "Wingdings 2", "code": "215", "unicode": "128946" },
  { "f": "Wingdings 2", "code": "216", "unicode": "128947" },
  { "f": "Wingdings 2", "code": "217", "unicode": "128948" },
  { "f": "Wingdings 2", "code": "218", "unicode": "128949" },
  { "f": "Wingdings 2", "code": "219", "unicode": "128950" },
  { "f": "Wingdings 2", "code": "220", "unicode": "128951" },
  { "f": "Wingdings 2", "code": "221", "unicode": "128952" },
  { "f": "Wingdings 2", "code": "222", "unicode": "128953" },
  { "f": "Wingdings 2", "code": "223", "unicode": "128954" },
  { "f": "Wingdings 2", "code": "224", "unicode": "128955" },
  { "f": "Wingdings 2", "code": "225", "unicode": "128956" },
  { "f": "Wingdings 2", "code": "226", "unicode": "128957" },
  { "f": "Wingdings 2", "code": "227", "unicode": "128958" },
  { "f": "Wingdings 2", "code": "228", "unicode": "128959" },
  { "f": "Wingdings 2", "code": "229", "unicode": "128960" },
  { "f": "Wingdings 2", "code": "230", "unicode": "128962" },
  { "f": "Wingdings 2", "code": "231", "unicode": "128964" },
  { "f": "Wingdings 2", "code": "232", "unicode": "128966" },
  { "f": "Wingdings 2", "code": "233", "unicode": "128969" },
  { "f": "Wingdings 2", "code": "234", "unicode": "128970" },
  { "f": "Wingdings 2", "code": "235", "unicode": "10038" },
  { "f": "Wingdings 2", "code": "236", "unicode": "128972" },
  { "f": "Wingdings 2", "code": "237", "unicode": "128974" },
  { "f": "Wingdings 2", "code": "238", "unicode": "128976" },
  { "f": "Wingdings 2", "code": "239", "unicode": "128978" },
  { "f": "Wingdings 2", "code": "240", "unicode": "10041" },
  { "f": "Wingdings 2", "code": "241", "unicode": "128963" },
  { "f": "Wingdings 2", "code": "242", "unicode": "128967" },
  { "f": "Wingdings 2", "code": "243", "unicode": "10031" },
  { "f": "Wingdings 2", "code": "244", "unicode": "128973" },
  { "f": "Wingdings 2", "code": "245", "unicode": "128980" },
  { "f": "Wingdings 2", "code": "246", "unicode": "11212" },
  { "f": "Wingdings 2", "code": "247", "unicode": "11213" },
  { "f": "Wingdings 2", "code": "248", "unicode": "8251" },
  { "f": "Wingdings 2", "code": "249", "unicode": "8258" },
  { "f": "Wingdings 3", "code": "32", "unicode": "32" },
  { "f": "Wingdings 3", "code": "33", "unicode": "11104" },
  { "f": "Wingdings 3", "code": "34", "unicode": "11106" },
  { "f": "Wingdings 3", "code": "35", "unicode": "11105" },
  { "f": "Wingdings 3", "code": "36", "unicode": "11107" },
  { "f": "Wingdings 3", "code": "37", "unicode": "11110" },
  { "f": "Wingdings 3", "code": "38", "unicode": "11111" },
  { "f": "Wingdings 3", "code": "39", "unicode": "11113" },
  { "f": "Wingdings 3", "code": "40", "unicode": "11112" },
  { "f": "Wingdings 3", "code": "41", "unicode": "11120" },
  { "f": "Wingdings 3", "code": "42", "unicode": "11122" },
  { "f": "Wingdings 3", "code": "43", "unicode": "11121" },
  { "f": "Wingdings 3", "code": "44", "unicode": "11123" },
  { "f": "Wingdings 3", "code": "45", "unicode": "11126" },
  { "f": "Wingdings 3", "code": "46", "unicode": "11128" },
  { "f": "Wingdings 3", "code": "47", "unicode": "11131" },
  { "f": "Wingdings 3", "code": "48", "unicode": "11133" },
  { "f": "Wingdings 3", "code": "49", "unicode": "11108" },
  { "f": "Wingdings 3", "code": "50", "unicode": "11109" },
  { "f": "Wingdings 3", "code": "51", "unicode": "11114" },
  { "f": "Wingdings 3", "code": "52", "unicode": "11116" },
  { "f": "Wingdings 3", "code": "53", "unicode": "11115" },
  { "f": "Wingdings 3", "code": "54", "unicode": "11117" },
  { "f": "Wingdings 3", "code": "55", "unicode": "11085" },
  { "f": "Wingdings 3", "code": "56", "unicode": "11168" },
  { "f": "Wingdings 3", "code": "57", "unicode": "11169" },
  { "f": "Wingdings 3", "code": "58", "unicode": "11170" },
  { "f": "Wingdings 3", "code": "59", "unicode": "11171" },
  { "f": "Wingdings 3", "code": "60", "unicode": "11172" },
  { "f": "Wingdings 3", "code": "61", "unicode": "11173" },
  { "f": "Wingdings 3", "code": "62", "unicode": "11174" },
  { "f": "Wingdings 3", "code": "63", "unicode": "11175" },
  { "f": "Wingdings 3", "code": "64", "unicode": "11152" },
  { "f": "Wingdings 3", "code": "65", "unicode": "11153" },
  { "f": "Wingdings 3", "code": "66", "unicode": "11154" },
  { "f": "Wingdings 3", "code": "67", "unicode": "11155" },
  { "f": "Wingdings 3", "code": "68", "unicode": "11136" },
  { "f": "Wingdings 3", "code": "69", "unicode": "11139" },
  { "f": "Wingdings 3", "code": "70", "unicode": "11134" },
  { "f": "Wingdings 3", "code": "71", "unicode": "11135" },
  { "f": "Wingdings 3", "code": "72", "unicode": "11140" },
  { "f": "Wingdings 3", "code": "73", "unicode": "11142" },
  { "f": "Wingdings 3", "code": "74", "unicode": "11141" },
  { "f": "Wingdings 3", "code": "75", "unicode": "11143" },
  { "f": "Wingdings 3", "code": "76", "unicode": "11151" },
  { "f": "Wingdings 3", "code": "77", "unicode": "11149" },
  { "f": "Wingdings 3", "code": "78", "unicode": "11150" },
  { "f": "Wingdings 3", "code": "79", "unicode": "11148" },
  { "f": "Wingdings 3", "code": "80", "unicode": "11118" },
  { "f": "Wingdings 3", "code": "81", "unicode": "11119" },
  { "f": "Wingdings 3", "code": "82", "unicode": "9099" },
  { "f": "Wingdings 3", "code": "83", "unicode": "8996" },
  { "f": "Wingdings 3", "code": "84", "unicode": "8963" },
  { "f": "Wingdings 3", "code": "85", "unicode": "8997" },
  { "f": "Wingdings 3", "code": "86", "unicode": "9251" },
  { "f": "Wingdings 3", "code": "87", "unicode": "9085" },
  { "f": "Wingdings 3", "code": "88", "unicode": "8682" },
  { "f": "Wingdings 3", "code": "89", "unicode": "11192" },
  { "f": "Wingdings 3", "code": "90", "unicode": "129184" },
  { "f": "Wingdings 3", "code": "91", "unicode": "129185" },
  { "f": "Wingdings 3", "code": "92", "unicode": "129186" },
  { "f": "Wingdings 3", "code": "93", "unicode": "129187" },
  { "f": "Wingdings 3", "code": "94", "unicode": "129188" },
  { "f": "Wingdings 3", "code": "95", "unicode": "129189" },
  { "f": "Wingdings 3", "code": "96", "unicode": "129190" },
  { "f": "Wingdings 3", "code": "97", "unicode": "129191" },
  { "f": "Wingdings 3", "code": "98", "unicode": "129192" },
  { "f": "Wingdings 3", "code": "99", "unicode": "129193" },
  { "f": "Wingdings 3", "code": "100", "unicode": "129194" },
  { "f": "Wingdings 3", "code": "101", "unicode": "129195" },
  { "f": "Wingdings 3", "code": "102", "unicode": "129104" },
  { "f": "Wingdings 3", "code": "103", "unicode": "129106" },
  { "f": "Wingdings 3", "code": "104", "unicode": "129105" },
  { "f": "Wingdings 3", "code": "105", "unicode": "129107" },
  { "f": "Wingdings 3", "code": "106", "unicode": "129108" },
  { "f": "Wingdings 3", "code": "107", "unicode": "129109" },
  { "f": "Wingdings 3", "code": "108", "unicode": "129111" },
  { "f": "Wingdings 3", "code": "109", "unicode": "129110" },
  { "f": "Wingdings 3", "code": "110", "unicode": "129112" },
  { "f": "Wingdings 3", "code": "111", "unicode": "129113" },
  { "f": "Wingdings 3", "code": "112", "unicode": "9650" },
  { "f": "Wingdings 3", "code": "113", "unicode": "9660" },
  { "f": "Wingdings 3", "code": "114", "unicode": "9651" },
  { "f": "Wingdings 3", "code": "115", "unicode": "9661" },
  { "f": "Wingdings 3", "code": "116", "unicode": "9664" },
  { "f": "Wingdings 3", "code": "117", "unicode": "9654" },
  { "f": "Wingdings 3", "code": "118", "unicode": "9665" },
  { "f": "Wingdings 3", "code": "119", "unicode": "9655" },
  { "f": "Wingdings 3", "code": "120", "unicode": "9699" },
  { "f": "Wingdings 3", "code": "121", "unicode": "9698" },
  { "f": "Wingdings 3", "code": "122", "unicode": "9700" },
  { "f": "Wingdings 3", "code": "123", "unicode": "9701" },
  { "f": "Wingdings 3", "code": "124", "unicode": "128896" },
  { "f": "Wingdings 3", "code": "125", "unicode": "128898" },
  { "f": "Wingdings 3", "code": "126", "unicode": "128897" },
  { "f": "Wingdings 3", "code": "128", "unicode": "128899" },
  { "f": "Wingdings 3", "code": "129", "unicode": "11205" },
  { "f": "Wingdings 3", "code": "130", "unicode": "11206" },
  { "f": "Wingdings 3", "code": "131", "unicode": "11207" },
  { "f": "Wingdings 3", "code": "132", "unicode": "11208" },
  { "f": "Wingdings 3", "code": "133", "unicode": "11164" },
  { "f": "Wingdings 3", "code": "134", "unicode": "11166" },
  { "f": "Wingdings 3", "code": "135", "unicode": "11165" },
  { "f": "Wingdings 3", "code": "136", "unicode": "11167" },
  { "f": "Wingdings 3", "code": "137", "unicode": "129040" },
  { "f": "Wingdings 3", "code": "138", "unicode": "129042" },
  { "f": "Wingdings 3", "code": "139", "unicode": "129041" },
  { "f": "Wingdings 3", "code": "140", "unicode": "129043" },
  { "f": "Wingdings 3", "code": "141", "unicode": "129044" },
  { "f": "Wingdings 3", "code": "142", "unicode": "129046" },
  { "f": "Wingdings 3", "code": "143", "unicode": "129045" },
  { "f": "Wingdings 3", "code": "144", "unicode": "129047" },
  { "f": "Wingdings 3", "code": "145", "unicode": "129048" },
  { "f": "Wingdings 3", "code": "146", "unicode": "129050" },
  { "f": "Wingdings 3", "code": "147", "unicode": "129049" },
  { "f": "Wingdings 3", "code": "148", "unicode": "129051" },
  { "f": "Wingdings 3", "code": "149", "unicode": "129052" },
  { "f": "Wingdings 3", "code": "150", "unicode": "129054" },
  { "f": "Wingdings 3", "code": "151", "unicode": "129053" },
  { "f": "Wingdings 3", "code": "152", "unicode": "129055" },
  { "f": "Wingdings 3", "code": "153", "unicode": "129024" },
  { "f": "Wingdings 3", "code": "154", "unicode": "129026" },
  { "f": "Wingdings 3", "code": "155", "unicode": "129025" },
  { "f": "Wingdings 3", "code": "156", "unicode": "129027" },
  { "f": "Wingdings 3", "code": "157", "unicode": "129028" },
  { "f": "Wingdings 3", "code": "158", "unicode": "129030" },
  { "f": "Wingdings 3", "code": "159", "unicode": "129029" },
  { "f": "Wingdings 3", "code": "160", "unicode": "129031" },
  { "f": "Wingdings 3", "code": "161", "unicode": "129032" },
  { "f": "Wingdings 3", "code": "162", "unicode": "129034" },
  { "f": "Wingdings 3", "code": "163", "unicode": "129033" },
  { "f": "Wingdings 3", "code": "164", "unicode": "129035" },
  { "f": "Wingdings 3", "code": "165", "unicode": "129056" },
  { "f": "Wingdings 3", "code": "166", "unicode": "129058" },
  { "f": "Wingdings 3", "code": "167", "unicode": "129060" },
  { "f": "Wingdings 3", "code": "168", "unicode": "129062" },
  { "f": "Wingdings 3", "code": "169", "unicode": "129064" },
  { "f": "Wingdings 3", "code": "170", "unicode": "129066" },
  { "f": "Wingdings 3", "code": "171", "unicode": "129068" },
  { "f": "Wingdings 3", "code": "172", "unicode": "129180" },
  { "f": "Wingdings 3", "code": "173", "unicode": "129181" },
  { "f": "Wingdings 3", "code": "174", "unicode": "129182" },
  { "f": "Wingdings 3", "code": "175", "unicode": "129183" },
  { "f": "Wingdings 3", "code": "176", "unicode": "129070" },
  { "f": "Wingdings 3", "code": "177", "unicode": "129072" },
  { "f": "Wingdings 3", "code": "178", "unicode": "129074" },
  { "f": "Wingdings 3", "code": "179", "unicode": "129076" },
  { "f": "Wingdings 3", "code": "180", "unicode": "129078" },
  { "f": "Wingdings 3", "code": "181", "unicode": "129080" },
  { "f": "Wingdings 3", "code": "182", "unicode": "129082" },
  { "f": "Wingdings 3", "code": "183", "unicode": "129081" },
  { "f": "Wingdings 3", "code": "184", "unicode": "129083" },
  { "f": "Wingdings 3", "code": "185", "unicode": "129176" },
  { "f": "Wingdings 3", "code": "186", "unicode": "129178" },
  { "f": "Wingdings 3", "code": "187", "unicode": "129177" },
  { "f": "Wingdings 3", "code": "188", "unicode": "129179" },
  { "f": "Wingdings 3", "code": "189", "unicode": "129084" },
  { "f": "Wingdings 3", "code": "190", "unicode": "129086" },
  { "f": "Wingdings 3", "code": "191", "unicode": "129085" },
  { "f": "Wingdings 3", "code": "192", "unicode": "129087" },
  { "f": "Wingdings 3", "code": "193", "unicode": "129088" },
  { "f": "Wingdings 3", "code": "194", "unicode": "129090" },
  { "f": "Wingdings 3", "code": "195", "unicode": "129089" },
  { "f": "Wingdings 3", "code": "196", "unicode": "129091" },
  { "f": "Wingdings 3", "code": "197", "unicode": "129092" },
  { "f": "Wingdings 3", "code": "198", "unicode": "129094" },
  { "f": "Wingdings 3", "code": "199", "unicode": "129093" },
  { "f": "Wingdings 3", "code": "200", "unicode": "129095" },
  { "f": "Wingdings 3", "code": "201", "unicode": "11176" },
  { "f": "Wingdings 3", "code": "202", "unicode": "11177" },
  { "f": "Wingdings 3", "code": "203", "unicode": "11178" },
  { "f": "Wingdings 3", "code": "204", "unicode": "11179" },
  { "f": "Wingdings 3", "code": "205", "unicode": "11180" },
  { "f": "Wingdings 3", "code": "206", "unicode": "11181" },
  { "f": "Wingdings 3", "code": "207", "unicode": "11182" },
  { "f": "Wingdings 3", "code": "208", "unicode": "11183" },
  { "f": "Wingdings 3", "code": "209", "unicode": "129120" },
  { "f": "Wingdings 3", "code": "210", "unicode": "129122" },
  { "f": "Wingdings 3", "code": "211", "unicode": "129121" },
  { "f": "Wingdings 3", "code": "212", "unicode": "129123" },
  { "f": "Wingdings 3", "code": "213", "unicode": "129124" },
  { "f": "Wingdings 3", "code": "214", "unicode": "129125" },
  { "f": "Wingdings 3", "code": "215", "unicode": "129127" },
  { "f": "Wingdings 3", "code": "216", "unicode": "129126" },
  { "f": "Wingdings 3", "code": "217", "unicode": "129136" },
  { "f": "Wingdings 3", "code": "218", "unicode": "129138" },
  { "f": "Wingdings 3", "code": "219", "unicode": "129137" },
  { "f": "Wingdings 3", "code": "220", "unicode": "129139" },
  { "f": "Wingdings 3", "code": "221", "unicode": "129140" },
  { "f": "Wingdings 3", "code": "222", "unicode": "129141" },
  { "f": "Wingdings 3", "code": "223", "unicode": "129143" },
  { "f": "Wingdings 3", "code": "224", "unicode": "129142" },
  { "f": "Wingdings 3", "code": "225", "unicode": "129152" },
  { "f": "Wingdings 3", "code": "226", "unicode": "129154" },
  { "f": "Wingdings 3", "code": "227", "unicode": "129153" },
  { "f": "Wingdings 3", "code": "228", "unicode": "129155" },
  { "f": "Wingdings 3", "code": "229", "unicode": "129156" },
  { "f": "Wingdings 3", "code": "230", "unicode": "129157" },
  { "f": "Wingdings 3", "code": "231", "unicode": "129159" },
  { "f": "Wingdings 3", "code": "232", "unicode": "129158" },
  { "f": "Wingdings 3", "code": "233", "unicode": "129168" },
  { "f": "Wingdings 3", "code": "234", "unicode": "129170" },
  { "f": "Wingdings 3", "code": "235", "unicode": "129169" },
  { "f": "Wingdings 3", "code": "236", "unicode": "129171" },
  { "f": "Wingdings 3", "code": "237", "unicode": "129172" },
  { "f": "Wingdings 3", "code": "238", "unicode": "129174" },
  { "f": "Wingdings 3", "code": "239", "unicode": "129173" },
  { "f": "Wingdings 3", "code": "240", "unicode": "129175" }
];

// src/helpers/pptx/utils/html.ts
var htmlStringMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#039;",
  "	": "&nbsp;&nbsp;&nbsp;&nbsp;",
  "s": "&nbsp;",
  " ": "&nbsp;"
};
var escapeHtml = (text) => {
  return text.replace(/[&<>"'\t\s]|/g, (match) => htmlStringMap[match] || match);
};
var estimateWidth = (prgr_text) => {
  const template = document.createElement("div");
  template.innerHTML = prgr_text;
  template.style.position = "absolute";
  template.style.whiteSpace = "nowrap";
  template.style.visibility = "hidden";
  document.body.appendChild(template);
  const width = template.offsetWidth;
  document.body.removeChild(template);
  return width;
};
var getHtmlBullet = (typefaceNode, buChar) => {
  switch (buChar) {
    case "\xA7":
      return "&#9632;";
      break;
    case "q":
      return "&#10065;";
      break;
    case "v":
      return "&#10070;";
      break;
    case "\xD8":
      return "&#11162;";
      break;
    case "\xFC":
      return "&#10004;";
      break;
    default:
      if (
        /*typefaceNode == "Wingdings" ||*/
        typefaceNode == "Wingdings 2" || typefaceNode == "Wingdings 3"
      ) {
        let wingCharCode = getDingbatToUnicode(typefaceNode, buChar);
        if (wingCharCode !== null) {
          return "&#" + wingCharCode + ";";
        }
      }
      return "&#" + buChar.charCodeAt(0) + ";";
  }
};
var getDingbatToUnicode = (typefaceNode, buChar) => {
  let dingbatCode = buChar.codePointAt(0) & 4095;
  let char_unicode = null;
  let len = dingbatUnicode.length;
  let i = 0;
  while (len--) {
    let item = dingbatUnicode[i];
    if (item.f == typefaceNode && Number(item.code) == dingbatCode) {
      char_unicode = item.unicode;
      break;
    }
    i++;
  }
  return char_unicode;
};

// src/helpers/pptx/utils/image.ts
var getBase64ImageDimensions = (imgSrc) => {
  let image = new Image();
  let w, h;
  image.onload = function() {
    w = image.width;
    h = image.height;
  };
  image.src = imgSrc;
  do {
    if (image.width !== void 0) {
      return [image.width, image.height];
    }
  } while (image.width === void 0);
};

// src/helpers/pptx/utils/svg.ts
var getMiddleStops = (s) => {
  let sArry = ["0%", "100%"];
  if (s == 0) {
    return sArry;
  } else {
    let i = s;
    while (i--) {
      let middleStop = 100 - 100 / (s + 1) * (i + 1), middleStopString = middleStop + "%";
      sArry.splice(-1, 0, middleStopString);
    }
  }
  return sArry;
};
var SVGangle = (deg, svgHeight, svgWidth) => {
  let w = svgWidth, h = svgHeight, ang = deg, o = 2, n = 2, wc = w / 2, hc = h / 2, tx1 = 2, ty1 = 2, tx2 = 2, ty2 = 2, k = (ang % 360 + 360) % 360, j = (360 - k) * Math.PI / 180, i = Math.tan(j), l = hc - i * wc;
  if (k == 0) {
    tx1 = w, ty1 = hc, tx2 = 0, ty2 = hc;
  } else if (k < 90) {
    n = w, o = 0;
  } else if (k == 90) {
    tx1 = wc, ty1 = 0, tx2 = wc, ty2 = h;
  } else if (k < 180) {
    n = 0, o = 0;
  } else if (k == 180) {
    tx1 = 0, ty1 = hc, tx2 = w, ty2 = hc;
  } else if (k < 270) {
    n = 0, o = h;
  } else if (k == 270) {
    tx1 = wc, ty1 = h, tx2 = wc, ty2 = 0;
  } else {
    n = w, o = h;
  }
  let m = o + n / i, x1 = Math.round(tx2 / w * 100 * 100) / 100, y1 = Math.round(ty2 / h * 100 * 100) / 100, x2 = Math.round(tx1 / w * 100 * 100) / 100, y2 = Math.round(ty1 / h * 100 * 100) / 100;
  tx1 = tx1 == 2 ? i * (m - l) / (Math.pow(i, 2) + 1) : tx1;
  ty1 = ty1 == 2 ? i * tx1 + l : ty1;
  tx2 = tx2 == 2 ? w - tx1 : tx2;
  ty2 = ty2 == 2 ? h - ty1 : ty2;
  return [x1, y1, x2, y2];
};
var getLinerGrandient = (prst, bgColor, fgColor) => {
  switch (prst) {
    case "smGrid":
      return ["linear-gradient(to right,  #" + fgColor + " -1px, transparent 1px ), linear-gradient(to bottom,  #" + fgColor + " -1px, transparent 1px)  #" + bgColor + ";", "4px 4px"];
    case "dotGrid":
      return ["linear-gradient(to right,  #" + fgColor + " -1px, transparent 1px ), linear-gradient(to bottom,  #" + fgColor + " -1px, transparent 1px)  #" + bgColor + ";", "8px 8px"];
    case "lgGrid":
      return ["linear-gradient(to right,  #" + fgColor + " -1px, transparent 1.5px ), linear-gradient(to bottom,  #" + fgColor + " -1px, transparent 1.5px)  #" + bgColor + ";", "8px 8px"];
    case "wdUpDiag":
      return ["repeating-linear-gradient(-45deg, transparent 1px , transparent 4px, #" + fgColor + " 7px)#" + bgColor + ";"];
    // return ["linear-gradient(45deg, transparent 0%, transparent calc(50% - 1px),  #" + fgColor + " 50%, transparent calc(50% + 1px),  transparent 100%) " +
    //     "#" + bgColor + ";", "6px 6px"];
    case "dkUpDiag":
      return ["repeating-linear-gradient(-45deg, transparent 1px , #" + bgColor + " 5px)#" + fgColor + ";"];
    case "ltUpDiag":
      return ["repeating-linear-gradient(-45deg, transparent 1px , transparent 2px, #" + fgColor + " 4px)#" + bgColor + ";"];
    case "wdDnDiag":
      return ["repeating-linear-gradient(45deg, transparent 1px , transparent 4px, #" + fgColor + " 7px)#" + bgColor + ";"];
    case "dkDnDiag":
      return ["repeating-linear-gradient(45deg, transparent 1px , #" + bgColor + " 5px)#" + fgColor + ";"];
    case "ltDnDiag":
      return ["repeating-linear-gradient(45deg, transparent 1px , transparent 2px, #" + fgColor + " 4px)#" + bgColor + ";"];
    case "dkHorz":
      return ["repeating-linear-gradient(0deg, transparent 1px , transparent 2px, #" + bgColor + " 7px)#" + fgColor + ";"];
    case "ltHorz":
      return ["repeating-linear-gradient(0deg, transparent 1px , transparent 5px, #" + fgColor + " 7px)#" + bgColor + ";"];
    case "narHorz":
      return ["repeating-linear-gradient(0deg, transparent 1px , transparent 2px, #" + fgColor + " 4px)#" + bgColor + ";"];
    case "dkVert":
      return ["repeating-linear-gradient(90deg, transparent 1px , transparent 2px, #" + bgColor + " 7px)#" + fgColor + ";"];
    case "ltVert":
      return ["repeating-linear-gradient(90deg, transparent 1px , transparent 5px, #" + fgColor + " 7px)#" + bgColor + ";"];
      break;
    case "narVert":
      return ["repeating-linear-gradient(90deg, transparent 1px , transparent 2px, #" + fgColor + " 4px)#" + bgColor + ";"];
    case "lgCheck":
    case "smCheck": {
      let size = "";
      let pos = "";
      if (prst == "lgCheck") {
        size = "8px 8px";
        pos = "0 0, 4px 4px, 4px 4px, 8px 8px";
      } else {
        size = "4px 4px";
        pos = "0 0, 2px 2px, 2px 2px, 4px 4px";
      }
      return ["linear-gradient(45deg,  #" + fgColor + " 25%, transparent 0, transparent 75%,  #" + fgColor + " 0), linear-gradient(45deg,  #" + fgColor + " 25%, transparent 0, transparent 75%,  #" + fgColor + " 0) #" + bgColor + ";", size, pos];
    }
    // case "smCheck":
    //     return ["linear-gradient(45deg, transparent 0%, transparent calc(50% - 0.5px),  #" + fgColor + " 50%, transparent calc(50% + 0.5px),  transparent 100%), " +
    //         "linear-gradient(-45deg, transparent 0%, transparent calc(50% - 0.5px) , #" + fgColor + " 50%, transparent calc(50% + 0.5px),  transparent 100%)  " +
    //         "#" + bgColor + ";", "4px 4px"];
    //     break 
    case "dashUpDiag":
      return ["repeating-linear-gradient(152deg, #" + fgColor + ", #" + fgColor + " 5% , transparent 0, transparent 70%)#" + bgColor + ";", "4px 4px"];
    case "dashDnDiag":
      return ["repeating-linear-gradient(45deg, #" + fgColor + ", #" + fgColor + " 5% , transparent 0, transparent 70%)#" + bgColor + ";", "4px 4px"];
    case "diagBrick":
      return ["linear-gradient(45deg, transparent 15%,  #" + fgColor + " 30%, transparent 30%), linear-gradient(-45deg, transparent 15%,  #" + fgColor + " 30%, transparent 30%), linear-gradient(-45deg, transparent 65%,  #" + fgColor + " 80%, transparent 0) #" + bgColor + ";", "4px 4px"];
    case "horzBrick":
      return ["linear-gradient(335deg, #" + bgColor + " 1.6px, transparent 1.6px), linear-gradient(155deg, #" + bgColor + " 1.6px, transparent 1.6px), linear-gradient(335deg, #" + bgColor + " 1.6px, transparent 1.6px), linear-gradient(155deg, #" + bgColor + " 1.6px, transparent 1.6px) #" + fgColor + ";", "4px 4px", "0 0.15px, 0.3px 2.5px, 2px 2.15px, 2.35px 0.4px"];
    case "dashVert":
      return ["linear-gradient(0deg,  #" + bgColor + " 30%, transparent 30%),linear-gradient(90deg,transparent, transparent 40%, #" + fgColor + " 40%, #" + fgColor + " 60% , transparent 60%)#" + bgColor + ";", "4px 4px"];
    case "dashHorz":
      return ["linear-gradient(90deg,  #" + bgColor + " 30%, transparent 30%),linear-gradient(0deg,transparent, transparent 40%, #" + fgColor + " 40%, #" + fgColor + " 60% , transparent 60%)#" + bgColor + ";", "4px 4px"];
    case "solidDmnd":
      return ["linear-gradient(135deg,  #" + fgColor + " 25%, transparent 25%), linear-gradient(225deg,  #" + fgColor + " 25%, transparent 25%), linear-gradient(315deg,  #" + fgColor + " 25%, transparent 25%), linear-gradient(45deg,  #" + fgColor + " 25%, transparent 25%) #" + bgColor + ";", "8px 8px"];
    case "openDmnd":
      return ["linear-gradient(45deg, transparent 0%, transparent calc(50% - 0.5px),  #" + fgColor + " 50%, transparent calc(50% + 0.5px),  transparent 100%), linear-gradient(-45deg, transparent 0%, transparent calc(50% - 0.5px) , #" + fgColor + " 50%, transparent calc(50% + 0.5px),  transparent 100%) #" + bgColor + ";", "8px 8px"];
    case "dotDmnd":
      return ["radial-gradient(#" + fgColor + " 15%, transparent 0), radial-gradient(#" + fgColor + " 15%, transparent 0) #" + bgColor + ";", "4px 4px", "0 0, 2px 2px"];
    case "zigZag":
    case "wave": {
      let size = "";
      if (prst == "zigZag") size = "0";
      else size = "1px";
      return ["linear-gradient(135deg,  #" + fgColor + " 25%, transparent 25%) 50px " + size + ", linear-gradient(225deg,  #" + fgColor + " 25%, transparent 25%) 50px " + size + ", linear-gradient(315deg,  #" + fgColor + " 25%, transparent 25%), linear-gradient(45deg,  #" + fgColor + " 25%, transparent 25%) #" + bgColor + ";", "4px 4px"];
    }
    case "lgConfetti":
    case "smConfetti": {
      let size = "";
      if (prst == "lgConfetti") size = "4px 4px";
      else size = "2px 2px";
      return ["linear-gradient(135deg,  #" + fgColor + " 25%, transparent 25%) 50px 1px, linear-gradient(225deg,  #" + fgColor + " 25%, transparent 25%), linear-gradient(315deg,  #" + fgColor + " 25%, transparent 25%) 50px 1px , linear-gradient(45deg,  #" + fgColor + " 25%, transparent 25%) #" + bgColor + ";", size];
    }
    // case "weave":
    //     return ["linear-gradient(45deg,  #" + bgColor + " 5%, transparent 25%) 50px 0, " +
    //         "linear-gradient(135deg,  #" + bgColor + " 25%, transparent 25%) 50px 0, " +
    //         "linear-gradient(45deg,  #" + bgColor + " 25%, transparent 25%) " +
    //         "#" + fgColor + ";", "4px 4px"];
    //     //background: linear-gradient(45deg, #dca 12%, transparent 0, transparent 88%, #dca 0),
    //     //linear-gradient(135deg, transparent 37 %, #a85 0, #a85 63 %, transparent 0),
    //     //linear-gradient(45deg, transparent 37 %, #dca 0, #dca 63 %, transparent 0) #753;
    //     // background-size: 25px 25px;
    //     break;
    case "plaid":
      return ["linear-gradient(0deg, transparent, transparent 25%, #" + fgColor + "33 25%, #" + fgColor + "33 50%),linear-gradient(90deg, transparent, transparent 25%, #" + fgColor + "66 25%, #" + fgColor + "66 50%) #" + bgColor + ";", "4px 4px"];
    /**
        background-color: #6677dd;
        background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 35px, rgba(255, 255, 255, 0.2) 35px, rgba(255, 255, 255, 0.2) 70px), 
        repeating-linear-gradient(90deg, transparent, transparent 35px, rgba(255,255,255,0.4) 35px, rgba(255,255,255,0.4) 70px);
     */
    case "sphere":
      return ["radial-gradient(#" + fgColor + " 50%, transparent 50%),#" + bgColor + ";", "4px 4px"];
    case "weave":
    case "shingle":
      return ["linear-gradient(45deg, #" + bgColor + " 1.31px , #" + fgColor + " 1.4px, #" + fgColor + " 1.5px, transparent 1.5px, transparent 4.2px, #" + fgColor + " 4.2px, #" + fgColor + " 4.3px, transparent 4.31px), linear-gradient(-45deg,  #" + bgColor + " 1.31px , #" + fgColor + " 1.4px, #" + fgColor + " 1.5px, transparent 1.5px, transparent 4.2px, #" + fgColor + " 4.2px, #" + fgColor + " 4.3px, transparent 4.31px) 0 4px, #" + bgColor + ";", "4px 8px"];
    //background:
    //linear-gradient(45deg, #708090 1.31px, #d9ecff 1.4px, #d9ecff 1.5px, transparent 1.5px, transparent 4.2px, #d9ecff 4.2px, #d9ecff 4.3px, transparent 4.31px),
    //linear-gradient(-45deg, #708090 1.31px, #d9ecff 1.4px, #d9ecff 1.5px, transparent 1.5px, transparent 4.2px, #d9ecff 4.2px, #d9ecff 4.3px, transparent 4.31px)0 4px;
    //background-color:#708090;
    //background-size: 4px 8px;
    case "pct5":
    case "pct10":
    case "pct20":
    case "pct25":
    case "pct30":
    case "pct40":
    case "pct50":
    case "pct60":
    case "pct70":
    case "pct75":
    case "pct80":
    case "pct90":
    //case "dotDmnd":
    case "trellis":
    case "divot":
      let px_pr_ary;
      switch (prst) {
        case "pct5":
          px_pr_ary = ["0.3px", "10%", "2px 2px"];
          break;
        case "divot":
          px_pr_ary = ["0.3px", "40%", "4px 4px"];
          break;
        case "pct10":
          px_pr_ary = ["0.3px", "20%", "2px 2px"];
          break;
        case "pct20":
          px_pr_ary = ["0.2px", "40%", "2px 2px"];
          break;
        case "pct25":
          px_pr_ary = ["0.2px", "50%", "2px 2px"];
          break;
        case "pct30":
          px_pr_ary = ["0.5px", "50%", "2px 2px"];
          break;
        case "pct40":
          px_pr_ary = ["0.5px", "70%", "2px 2px"];
          break;
        case "pct50":
          px_pr_ary = ["0.09px", "90%", "2px 2px"];
          break;
        case "pct60":
          px_pr_ary = ["0.3px", "90%", "2px 2px"];
          break;
        case "pct70":
        case "trellis":
          px_pr_ary = ["0.5px", "95%", "2px 2px"];
          break;
        case "pct75":
          px_pr_ary = ["0.65px", "100%", "2px 2px"];
          break;
        case "pct80":
          px_pr_ary = ["0.85px", "100%", "2px 2px"];
          break;
        case "pct90":
          px_pr_ary = ["1px", "100%", "2px 2px"];
          break;
      }
      return ["radial-gradient(#" + fgColor + " " + px_pr_ary[0] + ", transparent " + px_pr_ary[1] + "),#" + bgColor + ";", px_pr_ary[2]];
    default:
      return [0, 0];
  }
};
var shapeGear = (w, h, points) => {
  let innerRadius = h;
  let outerRadius = 1.5 * innerRadius;
  let cx = outerRadius, cy = outerRadius, notches = points, radiusO = outerRadius, radiusI = innerRadius, taperO = 50, taperI = 35, pi2 = 2 * Math.PI, angle = pi2 / (notches * 2), taperAI = angle * taperI * 5e-3, taperAO = angle * taperO * 5e-3, a = angle, toggle = false;
  let d = " M" + (cx + radiusO * Math.cos(taperAO)) + " " + (cy + radiusO * Math.sin(taperAO));
  for (; a <= pi2 + angle; a += angle) {
    if (toggle) {
      d += " L" + (cx + radiusI * Math.cos(a - taperAI)) + "," + (cy + radiusI * Math.sin(a - taperAI));
      d += " L" + (cx + radiusO * Math.cos(a + taperAO)) + "," + (cy + radiusO * Math.sin(a + taperAO));
    } else {
      d += " L" + (cx + radiusO * Math.cos(a - taperAO)) + "," + (cy + radiusO * Math.sin(a - taperAO));
      d += " L" + (cx + radiusI * Math.cos(a + taperAI)) + "," + (cy + radiusI * Math.sin(a + taperAI));
    }
    toggle = !toggle;
  }
  d += " ";
  return d;
};
var shapeArc = (cX, cY, rX, rY, stAng, endAng, isClose) => {
  let dData;
  let angle = stAng;
  if (endAng >= stAng) {
    while (angle <= endAng) {
      let radians = angle * (Math.PI / 180);
      let x = cX + Math.cos(radians) * rX;
      let y = cY + Math.sin(radians) * rY;
      if (angle == stAng) {
        dData = " M" + x + " " + y;
      }
      dData += " L" + x + " " + y;
      angle++;
    }
  } else {
    while (angle > endAng) {
      let radians = angle * (Math.PI / 180);
      let x = cX + Math.cos(radians) * rX;
      let y = cY + Math.sin(radians) * rY;
      if (angle == stAng) {
        dData = " M " + x + " " + y;
      }
      dData += " L " + x + " " + y;
      angle--;
    }
  }
  dData += isClose ? " z" : "";
  return dData;
};
var shapeSnipRoundRect = (w, h, adj1, adj2, shapeType, adjType) => {
  let adjA = 0, adjB = 0, adjC = 0, adjD = adj1;
  if (adjType == "cornr1") {
    adjA = 0;
    adjB = 0;
    adjC = 0;
    adjD = adj1;
  } else if (adjType == "cornr2") {
    adjA = adj1;
    adjB = adj2;
    adjC = adj2;
    adjD = adj1;
  } else if (adjType == "cornrAll") {
    adjA = adj1;
    adjB = adj1;
    adjC = adj1;
    adjD = adj1;
  } else if (adjType == "diag") {
    adjA = adj1;
    adjB = adj2;
    adjC = adj1;
    adjD = adj2;
  }
  let d;
  if (shapeType == "round") {
    d = "M0," + (h / 2 + (1 - adjB) * (h / 2)) + " Q0," + h + " " + adjB * (w / 2) + "," + h + " L" + (w / 2 + (1 - adjC) * (w / 2)) + "," + h + " Q" + w + "," + h + " " + w + "," + (h / 2 + h / 2 * (1 - adjC)) + "L" + w + "," + h / 2 * adjD + " Q" + w + ",0 " + (w / 2 + w / 2 * (1 - adjD)) + ",0 L" + w / 2 * adjA + ",0 Q0,0 0," + h / 2 * adjA + " z";
  } else if (shapeType == "snip") {
    d = "M0," + adjA * (h / 2) + " L0," + (h / 2 + h / 2 * (1 - adjB)) + "L" + adjB * (w / 2) + "," + h + " L" + (w / 2 + w / 2 * (1 - adjC)) + "," + h + "L" + w + "," + (h / 2 + h / 2 * (1 - adjC)) + " L" + w + "," + adjD * (h / 2) + "L" + (w / 2 + w / 2 * (1 - adjD)) + ",0 L" + w / 2 * adjA + ",0 z";
  }
  return d;
};
var shapePie = (H, w, adj1, adj2, isClose) => {
  let pieVal = parseInt(adj2);
  let piAngle = parseInt(adj1);
  let size = parseInt(H), radius = size / 2, value = pieVal - piAngle;
  if (value < 0) {
    value = 360 + value;
  }
  value = Math.min(Math.max(value, 0), 360);
  let x = Math.cos(2 * Math.PI / (360 / value));
  let y = Math.sin(2 * Math.PI / (360 / value));
  let longArc, d, rot;
  if (isClose) {
    longArc = value <= 180 ? 0 : 1;
    d = "M" + radius + "," + radius + " L" + radius + ",0 A" + radius + "," + radius + " 0 " + longArc + ",1 " + (radius + y * radius) + "," + (radius - x * radius) + " z";
    rot = "rotate(" + (piAngle - 270) + ", " + radius + ", " + radius + ")";
  } else {
    longArc = value <= 180 ? 0 : 1;
    let radius1 = radius;
    let radius2 = w / 2;
    d = "M" + radius1 + ",0 A" + radius2 + "," + radius1 + " 0 " + longArc + ",1 " + (radius2 + y * radius2) + "," + (radius1 - x * radius1);
    rot = "rotate(" + (piAngle + 90) + ", " + radius + ", " + radius + ")";
  }
  return [d, rot];
};
var getSvgGradient = (w, h, angl, color_arry, shpId) => {
  let stopsArray = getMiddleStops(color_arry - 2);
  let svgAngle = "", svgHeight = h, svgWidth = w, svg = "", xy_ary = SVGangle(angl, svgHeight, svgWidth), x1 = xy_ary[0], y1 = xy_ary[1], x2 = xy_ary[2], y2 = xy_ary[3];
  let sal = stopsArray.length, sr = sal < 20 ? 100 : 1e3;
  svgAngle = ' gradientUnits="userSpaceOnUse" x1="' + x1 + '%" y1="' + y1 + '%" x2="' + x2 + '%" y2="' + y2 + '%"';
  svgAngle = '<linearGradient id="linGrd_' + shpId + '"' + svgAngle + ">\n";
  svg += svgAngle;
  for (var i = 0; i < sal; i++) {
    let tinClr = tinycolor("#" + color_arry[i]);
    let alpha = tinClr.getAlpha();
    svg += '<stop offset="' + Math.round(parseFloat(stopsArray[i]) / 100 * sr) / sr + '" style="stop-color:' + tinClr.toHexString() + "; stop-opacity:" + alpha + ';"';
    svg += "/>\n";
  }
  svg += "</linearGradient>\n";
  return svg;
};

// src/helpers/pptx/utils/object.ts

var getTextByPathList = (node, path) => {
  if (path.constructor !== Array) {
    throw Error("Error of path type! path is not array.");
  }
  if (node === void 0) {
    return void 0;
  }
  let l = path.length;
  for (var i = 0; i < l; i++) {
    node = node[path[i]];
    if (node === void 0) {
      return void 0;
    }
  }
  return node;
};
var setTextByPathList = (node, path, value) => {
  if (path.constructor !== Array) {
    throw Error("Error of path type! path is not array.");
  }
  if (node === void 0) {
    return void 0;
  }
  _2.default.set(node, path, value);
};
var eachElement = (node, doFunction) => {
  if (node === void 0) {
    return;
  }
  let result = "";
  if (node.constructor === Array) {
    let l = node.length;
    for (var i = 0; i < l; i++) {
      result += doFunction(node[i], i);
    }
  } else {
    result += doFunction(node, 0);
  }
  return result;
};

// src/helpers/pptx/utils/shape/genTypedShape.ts
var genTypedShape = (shapType, w, h, border, fill, slideFactor, shapAdjstArr, oShadowSvgUrlStr, markerStart, markerEnd) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  let result = "";
  switch (shapType) {
    case "rect":
    case "flowChartProcess":
    case "flowChartPredefinedProcess":
    case "flowChartInternalStorage":
    case "actionButtonBlank":
      result += "<rect x='0' y='0' width='" + w + "' height='" + h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' " + oShadowSvgUrlStr + "  />";
      if (shapType == "flowChartPredefinedProcess") {
        result += "<rect x='" + w * (1 / 8) + "' y='0' width='" + w * (6 / 8) + "' height='" + h + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      } else if (shapType == "flowChartInternalStorage") {
        result += " <polyline points='" + w * (1 / 8) + " 0," + w * (1 / 8) + " " + h + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
        result += " <polyline points='0 " + h * (1 / 8) + "," + w + " " + h * (1 / 8) + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      }
      break;
    case "flowChartCollate": {
      let d = "M 0,0 L" + w + ",0 L0," + h + " L" + w + "," + h + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartDocument": {
      let y1, y2, y3, x1;
      x1 = w * 10800 / 21600;
      y1 = h * 17322 / 21600;
      y2 = h * 20172 / 21600;
      y3 = h * 23922 / 21600;
      let d = "M0,0 L" + w + ",0 L" + w + "," + y1 + " C" + x1 + "," + y1 + " " + x1 + "," + y3 + " 0," + y2 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartMultidocument": {
      let y1, y2, y3, y4, y5, y6, y7, y8, y9, x1, x2, x3, x4, x5, x6, x7;
      y1 = h * 18022 / 21600;
      y2 = h * 3675 / 21600;
      y3 = h * 23542 / 21600;
      y4 = h * 1815 / 21600;
      y5 = h * 16252 / 21600;
      y6 = h * 16352 / 21600;
      y7 = h * 14392 / 21600;
      y8 = h * 20782 / 21600;
      y9 = h * 14467 / 21600;
      x1 = w * 1532 / 21600;
      x2 = w * 2e4 / 21600;
      x3 = w * 9298 / 21600;
      x4 = w * 19298 / 21600;
      x5 = w * 18595 / 21600;
      x6 = w * 2972 / 21600;
      x7 = w * 20800 / 21600;
      let d = "M0," + y2 + " L" + x5 + "," + y2 + " L" + x5 + "," + y1 + " C" + x3 + "," + y1 + " " + x3 + "," + y3 + " 0," + y8 + " zM" + x1 + "," + y2 + " L" + x1 + "," + y4 + " L" + x2 + "," + y4 + " L" + x2 + "," + y5 + " C" + x4 + "," + y5 + " " + x5 + "," + y6 + " " + x5 + "," + y6 + "M" + x6 + "," + y4 + " L" + x6 + ",0 L" + w + ",0 L" + w + "," + y7 + " C" + x7 + "," + y7 + " " + x2 + "," + y9 + " " + x2 + "," + y9;
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonBackPrevious": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + g11 + "," + vc + " L" + g12 + "," + g9 + " L" + g12 + "," + g10 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonBeginning": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 / 8;
      g15 = g13 / 4;
      g16 = g11 + g14;
      g17 = g11 + g15;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + g17 + "," + vc + " L" + g12 + "," + g9 + " L" + g12 + "," + g10 + " zM" + g16 + "," + g9 + " L" + g11 + "," + g9 + " L" + g11 + "," + g10 + " L" + g16 + "," + g10 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonDocument": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, dx1, g11, g12, g13, g14, g15;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      dx1 = ss * 9 / 32;
      g11 = hc - dx1;
      g12 = hc + dx1;
      g13 = ss * 3 / 16;
      g14 = g12 - g13;
      g15 = g9 + g13;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + g11 + "," + g9 + " L" + g14 + "," + g9 + " L" + g12 + "," + g15 + " L" + g12 + "," + g10 + " L" + g11 + "," + g10 + " zM" + g14 + "," + g9 + " L" + g14 + "," + g15 + " L" + g12 + "," + g15 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonEnd": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 * 3 / 4;
      g15 = g13 * 7 / 8;
      g16 = g11 + g14;
      g17 = g11 + g15;
      let d = "M0," + h + " L" + w + "," + h + " L" + w + ",0 L0,0 z M" + g17 + "," + g9 + " L" + g12 + "," + g9 + " L" + g12 + "," + g10 + " L" + g17 + "," + g10 + " z M" + g16 + "," + vc + " L" + g11 + "," + g9 + " L" + g11 + "," + g10 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonForwardNext": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      let d = "M0," + h + " L" + w + "," + h + " L" + w + ",0 L0,0 z M" + g12 + "," + vc + " L" + g11 + "," + g9 + " L" + g11 + "," + g10 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonHelp": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g11, g13, g14, g15, g16, g19, g20, g21, g23, g24, g27, g29, g30, g31, g33, g36, g37, g41, g42;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g11 = hc - dx2;
      g13 = ss * 3 / 4;
      g14 = g13 / 7;
      g15 = g13 * 3 / 14;
      g16 = g13 * 2 / 7;
      g19 = g13 * 3 / 7;
      g20 = g13 * 4 / 7;
      g21 = g13 * 17 / 28;
      g23 = g13 * 21 / 28;
      g24 = g13 * 11 / 14;
      g27 = g9 + g16;
      g29 = g9 + g21;
      g30 = g9 + g23;
      g31 = g9 + g24;
      g33 = g11 + g15;
      g36 = g11 + g19;
      g37 = g11 + g20;
      g41 = g13 / 14;
      g42 = g13 * 3 / 28;
      let cX1 = g33 + g16;
      let cX2 = g36 + g14;
      let cY3 = g31 + g42;
      let cX4 = (g37 + g36 + g16) / 2;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + g33 + "," + g27 + shapeArc(cX1, g27, g16, g16, 180, 360, false).replace("M", "L") + shapeArc(cX4, g27, g14, g15, 0, 90, false).replace("M", "L") + shapeArc(cX4, g29, g41, g42, 270, 180, false).replace("M", "L") + " L" + g37 + "," + g30 + " L" + g36 + "," + g30 + " L" + g36 + "," + g29 + shapeArc(cX2, g29, g14, g15, 180, 270, false).replace("M", "L") + shapeArc(g37, g27, g41, g42, 90, 0, false).replace("M", "L") + shapeArc(cX1, g27, g14, g14, 0, -180, false).replace("M", "L") + " zM" + hc + "," + g31 + shapeArc(hc, cY3, g42, g42, 270, 630, false).replace("M", "L") + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonHome": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, g22, g23, g24, g25, g26, g27, g28, g29, g30, g31, g32, g33;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 / 16;
      g15 = g13 / 8;
      g16 = g13 * 3 / 16;
      g17 = g13 * 5 / 16;
      g18 = g13 * 7 / 16;
      g19 = g13 * 9 / 16;
      g20 = g13 * 11 / 16;
      g21 = g13 * 3 / 4;
      g22 = g13 * 13 / 16;
      g23 = g13 * 7 / 8;
      g24 = g9 + g14;
      g25 = g9 + g16;
      g26 = g9 + g17;
      g27 = g9 + g21;
      g28 = g11 + g15;
      g29 = g11 + g18;
      g30 = g11 + g19;
      g31 = g11 + g20;
      g32 = g11 + g22;
      g33 = g11 + g23;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + hc + "," + g9 + " L" + g11 + "," + vc + " L" + g28 + "," + vc + " L" + g28 + "," + g10 + " L" + g33 + "," + g10 + " L" + g33 + "," + vc + " L" + g12 + "," + vc + " L" + g32 + "," + g26 + " L" + g32 + "," + g24 + " L" + g31 + "," + g24 + " L" + g31 + "," + g25 + " z M" + g29 + "," + g27 + " L" + g30 + "," + g27 + " L" + g30 + "," + g10 + " L" + g29 + "," + g10 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonInformation": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g11, g13, g14, g17, g18, g19, g20, g22, g23, g24, g25, g28, g29, g30, g31, g32, g34, g35, g37, g38;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g11 = hc - dx2;
      g13 = ss * 3 / 4;
      g14 = g13 / 32;
      g17 = g13 * 5 / 16;
      g18 = g13 * 3 / 8;
      g19 = g13 * 13 / 32;
      g20 = g13 * 19 / 32;
      g22 = g13 * 11 / 16;
      g23 = g13 * 13 / 16;
      g24 = g13 * 7 / 8;
      g25 = g9 + g14;
      g28 = g9 + g17;
      g29 = g9 + g18;
      g30 = g9 + g23;
      g31 = g9 + g24;
      g32 = g11 + g17;
      g34 = g11 + g19;
      g35 = g11 + g20;
      g37 = g11 + g22;
      g38 = g13 * 3 / 32;
      let cY1 = g9 + dx2;
      let cY2 = g25 + g38;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + hc + "," + g9 + shapeArc(hc, cY1, dx2, dx2, 270, 630, false).replace("M", "L") + " zM" + hc + "," + g25 + shapeArc(hc, cY2, g38, g38, 270, 630, false).replace("M", "L") + "M" + g32 + "," + g28 + " L" + g35 + "," + g28 + " L" + g35 + "," + g30 + " L" + g37 + "," + g30 + " L" + g37 + "," + g31 + " L" + g32 + "," + g31 + " L" + g32 + "," + g30 + " L" + g34 + "," + g30 + " L" + g34 + "," + g29 + " L" + g32 + "," + g29 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonMovie": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, g22, g23, g24, g25, g26, g27, g28, g29, g30, g31, g32, g33, g34, g35, g36, g37, g38, g39, g40, g41, g42, g43, g44, g45, g46, g47, g48;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 * 1455 / 21600;
      g15 = g13 * 1905 / 21600;
      g16 = g13 * 2325 / 21600;
      g17 = g13 * 16155 / 21600;
      g18 = g13 * 17010 / 21600;
      g19 = g13 * 19335 / 21600;
      g20 = g13 * 19725 / 21600;
      g21 = g13 * 20595 / 21600;
      g22 = g13 * 5280 / 21600;
      g23 = g13 * 5730 / 21600;
      g24 = g13 * 6630 / 21600;
      g25 = g13 * 7492 / 21600;
      g26 = g13 * 9067 / 21600;
      g27 = g13 * 9555 / 21600;
      g28 = g13 * 13342 / 21600;
      g29 = g13 * 14580 / 21600;
      g30 = g13 * 15592 / 21600;
      g31 = g11 + g14;
      g32 = g11 + g15;
      g33 = g11 + g16;
      g34 = g11 + g17;
      g35 = g11 + g18;
      g36 = g11 + g19;
      g37 = g11 + g20;
      g38 = g11 + g21;
      g39 = g9 + g22;
      g40 = g9 + g23;
      g41 = g9 + g24;
      g42 = g9 + g25;
      g43 = g9 + g26;
      g44 = g9 + g27;
      g45 = g9 + g28;
      g46 = g9 + g29;
      g47 = g9 + g30;
      g48 = g9 + g31;
      let d = "M0," + h + " L" + w + "," + h + " L" + w + ",0 L0,0 zM" + g11 + "," + g39 + " L" + g11 + "," + g44 + " L" + g31 + "," + g44 + " L" + g32 + "," + g43 + " L" + g33 + "," + g43 + " L" + g33 + "," + g47 + " L" + g35 + "," + g47 + " L" + g35 + "," + g45 + " L" + g36 + "," + g45 + " L" + g38 + "," + g46 + " L" + g12 + "," + g46 + " L" + g12 + "," + g41 + " L" + g38 + "," + g41 + " L" + g37 + "," + g42 + " L" + g35 + "," + g42 + " L" + g35 + "," + g41 + " L" + g34 + "," + g40 + " L" + g32 + "," + g40 + " L" + g31 + "," + g39 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonReturn": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, g22, g23, g24, g25, g26, g27;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 * 7 / 8;
      g15 = g13 * 3 / 4;
      g16 = g13 * 5 / 8;
      g17 = g13 * 3 / 8;
      g18 = g13 / 4;
      g19 = g9 + g15;
      g20 = g9 + g16;
      g21 = g9 + g18;
      g22 = g11 + g14;
      g23 = g11 + g15;
      g24 = g11 + g16;
      g25 = g11 + g17;
      g26 = g11 + g18;
      g27 = g13 / 8;
      let cX1 = g24 - g27;
      let cY2 = g19 - g27;
      let cX3 = g11 + g17;
      let cY4 = g10 - g17;
      let d = "M0," + h + " L" + w + "," + h + " L" + w + ",0 L0,0 z M" + g12 + "," + g21 + " L" + g23 + "," + g9 + " L" + hc + "," + g21 + " L" + g24 + "," + g21 + " L" + g24 + "," + g20 + shapeArc(cX1, g20, g27, g27, 0, 90, false).replace("M", "L") + " L" + g25 + "," + g19 + shapeArc(g25, cY2, g27, g27, 90, 180, false).replace("M", "L") + " L" + g26 + "," + g21 + " L" + g11 + "," + g21 + " L" + g11 + "," + g20 + shapeArc(cX3, g20, g17, g17, 180, 90, false).replace("M", "L") + " L" + hc + "," + g10 + shapeArc(hc, cY4, g17, g17, 90, 0, false).replace("M", "L") + " L" + g22 + "," + g21 + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "actionButtonSound": {
      let hc = w / 2, vc = h / 2, ss = Math.min(w, h);
      let dx2, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, g22, g23, g24, g25, g26;
      dx2 = ss * 3 / 8;
      g9 = vc - dx2;
      g10 = vc + dx2;
      g11 = hc - dx2;
      g12 = hc + dx2;
      g13 = ss * 3 / 4;
      g14 = g13 / 8;
      g15 = g13 * 5 / 16;
      g16 = g13 * 5 / 8;
      g17 = g13 * 11 / 16;
      g18 = g13 * 3 / 4;
      g19 = g13 * 7 / 8;
      g20 = g9 + g14;
      g21 = g9 + g15;
      g22 = g9 + g17;
      g23 = g9 + g19;
      g24 = g11 + g15;
      g25 = g11 + g16;
      g26 = g11 + g18;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + g11 + "," + g21 + " L" + g24 + "," + g21 + " L" + g25 + "," + g9 + " L" + g25 + "," + g10 + " L" + g24 + "," + g22 + " L" + g11 + "," + g22 + " z M" + g26 + "," + g21 + " L" + g12 + "," + g20 + " M" + g26 + "," + vc + " L" + g12 + "," + vc + " M" + g26 + "," + g22 + " L" + g12 + "," + g23;
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "irregularSeal1":
    case "irregularSeal2": {
      let d;
      if (shapType == "irregularSeal1") {
        d = "M" + w * 10800 / 21600 + "," + h * 5800 / 21600 + " L" + w * 14522 / 21600 + ",0 L" + w * 14155 / 21600 + "," + h * 5325 / 21600 + " L" + w * 18380 / 21600 + "," + h * 4457 / 21600 + " L" + w * 16702 / 21600 + "," + h * 7315 / 21600 + " L" + w * 21097 / 21600 + "," + h * 8137 / 21600 + " L" + w * 17607 / 21600 + "," + h * 10475 / 21600 + " L" + w + "," + h * 13290 / 21600 + " L" + w * 16837 / 21600 + "," + h * 12942 / 21600 + " L" + w * 18145 / 21600 + "," + h * 18095 / 21600 + " L" + w * 14020 / 21600 + "," + h * 14457 / 21600 + " L" + w * 13247 / 21600 + "," + h * 19737 / 21600 + " L" + w * 10532 / 21600 + "," + h * 14935 / 21600 + " L" + w * 8485 / 21600 + "," + h + " L" + w * 7715 / 21600 + "," + h * 15627 / 21600 + " L" + w * 4762 / 21600 + "," + h * 17617 / 21600 + " L" + w * 5667 / 21600 + "," + h * 13937 / 21600 + " L" + w * 135 / 21600 + "," + h * 14587 / 21600 + " L" + w * 3722 / 21600 + "," + h * 11775 / 21600 + " L0," + h * 8615 / 21600 + " L" + w * 4627 / 21600 + "," + h * 7617 / 21600 + " L" + w * 370 / 21600 + "," + h * 2295 / 21600 + " L" + w * 7312 / 21600 + "," + h * 6320 / 21600 + " L" + w * 8352 / 21600 + "," + h * 2295 / 21600 + " z";
      } else if (shapType == "irregularSeal2") {
        d = "M" + w * 11462 / 21600 + "," + h * 4342 / 21600 + " L" + w * 14790 / 21600 + ",0 L" + w * 14525 / 21600 + "," + h * 5777 / 21600 + " L" + w * 18007 / 21600 + "," + h * 3172 / 21600 + " L" + w * 16380 / 21600 + "," + h * 6532 / 21600 + " L" + w + "," + h * 6645 / 21600 + " L" + w * 16985 / 21600 + "," + h * 9402 / 21600 + " L" + w * 18270 / 21600 + "," + h * 11290 / 21600 + " L" + w * 16380 / 21600 + "," + h * 12310 / 21600 + " L" + w * 18877 / 21600 + "," + h * 15632 / 21600 + " L" + w * 14640 / 21600 + "," + h * 14350 / 21600 + " L" + w * 14942 / 21600 + "," + h * 17370 / 21600 + " L" + w * 12180 / 21600 + "," + h * 15935 / 21600 + " L" + w * 11612 / 21600 + "," + h * 18842 / 21600 + " L" + w * 9872 / 21600 + "," + h * 17370 / 21600 + " L" + w * 8700 / 21600 + "," + h * 19712 / 21600 + " L" + w * 7527 / 21600 + "," + h * 18125 / 21600 + " L" + w * 4917 / 21600 + "," + h + " L" + w * 4805 / 21600 + "," + h * 18240 / 21600 + " L" + w * 1285 / 21600 + "," + h * 17825 / 21600 + " L" + w * 3330 / 21600 + "," + h * 15370 / 21600 + " L0," + h * 12877 / 21600 + " L" + w * 3935 / 21600 + "," + h * 11592 / 21600 + " L" + w * 1172 / 21600 + "," + h * 8270 / 21600 + " L" + w * 5372 / 21600 + "," + h * 7817 / 21600 + " L" + w * 4502 / 21600 + "," + h * 3625 / 21600 + " L" + w * 8550 / 21600 + "," + h * 6382 / 21600 + " L" + w * 9722 / 21600 + "," + h * 1887 / 21600 + " z";
      }
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartTerminator": {
      let x1, x2, y1, cd2 = 180, cd4 = 90, c3d4 = 270;
      x1 = w * 3475 / 21600;
      x2 = w * 18125 / 21600;
      y1 = h * 10800 / 21600;
      let d = "M" + x1 + ",0 L" + x2 + ",0" + shapeArc(x2, h / 2, x1, y1, c3d4, c3d4 + cd2, false).replace("M", "L") + " L" + x1 + "," + h + shapeArc(x1, h / 2, x1, y1, cd4, cd4 + cd2, false).replace("M", "L") + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartPunchedTape": {
      let x1, y1, y2, cd2 = 180;
      x1 = w * 5 / 20;
      y1 = h * 2 / 20;
      y2 = h * 18 / 20;
      let d = "M0," + y1 + shapeArc(x1, y1, x1, y1, cd2, 0, false).replace("M", "L") + shapeArc(w * (3 / 4), y1, x1, y1, cd2, 360, false).replace("M", "L") + " L" + w + "," + y2 + shapeArc(w * (3 / 4), y2, x1, y1, 0, -cd2, false).replace("M", "L") + shapeArc(x1, y2, x1, y1, 0, cd2, false).replace("M", "L") + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartOnlineStorage": {
      let x1, y1, c3d4 = 270, cd4 = 90;
      x1 = w * 1 / 6;
      y1 = h * 3 / 6;
      let d = "M" + x1 + ",0 L" + w + ",0" + shapeArc(w, h / 2, x1, y1, c3d4, 90, false).replace("M", "L") + " L" + x1 + "," + h + shapeArc(x1, h / 2, x1, y1, cd4, 270, false).replace("M", "L") + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartDisplay": {
      let x1, x2, y1, c3d4 = 270, cd2 = 180;
      x1 = w * 1 / 6;
      x2 = w * 5 / 6;
      y1 = h * 3 / 6;
      let d = "M0," + y1 + " L" + x1 + ",0 L" + x2 + ",0" + shapeArc(w, h / 2, x1, y1, c3d4, c3d4 + cd2, false).replace("M", "L") + " L" + x1 + "," + h + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartDelay": {
      let wd2 = w / 2, hd2 = h / 2, cd2 = 180, c3d4 = 270, cd4 = 90;
      let d = "M0,0 L" + wd2 + ",0" + shapeArc(wd2, hd2, wd2, hd2, c3d4, c3d4 + cd2, false).replace("M", "L") + " L0," + h + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "flowChartMagneticTape": {
      let wd2 = w / 2, hd2 = h / 2, cd2 = 180, c3d4 = 270, cd4 = 90;
      let idy, ib, ang1;
      idy = hd2 * Math.sin(Math.PI / 4);
      ib = hd2 + idy;
      ang1 = Math.atan(h / w);
      let ang1Dg = ang1 * 180 / Math.PI;
      let d = "M" + wd2 + "," + h + shapeArc(wd2, hd2, wd2, hd2, cd4, cd2, false).replace("M", "L") + shapeArc(wd2, hd2, wd2, hd2, cd2, c3d4, false).replace("M", "L") + shapeArc(wd2, hd2, wd2, hd2, c3d4, 360, false).replace("M", "L") + shapeArc(wd2, hd2, wd2, hd2, 0, ang1Dg, false).replace("M", "L") + " L" + w + "," + ib + " L" + w + "," + h + " z";
      result += "<path d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "ellipse":
    case "flowChartConnector":
    case "flowChartSummingJunction":
    case "flowChartOr": {
      result += "<ellipse cx='" + w / 2 + "' cy='" + h / 2 + "' rx='" + w / 2 + "' ry='" + h / 2 + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      if (shapType == "flowChartOr") {
        result += " <polyline points='" + w / 2 + " 0," + w / 2 + " " + h + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
        result += " <polyline points='0 " + h / 2 + "," + w + " " + h / 2 + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      } else if (shapType == "flowChartSummingJunction") {
        let iDx, idy, il, ir, it, ib, hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
        let angVal = Math.PI / 4;
        iDx = wd2 * Math.cos(angVal);
        idy = hd2 * Math.sin(angVal);
        il = hc - iDx;
        ir = hc + iDx;
        it = vc - idy;
        ib = vc + idy;
        result += " <polyline points='" + il + " " + it + "," + ir + " " + ib + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
        result += " <polyline points='" + ir + " " + it + "," + il + " " + ib + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      }
      break;
    }
    case "roundRect":
    case "round1Rect":
    case "round2DiagRect":
    case "round2SameRect":
    case "snip1Rect":
    case "snip2DiagRect":
    case "snip2SameRect":
    case "flowChartAlternateProcess":
    case "flowChartPunchedCard": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2;
      let sAdj22, sAdj2_val2;
      let shpTyp, adjTyp;
      if (shapAdjst_ary2 !== void 0 && shapAdjst_ary2.constructor === Array) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) / 5e4;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj2_val2 = parseInt(sAdj22.substr(4)) / 5e4;
          }
        }
      } else if (shapAdjst_ary2 !== void 0 && shapAdjst_ary2.constructor !== Array) {
        let sAdj = getTextByPathList(shapAdjst_ary2, ["attrs", "fmla"]);
        sAdj1_val2 = parseInt(sAdj.substr(4)) / 5e4;
        sAdj2_val2 = 0;
      }
      let tranglRott = "";
      switch (shapType) {
        case "roundRect":
        case "flowChartAlternateProcess":
          shpTyp = "round";
          adjTyp = "cornrAll";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          sAdj2_val2 = 0;
          break;
        case "round1Rect":
          shpTyp = "round";
          adjTyp = "cornr1";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          sAdj2_val2 = 0;
          break;
        case "round2DiagRect":
          shpTyp = "round";
          adjTyp = "diag";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          if (sAdj2_val2 === void 0) sAdj2_val2 = 0;
          break;
        case "round2SameRect":
          shpTyp = "round";
          adjTyp = "cornr2";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          if (sAdj2_val2 === void 0) sAdj2_val2 = 0;
          break;
        case "snip1Rect":
        case "flowChartPunchedCard":
          shpTyp = "snip";
          adjTyp = "cornr1";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          sAdj2_val2 = 0;
          if (shapType == "flowChartPunchedCard") {
            tranglRott = "transform='translate(" + w + ",0) scale(-1,1)'";
          }
          break;
        case "snip2DiagRect":
          shpTyp = "snip";
          adjTyp = "diag";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0;
          if (sAdj2_val2 === void 0) sAdj2_val2 = 0.33334;
          break;
        case "snip2SameRect":
          shpTyp = "snip";
          adjTyp = "cornr2";
          if (sAdj1_val2 === void 0) sAdj1_val2 = 0.33334;
          if (sAdj2_val2 === void 0) sAdj2_val2 = 0;
          break;
      }
      let d_val = shapeSnipRoundRect(w, h, sAdj1_val2, sAdj2_val2, shpTyp, adjTyp);
      result += "<path " + tranglRott + "  d='" + d_val + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "snipRoundRect": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.33334;
      let sAdj22, sAdj2_val2 = 0.33334;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) / 5e4;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj2_val2 = parseInt(sAdj22.substr(4)) / 5e4;
          }
        }
      }
      let d_val = "M0," + h + " L" + w + "," + h + " L" + w + "," + h / 2 * sAdj2_val2 + " L" + (w / 2 + w / 2 * (1 - sAdj2_val2)) + ",0 L" + w / 2 * sAdj1_val2 + ",0 Q0,0 0," + h / 2 * sAdj1_val2 + " z";
      result += "<path   d='" + d_val + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bentConnector2": {
      let d = "";
      d = "M 0 0 L " + w + " 0 L " + w + " " + h;
      result += "<path d='" + d + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' fill='none' ";
      if (markerStart) {
        result += markerStart;
      }
      if (markerEnd) {
        result += markerEnd;
      }
      result += "/>";
      break;
    }
    case "rtTriangle":
      result += " <polygon points='0 0,0 " + h + "," + w + " " + h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "triangle":
    case "flowChartExtract":
    case "flowChartMerge": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let shapAdjst_val = 0.5;
      if (shapAdjst !== void 0) {
        shapAdjst_val = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let tranglRott = "";
      if (shapType == "flowChartMerge") {
        tranglRott = "transform='rotate(180 " + w / 2 + "," + h / 2 + ")'";
      }
      result += " <polygon " + tranglRott + " points='" + w * shapAdjst_val + " 0,0 " + h + "," + w + " " + h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "diamond":
    case "flowChartDecision":
    case "flowChartSort":
      result += " <polygon points='" + w / 2 + " 0,0 " + h / 2 + "," + w / 2 + " " + h + "," + w + " " + h / 2 + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      if (shapType == "flowChartSort") {
        result += " <polyline points='0 " + h / 2 + "," + w + " " + h / 2 + "' fill='none' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      }
      break;
    case "trapezoid":
    case "flowChartManualOperation":
    case "flowChartManualInput": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adjst_val = 0.2;
      let max_adj_const = 0.7407;
      if (shapAdjst !== void 0) {
        let adjst = parseInt(shapAdjst.substr(4)) * slideFactor;
        adjst_val = adjst * 0.5 / max_adj_const;
      }
      let cnstVal = 0;
      let tranglRott = "";
      if (shapType == "flowChartManualOperation") {
        tranglRott = "transform='rotate(180 " + w / 2 + "," + h / 2 + ")'";
      }
      if (shapType == "flowChartManualInput") {
        adjst_val = 0;
        cnstVal = h / 5;
      }
      result += " <polygon " + tranglRott + " points='" + w * adjst_val + " " + cnstVal + ",0 " + h + "," + w + " " + h + "," + (1 - adjst_val) * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "parallelogram":
    case "flowChartInputOutput": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adjst_val = 0.25;
      let max_adj_const;
      if (w > h) {
        max_adj_const = w / h;
      } else {
        max_adj_const = h / w;
      }
      if (shapAdjst !== void 0) {
        let adjst = parseInt(shapAdjst.substr(4)) / 1e5;
        adjst_val = adjst / max_adj_const;
      }
      result += " <polygon points='" + adjst_val * w + " 0,0 " + h + "," + (1 - adjst_val) * w + " " + h + "," + w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
      break;
    }
    case "pentagon":
      result += " <polygon points='" + 0.5 * w + " 0,0 " + 0.375 * h + "," + 0.15 * w + " " + h + "," + 0.85 * w + " " + h + "," + w + " " + 0.375 * h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "hexagon":
    case "flowChartPreparation": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 25e3 * slideFactor;
      let vf = 115470 * slideFactor;
      ;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let angVal1 = 60 * Math.PI / 180;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let maxAdj, a, shd2, x1, x2, dy1, y1, y2, vc = h / 2, hd2 = h / 2;
      let ss = Math.min(w, h);
      maxAdj = cnstVal1 * w / ss;
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      shd2 = hd2 * vf / cnstVal2;
      x1 = ss * a / cnstVal2;
      x2 = w - x1;
      dy1 = shd2 * Math.sin(angVal1);
      y1 = vc - dy1;
      y2 = vc + dy1;
      let d = "M0," + vc + " L" + x1 + "," + y1 + " L" + x2 + "," + y1 + " L" + w + "," + vc + " L" + x2 + "," + y2 + " L" + x1 + "," + y2 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "heptagon":
      result += " <polygon points='" + 0.5 * w + " 0," + w / 8 + " " + h / 4 + ",0 " + 5 / 8 * h + "," + w / 4 + " " + h + "," + 3 / 4 * w + " " + h + "," + w + " " + 5 / 8 * h + "," + 7 / 8 * w + " " + h / 4 + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "octagon": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj1 = 0.25;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) / 1e5;
      }
      let adj2 = 1 - adj1;
      result += " <polygon points='" + adj1 * w + " 0,0 " + adj1 * h + ",0 " + adj2 * h + "," + adj1 * w + " " + h + "," + adj2 * w + " " + h + "," + w + " " + adj2 * h + "," + w + " " + adj1 * h + "," + adj2 * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "decagon":
      result += " <polygon points='" + 3 / 8 * w + " 0," + w / 8 + " " + h / 8 + ",0 " + h / 2 + "," + w / 8 + " " + 7 / 8 * h + "," + 3 / 8 * w + " " + h + "," + 5 / 8 * w + " " + h + "," + 7 / 8 * w + " " + 7 / 8 * h + "," + w + " " + h / 2 + "," + 7 / 8 * w + " " + h / 8 + "," + 5 / 8 * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "dodecagon":
      result += " <polygon points='" + 3 / 8 * w + " 0," + w / 8 + " " + h / 8 + ",0 " + 3 / 8 * h + ",0 " + 5 / 8 * h + "," + w / 8 + " " + 7 / 8 * h + "," + 3 / 8 * w + " " + h + "," + 5 / 8 * w + " " + h + "," + 7 / 8 * w + " " + 7 / 8 * h + "," + w + " " + 5 / 8 * h + "," + w + " " + 3 / 8 * h + "," + 7 / 8 * w + " " + h / 8 + "," + 5 / 8 * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "star4": {
      let a, iwd2, ihd2, sdx, sdy, sx1, sx2, sy1, sy2, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 19098 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_a = shapAdjst["attrs"]) == null ? void 0 : _a["name"];
        if (name == "adj") {
          adj = parseInt((_b = shapAdjst["attrs"]) == null ? void 0 : _b["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > cnstVal1 ? cnstVal1 : adj;
      iwd2 = wd2 * a / cnstVal1;
      ihd2 = hd2 * a / cnstVal1;
      sdx = iwd2 * Math.cos(0.7853981634);
      sdy = ihd2 * Math.sin(0.7853981634);
      sx1 = hc - sdx;
      sx2 = hc + sdx;
      sy1 = vc - sdy;
      sy2 = vc + sdy;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy1 + " L" + hc + ",0 L" + sx2 + "," + sy1 + " L" + w + "," + vc + " L" + sx2 + "," + sy2 + " L" + hc + "," + h + " L" + sx1 + "," + sy2 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star5": {
      let a, swd2, shd2, svc, dx1, dx2, dy1, dy2, x1, x2, x3, x4, y1, y2, iwd2, ihd2, sdx1, sdx2, sdy1, sdy2, sx1, sx2, sx3, sx4, sy1, sy2, sy3, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 19098 * slideFactor;
      let hf = 105146 * slideFactor;
      let vf = 110557 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        Object.keys(shapAdjst).forEach((key) => {
          var _a2, _b2, _c2, _d2;
          let name = (_a2 = shapAdjst[key]["attrs"]) == null ? void 0 : _a2["name"];
          if (name == "adj") {
            adj = parseInt((_b2 = shapAdjst[key]["attrs"]) == null ? void 0 : _b2["fmla"].substr(4)) * slideFactor;
          } else if (name == "hf") {
            hf = parseInt((_c2 = shapAdjst[key]["attrs"]) == null ? void 0 : _c2["fmla"].substr(4)) * slideFactor;
          } else if (name == "vf") {
            vf = parseInt((_d2 = shapAdjst[key]["attrs"]) == null ? void 0 : _d2["fmla"].substr(4)) * slideFactor;
          }
        });
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      swd2 = wd2 * hf / cnstVal1;
      shd2 = hd2 * vf / cnstVal1;
      svc = vc * vf / cnstVal1;
      dx1 = swd2 * Math.cos(0.31415926536);
      dx2 = swd2 * Math.cos(5.3407075111);
      dy1 = shd2 * Math.sin(0.31415926536);
      dy2 = shd2 * Math.sin(5.3407075111);
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc + dx2;
      x4 = hc + dx1;
      y1 = svc - dy1;
      y2 = svc - dy2;
      iwd2 = swd2 * a / maxAdj;
      ihd2 = shd2 * a / maxAdj;
      sdx1 = iwd2 * Math.cos(5.9690260418);
      sdx2 = iwd2 * Math.cos(0.94247779608);
      sdy1 = ihd2 * Math.sin(0.94247779608);
      sdy2 = ihd2 * Math.sin(5.9690260418);
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc + sdx2;
      sx4 = hc + sdx1;
      sy1 = svc - sdy1;
      sy2 = svc - sdy2;
      sy3 = svc + ihd2;
      yAdj = svc - ihd2;
      let d = "M" + x1 + "," + y1 + " L" + sx2 + "," + sy1 + " L" + hc + ",0 L" + sx3 + "," + sy1 + " L" + x4 + "," + y1 + " L" + sx4 + "," + sy2 + " L" + x3 + "," + y2 + " L" + hc + "," + sy3 + " L" + x2 + "," + y2 + " L" + sx1 + "," + sy2 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star6": {
      let a, swd2, dx1, x1, x2, y2, iwd2, ihd2, sdx2, sx1, sx2, sx3, sx4, sdy1, sy1, sy2, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2, hd4 = h / 4;
      let adj = 28868 * slideFactor;
      let hf = 115470 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        Object.keys(shapAdjst).forEach((key) => {
          var _a2, _b2, _c2;
          let name = (_a2 = shapAdjst[key]["attrs"]) == null ? void 0 : _a2["name"];
          if (name == "adj") {
            adj = parseInt((_b2 = shapAdjst[key]["attrs"]) == null ? void 0 : _b2["fmla"].substr(4)) * slideFactor;
          } else if (name == "hf") {
            hf = parseInt((_c2 = shapAdjst[key]["attrs"]) == null ? void 0 : _c2["fmla"].substr(4)) * slideFactor;
          }
        });
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      swd2 = wd2 * hf / cnstVal1;
      dx1 = swd2 * Math.cos(0.5235987756);
      x1 = hc - dx1;
      x2 = hc + dx1;
      y2 = vc + hd4;
      iwd2 = swd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx2 = iwd2 / 2;
      sx1 = hc - iwd2;
      sx2 = hc - sdx2;
      sx3 = hc + sdx2;
      sx4 = hc + iwd2;
      sdy1 = ihd2 * Math.sin(1.0471975512);
      sy1 = vc - sdy1;
      sy2 = vc + sdy1;
      yAdj = vc - ihd2;
      let d = "M" + x1 + "," + hd4 + " L" + sx2 + "," + sy1 + " L" + hc + ",0 L" + sx3 + "," + sy1 + " L" + x2 + "," + hd4 + " L" + sx4 + "," + vc + " L" + x2 + "," + y2 + " L" + sx3 + "," + sy2 + " L" + hc + "," + h + " L" + sx2 + "," + sy2 + " L" + x1 + "," + y2 + " L" + sx1 + "," + vc + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star7": {
      let a, swd2, shd2, svc, dx1, dx2, dx3, dy1, dy2, dy3, x1, x2, x3, x4, x5, x6, y1, y2, y3, iwd2, ihd2, sdx1, sdx2, sdx3, sx1, sx2, sx3, sx4, sx5, sx6, sdy1, sdy2, sdy3, sy1, sy2, sy3, sy4, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 34601 * slideFactor;
      let hf = 102572 * slideFactor;
      let vf = 105210 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        Object.keys(shapAdjst).forEach((key) => {
          var _a2, _b2, _c2, _d2;
          let name = (_a2 = shapAdjst[key]["attrs"]) == null ? void 0 : _a2["name"];
          if (name == "adj") {
            adj = parseInt((_b2 = shapAdjst[key]["attrs"]) == null ? void 0 : _b2["fmla"].substr(4)) * slideFactor;
          } else if (name == "hf") {
            hf = parseInt((_c2 = shapAdjst[key]["attrs"]) == null ? void 0 : _c2["fmla"].substr(4)) * slideFactor;
          } else if (name == "vf") {
            vf = parseInt((_d2 = shapAdjst[key]["attrs"]) == null ? void 0 : _d2["fmla"].substr(4)) * slideFactor;
          }
        });
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      swd2 = wd2 * hf / cnstVal1;
      shd2 = hd2 * vf / cnstVal1;
      svc = vc * vf / cnstVal1;
      dx1 = swd2 * 97493 / 1e5;
      dx2 = swd2 * 78183 / 1e5;
      dx3 = swd2 * 43388 / 1e5;
      dy1 = shd2 * 62349 / 1e5;
      dy2 = shd2 * 22252 / 1e5;
      dy3 = shd2 * 90097 / 1e5;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc - dx3;
      x4 = hc + dx3;
      x5 = hc + dx2;
      x6 = hc + dx1;
      y1 = svc - dy1;
      y2 = svc + dy2;
      y3 = svc + dy3;
      iwd2 = swd2 * a / maxAdj;
      ihd2 = shd2 * a / maxAdj;
      sdx1 = iwd2 * 97493 / 1e5;
      sdx2 = iwd2 * 78183 / 1e5;
      sdx3 = iwd2 * 43388 / 1e5;
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc - sdx3;
      sx4 = hc + sdx3;
      sx5 = hc + sdx2;
      sx6 = hc + sdx1;
      sdy1 = ihd2 * 90097 / 1e5;
      sdy2 = ihd2 * 22252 / 1e5;
      sdy3 = ihd2 * 62349 / 1e5;
      sy1 = svc - sdy1;
      sy2 = svc - sdy2;
      sy3 = svc + sdy3;
      sy4 = svc + ihd2;
      yAdj = svc - ihd2;
      let d = "M" + x1 + "," + y2 + " L" + sx1 + "," + sy2 + " L" + x2 + "," + y1 + " L" + sx3 + "," + sy1 + " L" + hc + ",0 L" + sx4 + "," + sy1 + " L" + x5 + "," + y1 + " L" + sx6 + "," + sy2 + " L" + x6 + "," + y2 + " L" + sx5 + "," + sy3 + " L" + x4 + "," + y3 + " L" + hc + "," + sy4 + " L" + x3 + "," + y3 + " L" + sx2 + "," + sy3 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star8": {
      let a, dx1, x1, x2, dy1, y1, y2, iwd2, ihd2, sdx1, sdx2, sdy1, sdy2, sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 37500 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_c = shapAdjst["attrs"]) == null ? void 0 : _c["name"];
        if (name == "adj") {
          adj = parseInt((_d = shapAdjst["attrs"]) == null ? void 0 : _d["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      dx1 = wd2 * Math.cos(0.7853981634);
      x1 = hc - dx1;
      x2 = hc + dx1;
      dy1 = hd2 * Math.sin(0.7853981634);
      y1 = vc - dy1;
      y2 = vc + dy1;
      iwd2 = wd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * 92388 / 1e5;
      sdx2 = iwd2 * 38268 / 1e5;
      sdy1 = ihd2 * 92388 / 1e5;
      sdy2 = ihd2 * 38268 / 1e5;
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc + sdx2;
      sx4 = hc + sdx1;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc + sdy2;
      sy4 = vc + sdy1;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy2 + " L" + x1 + "," + y1 + " L" + sx2 + "," + sy1 + " L" + hc + ",0 L" + sx3 + "," + sy1 + " L" + x2 + "," + y1 + " L" + sx4 + "," + sy2 + " L" + w + "," + vc + " L" + sx4 + "," + sy3 + " L" + x2 + "," + y2 + " L" + sx3 + "," + sy4 + " L" + hc + "," + h + " L" + sx2 + "," + sy4 + " L" + x1 + "," + y2 + " L" + sx1 + "," + sy3 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star10": {
      let a, swd2, dx1, dx2, x1, x2, x3, x4, dy1, dy2, y1, y2, y3, y4, iwd2, ihd2, sdx1, sdx2, sdy1, sdy2, sx1, sx2, sx3, sx4, sx5, sx6, sy1, sy2, sy3, sy4, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 42533 * slideFactor;
      let hf = 105146 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        Object.keys(shapAdjst).forEach((key) => {
          var _a2, _b2, _c2;
          let name = (_a2 = shapAdjst[key]["attrs"]) == null ? void 0 : _a2["name"];
          if (name == "adj") {
            adj = parseInt((_b2 = shapAdjst[key]["attrs"]) == null ? void 0 : _b2["fmla"].substr(4)) * slideFactor;
          } else if (name == "hf") {
            hf = parseInt((_c2 = shapAdjst[key]["attrs"]) == null ? void 0 : _c2["fmla"].substr(4)) * slideFactor;
          }
        });
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      swd2 = wd2 * hf / cnstVal1;
      dx1 = swd2 * 95106 / 1e5;
      dx2 = swd2 * 58779 / 1e5;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc + dx2;
      x4 = hc + dx1;
      dy1 = hd2 * 80902 / 1e5;
      dy2 = hd2 * 30902 / 1e5;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc + dy2;
      y4 = vc + dy1;
      iwd2 = swd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * 80902 / 1e5;
      sdx2 = iwd2 * 30902 / 1e5;
      sdy1 = ihd2 * 95106 / 1e5;
      sdy2 = ihd2 * 58779 / 1e5;
      sx1 = hc - iwd2;
      sx2 = hc - sdx1;
      sx3 = hc - sdx2;
      sx4 = hc + sdx2;
      sx5 = hc + sdx1;
      sx6 = hc + iwd2;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc + sdy2;
      sy4 = vc + sdy1;
      yAdj = vc - ihd2;
      let d = "M" + x1 + "," + y2 + " L" + sx2 + "," + sy2 + " L" + x2 + "," + y1 + " L" + sx3 + "," + sy1 + " L" + hc + ",0 L" + sx4 + "," + sy1 + " L" + x3 + "," + y1 + " L" + sx5 + "," + sy2 + " L" + x4 + "," + y2 + " L" + sx6 + "," + vc + " L" + x4 + "," + y3 + " L" + sx5 + "," + sy3 + " L" + x3 + "," + y4 + " L" + sx4 + "," + sy4 + " L" + hc + "," + h + " L" + sx3 + "," + sy4 + " L" + x2 + "," + y4 + " L" + sx2 + "," + sy3 + " L" + x1 + "," + y3 + " L" + sx1 + "," + vc + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star12": {
      let a, dx1, dy1, x1, x3, x4, y1, y3, y4, iwd2, ihd2, sdx1, sdx2, sdx3, sdy1, sdy2, sdy3, sx1, sx2, sx3, sx4, sx5, sx6, sy1, sy2, sy3, sy4, sy5, sy6, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2, hd4 = h / 4, wd4 = w / 4;
      let adj = 37500 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_e = shapAdjst["attrs"]) == null ? void 0 : _e["name"];
        if (name == "adj") {
          adj = parseInt((_f = shapAdjst["attrs"]) == null ? void 0 : _f["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      dx1 = wd2 * Math.cos(0.5235987756);
      dy1 = hd2 * Math.sin(1.0471975512);
      x1 = hc - dx1;
      x3 = w * 3 / 4;
      x4 = hc + dx1;
      y1 = vc - dy1;
      y3 = h * 3 / 4;
      y4 = vc + dy1;
      iwd2 = wd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * Math.cos(0.2617993878);
      sdx2 = iwd2 * Math.cos(0.7853981634);
      sdx3 = iwd2 * Math.cos(1.308996939);
      sdy1 = ihd2 * Math.sin(1.308996939);
      sdy2 = ihd2 * Math.sin(0.7853981634);
      sdy3 = ihd2 * Math.sin(0.2617993878);
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc - sdx3;
      sx4 = hc + sdx3;
      sx5 = hc + sdx2;
      sx6 = hc + sdx1;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc - sdy3;
      sy4 = vc + sdy3;
      sy5 = vc + sdy2;
      sy6 = vc + sdy1;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy3 + " L" + x1 + "," + hd4 + " L" + sx2 + "," + sy2 + " L" + wd4 + "," + y1 + " L" + sx3 + "," + sy1 + " L" + hc + ",0 L" + sx4 + "," + sy1 + " L" + x3 + "," + y1 + " L" + sx5 + "," + sy2 + " L" + x4 + "," + hd4 + " L" + sx6 + "," + sy3 + " L" + w + "," + vc + " L" + sx6 + "," + sy4 + " L" + x4 + "," + y3 + " L" + sx5 + "," + sy5 + " L" + x3 + "," + y4 + " L" + sx4 + "," + sy6 + " L" + hc + "," + h + " L" + sx3 + "," + sy6 + " L" + wd4 + "," + y4 + " L" + sx2 + "," + sy5 + " L" + x1 + "," + y3 + " L" + sx1 + "," + sy4 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star16": {
      let a, dx1, dx2, dx3, dy1, dy2, dy3, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6, iwd2, ihd2, sdx1, sdx2, sdx3, sdx4, sdy1, sdy2, sdy3, sdy4, sx1, sx2, sx3, sx4, sx5, sx6, sx7, sx8, sy1, sy2, sy3, sy4, sy5, sy6, sy7, sy8, iDx, idy, il, it, ir, ib, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2;
      let adj = 37500 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_g = shapAdjst["attrs"]) == null ? void 0 : _g["name"];
        if (name == "adj") {
          adj = parseInt((_h = shapAdjst["attrs"]) == null ? void 0 : _h["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      dx1 = wd2 * 92388 / 1e5;
      dx2 = wd2 * 70711 / 1e5;
      dx3 = wd2 * 38268 / 1e5;
      dy1 = hd2 * 92388 / 1e5;
      dy2 = hd2 * 70711 / 1e5;
      dy3 = hd2 * 38268 / 1e5;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc - dx3;
      x4 = hc + dx3;
      x5 = hc + dx2;
      x6 = hc + dx1;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc - dy3;
      y4 = vc + dy3;
      y5 = vc + dy2;
      y6 = vc + dy1;
      iwd2 = wd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * 98079 / 1e5;
      sdx2 = iwd2 * 83147 / 1e5;
      sdx3 = iwd2 * 55557 / 1e5;
      sdx4 = iwd2 * 19509 / 1e5;
      sdy1 = ihd2 * 98079 / 1e5;
      sdy2 = ihd2 * 83147 / 1e5;
      sdy3 = ihd2 * 55557 / 1e5;
      sdy4 = ihd2 * 19509 / 1e5;
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc - sdx3;
      sx4 = hc - sdx4;
      sx5 = hc + sdx4;
      sx6 = hc + sdx3;
      sx7 = hc + sdx2;
      sx8 = hc + sdx1;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc - sdy3;
      sy4 = vc - sdy4;
      sy5 = vc + sdy4;
      sy6 = vc + sdy3;
      sy7 = vc + sdy2;
      sy8 = vc + sdy1;
      iDx = iwd2 * Math.cos(0.7853981634);
      idy = ihd2 * Math.sin(0.7853981634);
      il = hc - iDx;
      it = vc - idy;
      ir = hc + iDx;
      ib = vc + idy;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy4 + " L" + x1 + "," + y3 + " L" + sx2 + "," + sy3 + " L" + x2 + "," + y2 + " L" + sx3 + "," + sy2 + " L" + x3 + "," + y1 + " L" + sx4 + "," + sy1 + " L" + hc + ",0 L" + sx5 + "," + sy1 + " L" + x4 + "," + y1 + " L" + sx6 + "," + sy2 + " L" + x5 + "," + y2 + " L" + sx7 + "," + sy3 + " L" + x6 + "," + y3 + " L" + sx8 + "," + sy4 + " L" + w + "," + vc + " L" + sx8 + "," + sy5 + " L" + x6 + "," + y4 + " L" + sx7 + "," + sy6 + " L" + x5 + "," + y5 + " L" + sx6 + "," + sy7 + " L" + x4 + "," + y6 + " L" + sx5 + "," + sy8 + " L" + hc + "," + h + " L" + sx4 + "," + sy8 + " L" + x3 + "," + y6 + " L" + sx3 + "," + sy7 + " L" + x2 + "," + y5 + " L" + sx2 + "," + sy6 + " L" + x1 + "," + y4 + " L" + sx1 + "," + sy5 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star24": {
      let a, dx1, dx2, dx3, dx4, dx5, dy1, dy2, dy3, dy4, dy5, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, iwd2, ihd2, sdx1, sdx2, sdx3, sdx4, sdx5, sdx6, sdy1, sdy2, sdy3, sdy4, sdy5, sdy6, sx1, sx2, sx3, sx4, sx5, sx6, sx7, sx8, sx9, sx10, sx11, sx12, sy1, sy2, sy3, sy4, sy5, sy6, sy7, sy8, sy9, sy10, sy11, sy12, iDx, idy, il, it, ir, ib, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2, hd4 = h / 4, wd4 = w / 4;
      let adj = 37500 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_i = shapAdjst["attrs"]) == null ? void 0 : _i["name"];
        if (name == "adj") {
          adj = parseInt((_j = shapAdjst["attrs"]) == null ? void 0 : _j["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      dx1 = wd2 * Math.cos(0.2617993878);
      dx2 = wd2 * Math.cos(0.5235987756);
      dx3 = wd2 * Math.cos(0.7853981634);
      dx4 = wd4;
      dx5 = wd2 * Math.cos(1.308996939);
      dy1 = hd2 * Math.sin(1.308996939);
      dy2 = hd2 * Math.sin(1.0471975512);
      dy3 = hd2 * Math.sin(0.7853981634);
      dy4 = hd4;
      dy5 = hd2 * Math.sin(0.2617993878);
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc - dx3;
      x4 = hc - dx4;
      x5 = hc - dx5;
      x6 = hc + dx5;
      x7 = hc + dx4;
      x8 = hc + dx3;
      x9 = hc + dx2;
      x10 = hc + dx1;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc - dy3;
      y4 = vc - dy4;
      y5 = vc - dy5;
      y6 = vc + dy5;
      y7 = vc + dy4;
      y8 = vc + dy3;
      y9 = vc + dy2;
      y10 = vc + dy1;
      iwd2 = wd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * 99144 / 1e5;
      sdx2 = iwd2 * 92388 / 1e5;
      sdx3 = iwd2 * 79335 / 1e5;
      sdx4 = iwd2 * 60876 / 1e5;
      sdx5 = iwd2 * 38268 / 1e5;
      sdx6 = iwd2 * 13053 / 1e5;
      sdy1 = ihd2 * 99144 / 1e5;
      sdy2 = ihd2 * 92388 / 1e5;
      sdy3 = ihd2 * 79335 / 1e5;
      sdy4 = ihd2 * 60876 / 1e5;
      sdy5 = ihd2 * 38268 / 1e5;
      sdy6 = ihd2 * 13053 / 1e5;
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc - sdx3;
      sx4 = hc - sdx4;
      sx5 = hc - sdx5;
      sx6 = hc - sdx6;
      sx7 = hc + sdx6;
      sx8 = hc + sdx5;
      sx9 = hc + sdx4;
      sx10 = hc + sdx3;
      sx11 = hc + sdx2;
      sx12 = hc + sdx1;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc - sdy3;
      sy4 = vc - sdy4;
      sy5 = vc - sdy5;
      sy6 = vc - sdy6;
      sy7 = vc + sdy6;
      sy8 = vc + sdy5;
      sy9 = vc + sdy4;
      sy10 = vc + sdy3;
      sy11 = vc + sdy2;
      sy12 = vc + sdy1;
      iDx = iwd2 * Math.cos(0.7853981634);
      idy = ihd2 * Math.sin(0.7853981634);
      il = hc - iDx;
      it = vc - idy;
      ir = hc + iDx;
      ib = vc + idy;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy6 + " L" + x1 + "," + y5 + " L" + sx2 + "," + sy5 + " L" + x2 + "," + y4 + " L" + sx3 + "," + sy4 + " L" + x3 + "," + y3 + " L" + sx4 + "," + sy3 + " L" + x4 + "," + y2 + " L" + sx5 + "," + sy2 + " L" + x5 + "," + y1 + " L" + sx6 + "," + sy1 + " L" + hc + ",0 L" + sx7 + "," + sy1 + " L" + x6 + "," + y1 + " L" + sx8 + "," + sy2 + " L" + x7 + "," + y2 + " L" + sx9 + "," + sy3 + " L" + x8 + "," + y3 + " L" + sx10 + "," + sy4 + " L" + x9 + "," + y4 + " L" + sx11 + "," + sy5 + " L" + x10 + "," + y5 + " L" + sx12 + "," + sy6 + " L" + w + "," + vc + " L" + sx12 + "," + sy7 + " L" + x10 + "," + y6 + " L" + sx11 + "," + sy8 + " L" + x9 + "," + y7 + " L" + sx10 + "," + sy9 + " L" + x8 + "," + y8 + " L" + sx9 + "," + sy10 + " L" + x7 + "," + y9 + " L" + sx8 + "," + sy11 + " L" + x6 + "," + y10 + " L" + sx7 + "," + sy12 + " L" + hc + "," + h + " L" + sx6 + "," + sy12 + " L" + x5 + "," + y10 + " L" + sx5 + "," + sy11 + " L" + x4 + "," + y9 + " L" + sx4 + "," + sy10 + " L" + x3 + "," + y8 + " L" + sx3 + "," + sy9 + " L" + x2 + "," + y7 + " L" + sx2 + "," + sy8 + " L" + x1 + "," + y6 + " L" + sx1 + "," + sy7 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "star32": {
      let a, dx1, dx2, dx3, dx4, dx5, dx6, dx7, dy1, dy2, dy3, dy4, dy5, dy6, dy7, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, iwd2, ihd2, sdx1, sdx2, sdx3, sdx4, sdx5, sdx6, sdx7, sdx8, sdy1, sdy2, sdy3, sdy4, sdy5, sdy6, sdy7, sdy8, sx1, sx2, sx3, sx4, sx5, sx6, sx7, sx8, sx9, sx10, sx11, sx12, sx13, sx14, sx15, sx16, sy1, sy2, sy3, sy4, sy5, sy6, sy7, sy8, sy9, sy10, sy11, sy12, sy13, sy14, sy15, sy16, iDx, idy, il, it, ir, ib, yAdj;
      let hc = w / 2, vc = h / 2, wd2 = w / 2, hd2 = h / 2, hd4 = h / 4, wd4 = w / 4;
      let adj = 37500 * slideFactor;
      let maxAdj = 5e4 * slideFactor;
      let shapAdjst = shapAdjstArr;
      if (shapAdjst !== void 0) {
        let name = (_k = shapAdjst["attrs"]) == null ? void 0 : _k["name"];
        if (name == "adj") {
          adj = parseInt((_l = shapAdjst["attrs"]) == null ? void 0 : _l["fmla"].substr(4)) * slideFactor;
        }
      }
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      dx1 = wd2 * 98079 / 1e5;
      dx2 = wd2 * 92388 / 1e5;
      dx3 = wd2 * 83147 / 1e5;
      dx4 = wd2 * Math.cos(0.7853981634);
      dx5 = wd2 * 55557 / 1e5;
      dx6 = wd2 * 38268 / 1e5;
      dx7 = wd2 * 19509 / 1e5;
      dy1 = hd2 * 98079 / 1e5;
      dy2 = hd2 * 92388 / 1e5;
      dy3 = hd2 * 83147 / 1e5;
      dy4 = hd2 * Math.sin(0.7853981634);
      dy5 = hd2 * 55557 / 1e5;
      dy6 = hd2 * 38268 / 1e5;
      dy7 = hd2 * 19509 / 1e5;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc - dx3;
      x4 = hc - dx4;
      x5 = hc - dx5;
      x6 = hc - dx6;
      x7 = hc - dx7;
      x8 = hc + dx7;
      x9 = hc + dx6;
      x10 = hc + dx5;
      x11 = hc + dx4;
      x12 = hc + dx3;
      x13 = hc + dx2;
      x14 = hc + dx1;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc - dy3;
      y4 = vc - dy4;
      y5 = vc - dy5;
      y6 = vc - dy6;
      y7 = vc - dy7;
      y8 = vc + dy7;
      y9 = vc + dy6;
      y10 = vc + dy5;
      y11 = vc + dy4;
      y12 = vc + dy3;
      y13 = vc + dy2;
      y14 = vc + dy1;
      iwd2 = wd2 * a / maxAdj;
      ihd2 = hd2 * a / maxAdj;
      sdx1 = iwd2 * 99518 / 1e5;
      sdx2 = iwd2 * 95694 / 1e5;
      sdx3 = iwd2 * 88192 / 1e5;
      sdx4 = iwd2 * 77301 / 1e5;
      sdx5 = iwd2 * 63439 / 1e5;
      sdx6 = iwd2 * 47140 / 1e5;
      sdx7 = iwd2 * 29028 / 1e5;
      sdx8 = iwd2 * 9802 / 1e5;
      sdy1 = ihd2 * 99518 / 1e5;
      sdy2 = ihd2 * 95694 / 1e5;
      sdy3 = ihd2 * 88192 / 1e5;
      sdy4 = ihd2 * 77301 / 1e5;
      sdy5 = ihd2 * 63439 / 1e5;
      sdy6 = ihd2 * 47140 / 1e5;
      sdy7 = ihd2 * 29028 / 1e5;
      sdy8 = ihd2 * 9802 / 1e5;
      sx1 = hc - sdx1;
      sx2 = hc - sdx2;
      sx3 = hc - sdx3;
      sx4 = hc - sdx4;
      sx5 = hc - sdx5;
      sx6 = hc - sdx6;
      sx7 = hc - sdx7;
      sx8 = hc - sdx8;
      sx9 = hc + sdx8;
      sx10 = hc + sdx7;
      sx11 = hc + sdx6;
      sx12 = hc + sdx5;
      sx13 = hc + sdx4;
      sx14 = hc + sdx3;
      sx15 = hc + sdx2;
      sx16 = hc + sdx1;
      sy1 = vc - sdy1;
      sy2 = vc - sdy2;
      sy3 = vc - sdy3;
      sy4 = vc - sdy4;
      sy5 = vc - sdy5;
      sy6 = vc - sdy6;
      sy7 = vc - sdy7;
      sy8 = vc - sdy8;
      sy9 = vc + sdy8;
      sy10 = vc + sdy7;
      sy11 = vc + sdy6;
      sy12 = vc + sdy5;
      sy13 = vc + sdy4;
      sy14 = vc + sdy3;
      sy15 = vc + sdy2;
      sy16 = vc + sdy1;
      iDx = iwd2 * Math.cos(0.7853981634);
      idy = ihd2 * Math.sin(0.7853981634);
      il = hc - iDx;
      it = vc - idy;
      ir = hc + iDx;
      ib = vc + idy;
      yAdj = vc - ihd2;
      let d = "M0," + vc + " L" + sx1 + "," + sy8 + " L" + x1 + "," + y7 + " L" + sx2 + "," + sy7 + " L" + x2 + "," + y6 + " L" + sx3 + "," + sy6 + " L" + x3 + "," + y5 + " L" + sx4 + "," + sy5 + " L" + x4 + "," + y4 + " L" + sx5 + "," + sy4 + " L" + x5 + "," + y3 + " L" + sx6 + "," + sy3 + " L" + x6 + "," + y2 + " L" + sx7 + "," + sy2 + " L" + x7 + "," + y1 + " L" + sx8 + "," + sy1 + " L" + hc + ",0 L" + sx9 + "," + sy1 + " L" + x8 + "," + y1 + " L" + sx10 + "," + sy2 + " L" + x9 + "," + y2 + " L" + sx11 + "," + sy3 + " L" + x10 + "," + y3 + " L" + sx12 + "," + sy4 + " L" + x11 + "," + y4 + " L" + sx13 + "," + sy5 + " L" + x12 + "," + y5 + " L" + sx14 + "," + sy6 + " L" + x13 + "," + y6 + " L" + sx15 + "," + sy7 + " L" + x14 + "," + y7 + " L" + sx16 + "," + sy8 + " L" + w + "," + vc + " L" + sx16 + "," + sy9 + " L" + x14 + "," + y8 + " L" + sx15 + "," + sy10 + " L" + x13 + "," + y9 + " L" + sx14 + "," + sy11 + " L" + x12 + "," + y10 + " L" + sx13 + "," + sy12 + " L" + x11 + "," + y11 + " L" + sx12 + "," + sy13 + " L" + x10 + "," + y12 + " L" + sx11 + "," + sy14 + " L" + x9 + "," + y13 + " L" + sx10 + "," + sy15 + " L" + x8 + "," + y14 + " L" + sx9 + "," + sy16 + " L" + hc + "," + h + " L" + sx8 + "," + sy16 + " L" + x7 + "," + y14 + " L" + sx7 + "," + sy15 + " L" + x6 + "," + y13 + " L" + sx6 + "," + sy14 + " L" + x5 + "," + y12 + " L" + sx5 + "," + sy13 + " L" + x4 + "," + y11 + " L" + sx4 + "," + sy12 + " L" + x3 + "," + y10 + " L" + sx3 + "," + sy11 + " L" + x2 + "," + y9 + " L" + sx2 + "," + sy10 + " L" + x1 + "," + y8 + " L" + sx1 + "," + sy9 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "pie":
    case "pieWedge":
    case "arc": {
      let shapAdjst = shapAdjstArr;
      let adj1, adj2, H, shapAdjst1, shapAdjst2, isClose;
      if (shapType == "pie") {
        adj1 = 0;
        adj2 = 270;
        H = h;
        isClose = true;
      } else if (shapType == "pieWedge") {
        adj1 = 180;
        adj2 = 270;
        H = 2 * h;
        isClose = true;
      } else if (shapType == "arc") {
        adj1 = 270;
        adj2 = 0;
        H = h;
        isClose = false;
      }
      if (shapAdjst !== void 0) {
        shapAdjst1 = getTextByPathList(shapAdjst, ["attrs", "fmla"]);
        shapAdjst2 = shapAdjst1;
        if (shapAdjst1 === void 0) {
          shapAdjst1 = (_m = shapAdjst[0]["attrs"]) == null ? void 0 : _m["fmla"];
          shapAdjst2 = (_n = shapAdjst[1]["attrs"]) == null ? void 0 : _n["fmla"];
        }
        if (shapAdjst1 !== void 0) {
          adj1 = parseInt(shapAdjst1.substr(4)) / 6e4;
        }
        if (shapAdjst2 !== void 0) {
          adj2 = parseInt(shapAdjst2.substr(4)) / 6e4;
        }
      }
      let pieVals = shapePie(H, w, adj1, adj2, isClose);
      result += "<path   d='" + pieVals[0] + "' transform='" + pieVals[1] + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "chord": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 45;
      let sAdj22, sAdj2_val2 = 270;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) / 6e4;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj2_val2 = parseInt(sAdj22.substr(4)) / 6e4;
          }
        }
      }
      let hR = h / 2;
      let wR = w / 2;
      let d_val = shapeArc(wR, hR, wR, hR, sAdj1_val2, sAdj2_val2, true);
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "frame": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj1 = 12500 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a1, x1, x4, y4;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnstVal1) a1 = cnstVal1;
      else a1 = adj1;
      x1 = Math.min(w, h) * a1 / cnstVal2;
      x4 = w - x1;
      y4 = h - x1;
      let d = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " zM" + x1 + "," + x1 + " L" + x1 + "," + y4 + " L" + x4 + "," + y4 + " L" + x4 + "," + x1 + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "donut": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a, dr, iwd2, ihd2;
      if (adj < 0) a = 0;
      else if (adj > cnstVal1) a = cnstVal1;
      else a = adj;
      dr = Math.min(w, h) * a / cnstVal2;
      iwd2 = w / 2 - dr;
      ihd2 = h / 2 - dr;
      let d = "M0," + h / 2 + shapeArc(w / 2, h / 2, w / 2, h / 2, 180, 270, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 270, 360, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 0, 90, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 90, 180, false).replace("M", "L") + " zM" + dr + "," + h / 2 + shapeArc(w / 2, h / 2, iwd2, ihd2, 180, 90, false).replace("M", "L") + shapeArc(w / 2, h / 2, iwd2, ihd2, 90, 0, false).replace("M", "L") + shapeArc(w / 2, h / 2, iwd2, ihd2, 0, -90, false).replace("M", "L") + shapeArc(w / 2, h / 2, iwd2, ihd2, 270, 180, false).replace("M", "L") + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "noSmoking": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 18750 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a, dr, iwd2, ihd2, ang, ang2rad, ct, st, m, n, drd2, dang, dang2, swAng, t3, stAng1, stAng2;
      if (adj < 0) a = 0;
      else if (adj > cnstVal1) a = cnstVal1;
      else a = adj;
      dr = Math.min(w, h) * a / cnstVal2;
      iwd2 = w / 2 - dr;
      ihd2 = h / 2 - dr;
      ang = Math.atan(h / w);
      ct = ihd2 * Math.cos(ang);
      st = iwd2 * Math.sin(ang);
      m = Math.sqrt(ct * ct + st * st);
      n = iwd2 * ihd2 / m;
      drd2 = dr / 2;
      dang = Math.atan(drd2 / n);
      dang2 = dang * 2;
      swAng = -Math.PI + dang2;
      stAng1 = ang - dang;
      stAng2 = stAng1 - Math.PI;
      let ct1, st1, m1, n1, dx1, dy1, x1, x2, y1, y2;
      ct1 = ihd2 * Math.cos(stAng1);
      st1 = iwd2 * Math.sin(stAng1);
      m1 = Math.sqrt(ct1 * ct1 + st1 * st1);
      n1 = iwd2 * ihd2 / m1;
      dx1 = n1 * Math.cos(stAng1);
      dy1 = n1 * Math.sin(stAng1);
      x1 = w / 2 + dx1;
      y1 = h / 2 + dy1;
      x2 = w / 2 - dx1;
      y2 = h / 2 - dy1;
      let stAng1deg = stAng1 * 180 / Math.PI;
      let stAng2deg = stAng2 * 180 / Math.PI;
      let swAng2deg = swAng * 180 / Math.PI;
      let d = "M0," + h / 2 + shapeArc(w / 2, h / 2, w / 2, h / 2, 180, 270, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 270, 360, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 0, 90, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 90, 180, false).replace("M", "L") + " zM" + x1 + "," + y1 + shapeArc(w / 2, h / 2, iwd2, ihd2, stAng1deg, stAng1deg + swAng2deg, false).replace("M", "L") + " zM" + x2 + "," + y2 + shapeArc(w / 2, h / 2, iwd2, ihd2, stAng2deg, stAng2deg + swAng2deg, false).replace("M", "L") + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "halfFrame": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 3.5;
      let sAdj22, sAdj2_val2 = 3.5;
      let cnsVal = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj2_val2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let minWH = Math.min(w, h);
      let maxAdj2 = cnsVal * w / minWH;
      let a1, a2;
      if (sAdj2_val2 < 0) a2 = 0;
      else if (sAdj2_val2 > maxAdj2) a2 = maxAdj2;
      else a2 = sAdj2_val2;
      let x1 = minWH * a2 / cnsVal;
      let g1 = h * x1 / w;
      let g2 = h - g1;
      let maxAdj1 = cnsVal * g2 / minWH;
      if (sAdj1_val2 < 0) a1 = 0;
      else if (sAdj1_val2 > maxAdj1) a1 = maxAdj1;
      else a1 = sAdj1_val2;
      let y1 = minWH * a1 / cnsVal;
      let dx2 = y1 * w / h;
      let x2 = w - dx2;
      let dy2 = x1 * h / w;
      let y2 = h - dy2;
      let d = "M0,0 L" + w + ",0 L" + x2 + "," + y1 + " L" + x1 + "," + y1 + " L" + x1 + "," + y2 + " L0," + h + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "blockArc": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 180;
      let sAdj22, adj2 = 0;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) / 6e4;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) / 6e4;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let stAng, istAng, a3, sw11, sw12, swAng, iswAng;
      let cd1 = 360;
      if (adj1 < 0) stAng = 0;
      else if (adj1 > cd1) stAng = cd1;
      else stAng = adj1;
      if (adj2 < 0) istAng = 0;
      else if (adj2 > cd1) istAng = cd1;
      else istAng = adj2;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > cnstVal1) a3 = cnstVal1;
      else a3 = adj3;
      sw11 = istAng - stAng;
      sw12 = sw11 + cd1;
      swAng = sw11 > 0 ? sw11 : sw12;
      iswAng = -swAng;
      let endAng = stAng + swAng;
      let iendAng = istAng + iswAng;
      let wt1, ht1, dx1, dy1, x1, y1, stRd, istRd, wd2, hd2, hc, vc;
      stRd = stAng * Math.PI / 180;
      istRd = istAng * Math.PI / 180;
      wd2 = w / 2;
      hd2 = h / 2;
      hc = w / 2;
      vc = h / 2;
      if (stAng > 90 && stAng < 270) {
        wt1 = wd2 * Math.sin(Math.PI / 2 - stRd);
        ht1 = hd2 * Math.cos(Math.PI / 2 - stRd);
        dx1 = wd2 * Math.cos(Math.atan(ht1 / wt1));
        dy1 = hd2 * Math.sin(Math.atan(ht1 / wt1));
        x1 = hc - dx1;
        y1 = vc - dy1;
      } else {
        wt1 = wd2 * Math.sin(stRd);
        ht1 = hd2 * Math.cos(stRd);
        dx1 = wd2 * Math.cos(Math.atan(wt1 / ht1));
        dy1 = hd2 * Math.sin(Math.atan(wt1 / ht1));
        x1 = hc + dx1;
        y1 = vc + dy1;
      }
      let dr, iwd2, ihd2, wt2, ht2, dx2, dy2, x2, y2;
      dr = Math.min(w, h) * a3 / cnstVal2;
      iwd2 = wd2 - dr;
      ihd2 = hd2 - dr;
      if (endAng <= 450 && endAng > 270 || endAng >= 630 && endAng < 720) {
        wt2 = iwd2 * Math.sin(istRd);
        ht2 = ihd2 * Math.cos(istRd);
        dx2 = iwd2 * Math.cos(Math.atan(wt2 / ht2));
        dy2 = ihd2 * Math.sin(Math.atan(wt2 / ht2));
        x2 = hc + dx2;
        y2 = vc + dy2;
      } else {
        wt2 = iwd2 * Math.sin(Math.PI / 2 - istRd);
        ht2 = ihd2 * Math.cos(Math.PI / 2 - istRd);
        dx2 = iwd2 * Math.cos(Math.atan(ht2 / wt2));
        dy2 = ihd2 * Math.sin(Math.atan(ht2 / wt2));
        x2 = hc - dx2;
        y2 = vc - dy2;
      }
      let d = "M" + x1 + "," + y1 + shapeArc(wd2, hd2, wd2, hd2, stAng, endAng, false).replace("M", "L") + " L" + x2 + "," + y2 + shapeArc(wd2, hd2, iwd2, ihd2, istAng, iendAng, false).replace("M", "L") + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bracePair": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 8333 * slideFactor;
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal2 = 5e4 * slideFactor;
      let cnstVal3 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let vc = h / 2, cd = 360, cd2 = 180, cd4 = 90, c3d4 = 270, a, x1, x2, x3, x4, y2, y3, y4;
      if (adj < 0) a = 0;
      else if (adj > cnstVal1) a = cnstVal1;
      else a = adj;
      let minWH = Math.min(w, h);
      x1 = minWH * a / cnstVal3;
      x2 = minWH * a / cnstVal2;
      x3 = w - x2;
      x4 = w - x1;
      y2 = vc - x1;
      y3 = vc + x1;
      y4 = h - x1;
      let d = "M" + x2 + "," + h + shapeArc(x2, y4, x1, x1, cd4, cd2, false).replace("M", "L") + " L" + x1 + "," + y3 + shapeArc(0, y3, x1, x1, 0, -cd4, false).replace("M", "L") + shapeArc(0, y2, x1, x1, cd4, 0, false).replace("M", "L") + " L" + x1 + "," + x1 + shapeArc(x2, x1, x1, x1, cd2, c3d4, false).replace("M", "L") + " M" + x3 + ",0" + shapeArc(x3, x1, x1, x1, c3d4, cd, false).replace("M", "L") + " L" + x4 + "," + y2 + shapeArc(w, y2, x1, x1, cd2, cd4, false).replace("M", "L") + shapeArc(w, y3, x1, x1, c3d4, cd2, false).replace("M", "L") + " L" + x4 + "," + y4 + shapeArc(x3, y4, x1, x1, 0, cd4, false).replace("M", "L");
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftBrace": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 8333 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, cd2 = 180, cd4 = 90, c3d4 = 270, a1, a2, q1, q2, q3, y1, y2, y3, y4;
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal2) a2 = cnstVal2;
      else a2 = adj2;
      let minWH = Math.min(w, h);
      q1 = cnstVal2 - a2;
      if (q1 < a2) q2 = q1;
      else q2 = a2;
      q3 = q2 / 2;
      let maxAdj1 = q3 * h / minWH;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      y1 = minWH * a1 / cnstVal2;
      y3 = h * a2 / cnstVal2;
      y2 = y3 - y1;
      y4 = y3 + y1;
      let d = "M" + w + "," + h + shapeArc(w, h - y1, w / 2, y1, cd4, cd2, false).replace("M", "L") + " L" + w / 2 + "," + y4 + shapeArc(0, y4, w / 2, y1, 0, -cd4, false).replace("M", "L") + shapeArc(0, y2, w / 2, y1, cd4, 0, false).replace("M", "L") + " L" + w / 2 + "," + y1 + shapeArc(w, y1, w / 2, y1, cd2, c3d4, false).replace("M", "L");
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "rightBrace": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 8333 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, cd = 360, cd2 = 180, cd4 = 90, c3d4 = 270, a1, a2, q1, q2, q3, y1, y2, y3, y4;
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal2) a2 = cnstVal2;
      else a2 = adj2;
      let minWH = Math.min(w, h);
      q1 = cnstVal2 - a2;
      if (q1 < a2) q2 = q1;
      else q2 = a2;
      q3 = q2 / 2;
      let maxAdj1 = q3 * h / minWH;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      y1 = minWH * a1 / cnstVal2;
      y3 = h * a2 / cnstVal2;
      y2 = y3 - y1;
      y4 = h - y1;
      let d = "M0,0" + shapeArc(0, y1, w / 2, y1, c3d4, cd, false).replace("M", "L") + " L" + w / 2 + "," + y2 + shapeArc(w, y2, w / 2, y1, cd2, cd4, false).replace("M", "L") + shapeArc(w, y3 + y1, w / 2, y1, c3d4, cd2, false).replace("M", "L") + " L" + w / 2 + "," + y4 + shapeArc(0, y4, w / 2, y1, 0, cd4, false).replace("M", "L");
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bracketPair": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 16667 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let r = w, b = h, cd2 = 180, cd4 = 90, c3d4 = 270, a, x1, x2, y2;
      if (adj < 0) a = 0;
      else if (adj > cnstVal1) a = cnstVal1;
      else a = adj;
      x1 = Math.min(w, h) * a / cnstVal2;
      x2 = r - x1;
      y2 = b - x1;
      let d = shapeArc(x1, x1, x1, x1, c3d4, cd2, false) + shapeArc(x1, y2, x1, x1, cd2, cd4, false).replace("M", "L") + shapeArc(x2, x1, x1, x1, c3d4, c3d4 + cd4, false) + shapeArc(x2, y2, x1, x1, 0, cd4, false).replace("M", "L");
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftBracket": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 8333 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let maxAdj = cnstVal1 * h / Math.min(w, h);
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let r = w, b = h, cd2 = 180, cd4 = 90, c3d4 = 270, a, y1, y2;
      if (adj < 0) a = 0;
      else if (adj > maxAdj) a = maxAdj;
      else a = adj;
      y1 = Math.min(w, h) * a / cnstVal2;
      if (y1 > w) y1 = w;
      y2 = b - y1;
      let d = "M" + r + "," + b + shapeArc(y1, y2, y1, y1, cd4, cd2, false).replace("M", "L") + " L0," + y1 + shapeArc(y1, y1, y1, y1, cd2, c3d4, false).replace("M", "L") + " L" + r + ",0";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "rightBracket": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 8333 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let maxAdj = cnstVal1 * h / Math.min(w, h);
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let cd = 360, cd2 = 180, cd4 = 90, c3d4 = 270, a, y1, y2, y3;
      if (adj < 0) a = 0;
      else if (adj > maxAdj) a = maxAdj;
      else a = adj;
      y1 = Math.min(w, h) * a / cnstVal2;
      y2 = h - y1;
      y3 = w - y1;
      let d = "M0," + h + shapeArc(y3, y2, y1, y1, cd4, 0, false).replace("M", "L") + //" L"+ r + "," + y2 +
      " L" + w + "," + h / 2 + shapeArc(y3, y1, y1, y1, cd, c3d4, false).replace("M", "L") + " L0,0";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "moon": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 0.5;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) / 1e5;
      }
      let hd2, cd2, cd4;
      hd2 = h / 2;
      cd2 = 180;
      cd4 = 90;
      let adj2 = (1 - adj) * w;
      let d = "M" + w + "," + h + shapeArc(w, hd2, w, hd2, cd4, cd4 + cd2, false).replace("M", "L") + shapeArc(w, hd2, adj2, hd2, cd4 + cd2, cd4, false).replace("M", "L") + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "corner": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 5e4 * slideFactor;
      let sAdj22, sAdj2_val2 = 5e4 * slideFactor;
      let cnsVal = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj2_val2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let minWH = Math.min(w, h);
      let maxAdj1 = cnsVal * h / minWH;
      let maxAdj2 = cnsVal * w / minWH;
      let a1, a2, x1, dy1, y1;
      if (sAdj1_val2 < 0) a1 = 0;
      else if (sAdj1_val2 > maxAdj1) a1 = maxAdj1;
      else a1 = sAdj1_val2;
      if (sAdj2_val2 < 0) a2 = 0;
      else if (sAdj2_val2 > maxAdj2) a2 = maxAdj2;
      else a2 = sAdj2_val2;
      x1 = minWH * a2 / cnsVal;
      dy1 = minWH * a1 / cnsVal;
      y1 = h - dy1;
      let d = "M0,0 L" + x1 + ",0 L" + x1 + "," + y1 + " L" + w + "," + y1 + " L" + w + "," + h + " L0," + h + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "diagStripe": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let sAdj1_val2 = 5e4 * slideFactor;
      let cnsVal = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        sAdj1_val2 = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a1, x2, y2;
      if (sAdj1_val2 < 0) a1 = 0;
      else if (sAdj1_val2 > cnsVal) a1 = cnsVal;
      else a1 = sAdj1_val2;
      x2 = w * a1 / cnsVal;
      y2 = h * a1 / cnsVal;
      let d = "M0," + y2 + " L" + x2 + ",0 L" + w + ",0 L0," + h + " z";
      result += "<path   d='" + d + "'  fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "gear6":
    case "gear9": {
      let gearNum = shapType.substr(4), d;
      if (gearNum == "6") {
        d = shapeGear(w, h / 3.5, parseInt(gearNum));
      } else {
        d = shapeGear(w, h / 3.5, parseInt(gearNum));
      }
      result += "<path   d='" + d + "' transform='rotate(20," + 3 / 7 * h + "," + 3 / 7 * h + ")' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bentConnector3": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let shapAdjst_val = 0.5;
      if (shapAdjst !== void 0) {
        shapAdjst_val = parseInt(shapAdjst.substr(4)) / 1e5;
        result += " <polyline points='0 0," + shapAdjst_val * w + " 0," + shapAdjst_val * w + " " + h + "," + w + " " + h + "' fill='transparent'' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' ";
        if (markerStart) {
          result += markerStart;
        }
        if (markerEnd) {
          result += markerEnd;
        }
        result += "/>";
      }
      break;
    }
    case "plus": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj1 = 0.25;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) / 1e5;
      }
      let adj2 = 1 - adj1;
      result += " <polygon points='" + adj1 * w + " 0," + adj1 * w + " " + adj1 * h + ",0 " + adj1 * h + ",0 " + adj2 * h + "," + adj1 * w + " " + adj2 * h + "," + adj1 * w + " " + h + "," + adj2 * w + " " + h + "," + adj2 * w + " " + adj2 * h + "," + w + " " + adj2 * h + "," + +w + " " + adj1 * h + "," + adj2 * w + " " + adj1 * h + "," + adj2 * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "teardrop": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj1 = 1e5 * slideFactor;
      let cnsVal1 = adj1;
      let cnsVal2 = 2e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a1, r2, tw, th, sw, sh, dx1, dy1, x1, y1, x2, y2, rd45;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnsVal2) a1 = cnsVal2;
      else a1 = adj1;
      r2 = Math.sqrt(2);
      tw = r2 * (w / 2);
      th = r2 * (h / 2);
      sw = tw * a1 / cnsVal1;
      sh = th * a1 / cnsVal1;
      rd45 = 45 * Math.PI / 180;
      dx1 = sw * Math.cos(rd45);
      dy1 = sh * Math.cos(rd45);
      x1 = w / 2 + dx1;
      y1 = h / 2 - dy1;
      x2 = (w / 2 + x1) / 2;
      y2 = (h / 2 + y1) / 2;
      let d_val = shapeArc(w / 2, h / 2, w / 2, h / 2, 180, 270, false) + "Q " + x2 + ",0 " + x1 + "," + y1 + "Q " + w + "," + y2 + " " + w + "," + h / 2 + shapeArc(w / 2, h / 2, w / 2, h / 2, 0, 90, false).replace("M", "L") + shapeArc(w / 2, h / 2, w / 2, h / 2, 90, 180, false).replace("M", "L") + " z";
      result += "<path   d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "plaque": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj1 = 16667 * slideFactor;
      let cnsVal1 = 5e4 * slideFactor;
      let cnsVal2 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a1, x1, x2, y2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnsVal1) a1 = cnsVal1;
      else a1 = adj1;
      x1 = a1 * Math.min(w, h) / cnsVal2;
      x2 = w - x1;
      y2 = h - x1;
      let d_val = "M0," + x1 + shapeArc(0, 0, x1, x1, 90, 0, false).replace("M", "L") + " L" + x2 + ",0" + shapeArc(w, 0, x1, x1, 180, 90, false).replace("M", "L") + " L" + w + "," + y2 + shapeArc(w, h, x1, x1, 270, 180, false).replace("M", "L") + " L" + x1 + "," + h + shapeArc(0, h, x1, x1, 0, -90, false).replace("M", "L") + " z";
      result += "<path   d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "sun": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj1 = 25e3 * refr;
      let cnstVal1 = 12500 * refr;
      let cnstVal2 = 46875 * refr;
      if (shapAdjst !== void 0) {
        adj1 = parseInt(shapAdjst.substr(4)) * refr;
      }
      let a1;
      if (adj1 < cnstVal1) a1 = cnstVal1;
      else if (adj1 > cnstVal2) a1 = cnstVal2;
      else a1 = adj1;
      let cnstVa3 = 5e4 * refr;
      let cnstVa4 = 1e5 * refr;
      let g0 = cnstVa3 - a1, g1 = g0 * (30274 * refr) / (32768 * refr), g2 = g0 * (12540 * refr) / (32768 * refr), g3 = g1 + cnstVa3, g4 = g2 + cnstVa3, g5 = cnstVa3 - g1, g6 = cnstVa3 - g2, g7 = g0 * (23170 * refr) / (32768 * refr), g8 = cnstVa3 + g7, g9 = cnstVa3 - g7, g10 = g5 * 3 / 4, g11 = g6 * 3 / 4, g12 = g10 + 3662 * refr, g13 = g11 + 36620 * refr, g14 = g11 + 12500 * refr, g15 = cnstVa4 - g10, g16 = cnstVa4 - g12, g17 = cnstVa4 - g13, g18 = cnstVa4 - g14, ox1 = w * (18436 * refr) / (21600 * refr), oy1 = h * (3163 * refr) / (21600 * refr), ox2 = w * (3163 * refr) / (21600 * refr), oy2 = h * (18436 * refr) / (21600 * refr), x8 = w * g8 / cnstVa4, x9 = w * g9 / cnstVa4, x10 = w * g10 / cnstVa4, x12 = w * g12 / cnstVa4, x13 = w * g13 / cnstVa4, x14 = w * g14 / cnstVa4, x15 = w * g15 / cnstVa4, x16 = w * g16 / cnstVa4, x17 = w * g17 / cnstVa4, x18 = w * g18 / cnstVa4, x19 = w * a1 / cnstVa4, wR = w * g0 / cnstVa4, hR = h * g0 / cnstVa4, y8 = h * g8 / cnstVa4, y9 = h * g9 / cnstVa4, y10 = h * g10 / cnstVa4, y12 = h * g12 / cnstVa4, y13 = h * g13 / cnstVa4, y14 = h * g14 / cnstVa4, y15 = h * g15 / cnstVa4, y16 = h * g16 / cnstVa4, y17 = h * g17 / cnstVa4, y18 = h * g18 / cnstVa4;
      let d_val = "M" + w + "," + h / 2 + " L" + x15 + "," + y18 + " L" + x15 + "," + y14 + "z M" + ox1 + "," + oy1 + " L" + x16 + "," + y17 + " L" + x13 + "," + y12 + "z M" + w / 2 + ",0 L" + x18 + "," + y10 + " L" + x14 + "," + y10 + "z M" + ox2 + "," + oy1 + " L" + x17 + "," + y12 + " L" + x12 + "," + y17 + "z M0," + h / 2 + " L" + x10 + "," + y14 + " L" + x10 + "," + y18 + "z M" + ox2 + "," + oy2 + " L" + x12 + "," + y13 + " L" + x17 + "," + y16 + "z M" + w / 2 + "," + h + " L" + x14 + "," + y15 + " L" + x18 + "," + y15 + "z M" + ox1 + "," + oy2 + " L" + x13 + "," + y16 + " L" + x16 + "," + y13 + " z M" + x19 + "," + h / 2 + shapeArc(w / 2, h / 2, wR, hR, 180, 540, false).replace("M", "L") + " z";
      result += "<path   d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "heart": {
      let dx1, dx2, x1, x2, x3, x4, y1;
      dx1 = w * 49 / 48;
      dx2 = w * 10 / 48;
      x1 = w / 2 - dx1;
      x2 = w / 2 - dx2;
      x3 = w / 2 + dx2;
      x4 = w / 2 + dx1;
      y1 = -h / 3;
      let d_val = "M" + w / 2 + "," + h / 4 + "C" + x3 + "," + y1 + " " + x4 + "," + h / 4 + " " + w / 2 + "," + h + "C" + x1 + "," + h / 4 + " " + x2 + "," + y1 + " " + w / 2 + "," + h / 4 + " z";
      result += "<path   d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "lightningBolt": {
      let x1 = w * 5022 / 21600, x2 = w * 11050 / 21600, x3 = w * 8472 / 21600, x4 = w * 8757 / 21600, x5 = w * 10012 / 21600, x6 = w * 14767 / 21600, x7 = w * 12222 / 21600, x8 = w * 12860 / 21600, x9 = w * 13917 / 21600, x10 = w * 7602 / 21600, x11 = w * 16577 / 21600, y1 = h * 3890 / 21600, y2 = h * 6080 / 21600, y3 = h * 6797 / 21600, y4 = h * 7437 / 21600, y5 = h * 12877 / 21600, y6 = h * 9705 / 21600, y7 = h * 12007 / 21600, y8 = h * 13987 / 21600, y9 = h * 8382 / 21600, y10 = h * 14277 / 21600, y11 = h * 14915 / 21600;
      let d_val = "M" + x3 + ",0 L" + x8 + "," + y2 + " L" + x2 + "," + y3 + " L" + x11 + "," + y7 + " L" + x6 + "," + y5 + " L" + w + "," + h + " L" + x5 + "," + y11 + " L" + x7 + "," + y8 + " L" + x1 + "," + y6 + " L" + x10 + "," + y9 + " L0," + y1 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "cube": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj = 25e3 * refr;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * refr;
      }
      let d_val;
      let cnstVal2 = 1e5 * refr;
      let ss = Math.min(w, h);
      let a, y1, y4, x4;
      a = adj < 0 ? 0 : adj > cnstVal2 ? cnstVal2 : adj;
      y1 = ss * a / cnstVal2;
      y4 = h - y1;
      x4 = w - y1;
      d_val = "M0," + y1 + " L" + y1 + ",0 L" + w + ",0 L" + w + "," + y4 + " L" + x4 + "," + h + " L0," + h + " zM0," + y1 + " L" + x4 + "," + y1 + " M" + x4 + "," + y1 + " L" + w + ",0M" + x4 + "," + y1 + " L" + x4 + "," + h;
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bevel": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj = 12500 * refr;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * refr;
      }
      let d_val;
      let cnstVal1 = 5e4 * refr;
      let cnstVal2 = 1e5 * refr;
      let ss = Math.min(w, h);
      let a, x1, x2, y2;
      a = adj < 0 ? 0 : adj > cnstVal1 ? cnstVal1 : adj;
      x1 = ss * a / cnstVal2;
      x2 = w - x1;
      y2 = h - x1;
      d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + x1 + " L" + x2 + "," + x1 + " L" + x2 + "," + y2 + " L" + x1 + "," + y2 + " z M0,0 L" + x1 + "," + x1 + " M0," + h + " L" + x1 + "," + y2 + " M" + w + ",0 L" + x2 + "," + x1 + " M" + w + "," + h + " L" + x2 + "," + y2;
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "foldedCorner": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj = 16667 * refr;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * refr;
      }
      let d_val;
      let cnstVal1 = 5e4 * refr;
      let cnstVal2 = 1e5 * refr;
      let ss = Math.min(w, h);
      let a, dy2, dy1, x1, x2, y2, y1;
      a = adj < 0 ? 0 : adj > cnstVal1 ? cnstVal1 : adj;
      dy2 = ss * a / cnstVal2;
      dy1 = dy2 / 5;
      x1 = w - dy2;
      x2 = x1 + dy1;
      y2 = h - dy2;
      y1 = y2 + dy1;
      d_val = "M" + x1 + "," + h + " L" + x2 + "," + y1 + " L" + w + "," + y2 + " L" + x1 + "," + h + " L0," + h + " L0,0 L" + w + ",0 L" + w + "," + y2;
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "cloud":
    case "cloudCallout": {
      let x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, rx1, rx2, rx3, rx4, rx5, rx6, rx7, rx8, rx9, rx10, rx11, ry1, ry2, ry3, ry4, ry5, ry6, ry7, ry8, ry9, ry10, ry11;
      x0 = w * 3900 / 43200;
      ;
      x1 = w * 4693 / 43200;
      x2 = w * 6928 / 43200;
      x3 = w * 16478 / 43200;
      x4 = w * 28827 / 43200;
      x5 = w * 34129 / 43200;
      x6 = w * 41798 / 43200;
      x7 = w * 38324 / 43200;
      x8 = w * 29078 / 43200;
      x9 = w * 22141 / 43200;
      x10 = w * 14e3 / 43200;
      x11 = w * 4127 / 43200;
      y0 = h * 14370 / 43200;
      y1 = h * 26177 / 43200;
      y2 = h * 34899 / 43200;
      y3 = h * 39090 / 43200;
      y4 = h * 34751 / 43200;
      y5 = h * 22954 / 43200;
      y6 = h * 15354 / 43200;
      y7 = h * 5426 / 43200;
      y8 = h * 3952 / 43200;
      y9 = h * 4720 / 43200;
      y10 = h * 5192 / 43200;
      y11 = h * 15789 / 43200;
      let rX1 = w * 6753 / 43200, rY1 = h * 9190 / 43200, rX2 = w * 5333 / 43200, rY2 = h * 7267 / 43200, rX3 = w * 4365 / 43200, rY3 = h * 5945 / 43200, rX4 = w * 4857 / 43200, rY4 = h * 6595 / 43200, rY5 = h * 7273 / 43200, rX6 = w * 6775 / 43200, rY6 = h * 9220 / 43200, rX7 = w * 5785 / 43200, rY7 = h * 7867 / 43200, rX8 = w * 6752 / 43200, rY8 = h * 9215 / 43200, rX9 = w * 7720 / 43200, rY9 = h * 10543 / 43200, rX10 = w * 4360 / 43200, rY10 = h * 5918 / 43200, rX11 = w * 4345 / 43200;
      let sA1 = -11429249 / 6e4, wA1 = 7426832 / 6e4, sA2 = -8646143 / 6e4, wA2 = 5396714 / 6e4, sA3 = -8748475 / 6e4, wA3 = 5983381 / 6e4, sA4 = -7859164 / 6e4, wA4 = 7034504 / 6e4, sA5 = -4722533 / 6e4, wA5 = 6541615 / 6e4, sA6 = -2776035 / 6e4, wA6 = 7816140 / 6e4, sA7 = 37501 / 6e4, wA7 = 6842e3 / 6e4, sA8 = 1347096 / 6e4, wA8 = 6910353 / 6e4, sA9 = 3974558 / 6e4, wA9 = 4542661 / 6e4, sA10 = -16496525 / 6e4, wA10 = 8804134 / 6e4, sA11 = -14809710 / 6e4, wA11 = 9151131 / 6e4;
      let cX0, cX1, cX2, cX3, cX4, cX5, cX6, cX7, cX8, cX9, cX10, cY0, cY1, cY2, cY3, cY4, cY5, cY6, cY7, cY8, cY9, cY10;
      let arc1, arc2, arc3, arc4, arc5, arc6, arc7, arc8, arc9, arc10, arc11;
      let lxy1, lxy2, lxy3, lxy4, lxy5, lxy6, lxy7, lxy8, lxy9, lxy10;
      cX0 = x0 - rX1 * Math.cos(sA1 * Math.PI / 180);
      cY0 = y0 - rY1 * Math.sin(sA1 * Math.PI / 180);
      arc1 = shapeArc(cX0, cY0, rX1, rY1, sA1, sA1 + wA1, false).replace("M", "L");
      lxy1 = arc1.substr(arc1.lastIndexOf("L") + 1).split(" ");
      cX1 = parseInt(lxy1[0]) - rX2 * Math.cos(sA2 * Math.PI / 180);
      cY1 = parseInt(lxy1[1]) - rY2 * Math.sin(sA2 * Math.PI / 180);
      arc2 = shapeArc(cX1, cY1, rX2, rY2, sA2, sA2 + wA2, false).replace("M", "L");
      lxy2 = arc2.substr(arc2.lastIndexOf("L") + 1).split(" ");
      cX2 = parseInt(lxy2[0]) - rX3 * Math.cos(sA3 * Math.PI / 180);
      cY2 = parseInt(lxy2[1]) - rY3 * Math.sin(sA3 * Math.PI / 180);
      arc3 = shapeArc(cX2, cY2, rX3, rY3, sA3, sA3 + wA3, false).replace("M", "L");
      lxy3 = arc3.substr(arc3.lastIndexOf("L") + 1).split(" ");
      cX3 = parseInt(lxy3[0]) - rX4 * Math.cos(sA4 * Math.PI / 180);
      cY3 = parseInt(lxy3[1]) - rY4 * Math.sin(sA4 * Math.PI / 180);
      arc4 = shapeArc(cX3, cY3, rX4, rY4, sA4, sA4 + wA4, false).replace("M", "L");
      lxy4 = arc4.substr(arc4.lastIndexOf("L") + 1).split(" ");
      cX4 = parseInt(lxy4[0]) - rX2 * Math.cos(sA5 * Math.PI / 180);
      cY4 = parseInt(lxy4[1]) - rY5 * Math.sin(sA5 * Math.PI / 180);
      arc5 = shapeArc(cX4, cY4, rX2, rY5, sA5, sA5 + wA5, false).replace("M", "L");
      lxy5 = arc5.substr(arc5.lastIndexOf("L") + 1).split(" ");
      cX5 = parseInt(lxy5[0]) - rX6 * Math.cos(sA6 * Math.PI / 180);
      cY5 = parseInt(lxy5[1]) - rY6 * Math.sin(sA6 * Math.PI / 180);
      arc6 = shapeArc(cX5, cY5, rX6, rY6, sA6, sA6 + wA6, false).replace("M", "L");
      lxy6 = arc6.substr(arc6.lastIndexOf("L") + 1).split(" ");
      cX6 = parseInt(lxy6[0]) - rX7 * Math.cos(sA7 * Math.PI / 180);
      cY6 = parseInt(lxy6[1]) - rY7 * Math.sin(sA7 * Math.PI / 180);
      arc7 = shapeArc(cX6, cY6, rX7, rY7, sA7, sA7 + wA7, false).replace("M", "L");
      lxy7 = arc7.substr(arc7.lastIndexOf("L") + 1).split(" ");
      cX7 = parseInt(lxy7[0]) - rX8 * Math.cos(sA8 * Math.PI / 180);
      cY7 = parseInt(lxy7[1]) - rY8 * Math.sin(sA8 * Math.PI / 180);
      arc8 = shapeArc(cX7, cY7, rX8, rY8, sA8, sA8 + wA8, false).replace("M", "L");
      lxy8 = arc8.substr(arc8.lastIndexOf("L") + 1).split(" ");
      cX8 = parseInt(lxy8[0]) - rX9 * Math.cos(sA9 * Math.PI / 180);
      cY8 = parseInt(lxy8[1]) - rY9 * Math.sin(sA9 * Math.PI / 180);
      arc9 = shapeArc(cX8, cY8, rX9, rY9, sA9, sA9 + wA9, false).replace("M", "L");
      lxy9 = arc9.substr(arc9.lastIndexOf("L") + 1).split(" ");
      cX9 = parseInt(lxy9[0]) - rX10 * Math.cos(sA10 * Math.PI / 180);
      cY9 = parseInt(lxy9[1]) - rY10 * Math.sin(sA10 * Math.PI / 180);
      arc10 = shapeArc(cX9, cY9, rX10, rY10, sA10, sA10 + wA10, false).replace("M", "L");
      lxy10 = arc10.substr(arc10.lastIndexOf("L") + 1).split(" ");
      cX10 = parseInt(lxy10[0]) - rX11 * Math.cos(sA11 * Math.PI / 180);
      cY10 = parseInt(lxy10[1]) - rY3 * Math.sin(sA11 * Math.PI / 180);
      arc11 = shapeArc(cX10, cY10, rX11, rY3, sA11, sA11 + wA11, false).replace("M", "L");
      let d1 = "M" + x0 + "," + y0 + arc1 + arc2 + arc3 + arc4 + arc5 + arc6 + arc7 + arc8 + arc9 + arc10 + arc11 + " z";
      if (shapType == "cloudCallout") {
        let shapAdjst_ary2 = shapAdjstArr;
        let refr = slideFactor;
        let sAdj12, adj1 = -20833 * refr;
        let sAdj22, adj2 = 62500 * refr;
        if (shapAdjst_ary2 !== void 0) {
          for (var i = 0; i < shapAdjst_ary2.length; i++) {
            let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
            if (sAdj_name == "adj1") {
              sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
              adj1 = parseInt(sAdj12.substr(4)) * refr;
            } else if (sAdj_name == "adj2") {
              sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
              adj2 = parseInt(sAdj22.substr(4)) * refr;
            }
          }
        }
        let d_val;
        let cnstVal2 = 1e5 * refr;
        let ss = Math.min(w, h);
        let wd2 = w / 2, hd2 = h / 2;
        let dxPos, dyPos, xPos, yPos, ht, wt, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, g22, g23, g24, g25, g26, x23, x24, x25;
        dxPos = w * adj1 / cnstVal2;
        dyPos = h * adj2 / cnstVal2;
        xPos = wd2 + dxPos;
        yPos = hd2 + dyPos;
        ht = hd2 * Math.cos(Math.atan(dyPos / dxPos));
        wt = wd2 * Math.sin(Math.atan(dyPos / dxPos));
        g2 = wd2 * Math.cos(Math.atan(wt / ht));
        g3 = hd2 * Math.sin(Math.atan(wt / ht));
        if (adj1 >= 0) {
          g4 = wd2 + g2;
          g5 = hd2 + g3;
        } else {
          g4 = wd2 - g2;
          g5 = hd2 - g3;
        }
        g6 = g4 - xPos;
        g7 = g5 - yPos;
        g8 = Math.sqrt(g6 * g6 + g7 * g7);
        g9 = ss * 6600 / 21600;
        g10 = g8 - g9;
        g11 = g10 / 3;
        g12 = ss * 1800 / 21600;
        g13 = g11 + g12;
        g14 = g13 * g6 / g8;
        g15 = g13 * g7 / g8;
        g16 = g14 + xPos;
        g17 = g15 + yPos;
        g18 = ss * 4800 / 21600;
        g19 = g11 * 2;
        g20 = g18 + g19;
        g21 = g20 * g6 / g8;
        g22 = g20 * g7 / g8;
        g23 = g21 + xPos;
        g24 = g22 + yPos;
        g25 = ss * 1200 / 21600;
        g26 = ss * 600 / 21600;
        x23 = xPos + g26;
        x24 = g16 + g25;
        x25 = g23 + g12;
        d_val = //" M" + x23 + "," + yPos + 
        shapeArc(x23 - g26, yPos, g26, g26, 0, 360, false) + //.replace("M","L") +
        " z M" + x24 + "," + g17 + shapeArc(x24 - g25, g17, g25, g25, 0, 360, false).replace("M", "L") + " z M" + x25 + "," + g24 + shapeArc(x25 - g12, g24, g12, g12, 0, 360, false).replace("M", "L") + " z";
        d1 += d_val;
      }
      result += "<path d='" + d1 + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "smileyFace": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj = 4653 * refr;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * refr;
      }
      let d_val;
      let cnstVal1 = 5e4 * refr;
      let cnstVal2 = 1e5 * refr;
      let cnstVal3 = 4653 * refr;
      let ss = Math.min(w, h);
      let a, x1, x2, x3, x4, y1, y3, dy2, y2, y4, dy3, y5, wR, hR, wd2, hd2;
      wd2 = w / 2;
      hd2 = h / 2;
      a = adj < -cnstVal3 ? -cnstVal3 : adj > cnstVal3 ? cnstVal3 : adj;
      x1 = w * 4969 / 21699;
      x2 = w * 6215 / 21600;
      x3 = w * 13135 / 21600;
      x4 = w * 16640 / 21600;
      y1 = h * 7570 / 21600;
      y3 = h * 16515 / 21600;
      dy2 = h * a / cnstVal2;
      y2 = y3 - dy2;
      y4 = y3 + dy2;
      dy3 = h * a / cnstVal1;
      y5 = y4 + dy3;
      wR = w * 1125 / 21600;
      hR = h * 1125 / 21600;
      let cX1 = x2 - wR * Math.cos(Math.PI);
      let cY1 = y1 - hR * Math.sin(Math.PI);
      let cX2 = x3 - wR * Math.cos(Math.PI);
      d_val = //eyes
      shapeArc(cX1, cY1, wR, hR, 180, 540, false) + shapeArc(cX2, cY1, wR, hR, 180, 540, false) + //mouth
      " M" + x1 + "," + y2 + " Q" + wd2 + "," + y5 + " " + x4 + "," + y2 + " Q" + wd2 + "," + y5 + " " + x1 + "," + y2 + //head
      " M0," + hd2 + shapeArc(wd2, hd2, wd2, hd2, 180, 540, false).replace("M", "L") + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "verticalScroll":
    case "horizontalScroll": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let refr = slideFactor;
      let adj = 12500 * refr;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * refr;
      }
      let d_val;
      let cnstVal1 = 25e3 * refr;
      let cnstVal2 = 1e5 * refr;
      let ss = Math.min(w, h);
      let t = 0, l = 0, b = h, r = w;
      let a, ch, ch2, ch4;
      a = adj < 0 ? 0 : adj > cnstVal1 ? cnstVal1 : adj;
      ch = ss * a / cnstVal2;
      ch2 = ch / 2;
      ch4 = ch / 4;
      if (shapType == "verticalScroll") {
        let x3, x4, x6, x7, x5, y3, y4;
        x3 = ch + ch2;
        x4 = ch + ch;
        x6 = r - ch;
        x7 = r - ch2;
        x5 = x6 - ch2;
        y3 = b - ch;
        y4 = b - ch2;
        d_val = "M" + ch + "," + y3 + " L" + ch + "," + ch2 + shapeArc(x3, ch2, ch2, ch2, 180, 270, false).replace("M", "L") + " L" + x7 + "," + t + shapeArc(x7, ch2, ch2, ch2, 270, 450, false).replace("M", "L") + " L" + x6 + "," + ch + " L" + x6 + "," + y4 + shapeArc(x5, y4, ch2, ch2, 0, 90, false).replace("M", "L") + " L" + ch2 + "," + b + shapeArc(ch2, y4, ch2, ch2, 90, 270, false).replace("M", "L") + " z M" + x3 + "," + t + shapeArc(x3, ch2, ch2, ch2, 270, 450, false).replace("M", "L") + shapeArc(x3, x3 / 2, ch4, ch4, 90, 270, false).replace("M", "L") + " L" + x4 + "," + ch2 + " M" + x6 + "," + ch + " L" + x3 + "," + ch + " M" + ch + "," + y4 + shapeArc(ch2, y4, ch2, ch2, 0, 270, false).replace("M", "L") + shapeArc(ch2, (y4 + y3) / 2, ch4, ch4, 270, 450, false).replace("M", "L") + " z M" + ch + "," + y4 + " L" + ch + "," + y3;
      } else if (shapType == "horizontalScroll") {
        let y3, y4, y6, y7, y5, x3, x4;
        y3 = ch + ch2;
        y4 = ch + ch;
        y6 = b - ch;
        y7 = b - ch2;
        y5 = y6 - ch2;
        x3 = r - ch;
        x4 = r - ch2;
        d_val = "M" + l + "," + y3 + shapeArc(ch2, y3, ch2, ch2, 180, 270, false).replace("M", "L") + " L" + x3 + "," + ch + " L" + x3 + "," + ch2 + shapeArc(x4, ch2, ch2, ch2, 180, 360, false).replace("M", "L") + " L" + r + "," + y5 + shapeArc(x4, y5, ch2, ch2, 0, 90, false).replace("M", "L") + " L" + ch + "," + y6 + " L" + ch + "," + y7 + shapeArc(ch2, y7, ch2, ch2, 0, 180, false).replace("M", "L") + " zM" + x4 + "," + ch + shapeArc(x4, ch2, ch2, ch2, 90, -180, false).replace("M", "L") + shapeArc((x3 + x4) / 2, ch2, ch4, ch4, 180, 0, false).replace("M", "L") + " z M" + x4 + "," + ch + " L" + x3 + "," + ch + " M" + ch2 + "," + y4 + " L" + ch2 + "," + y3 + shapeArc(y3 / 2, y3, ch4, ch4, 180, 360, false).replace("M", "L") + shapeArc(ch2, y3, ch2, ch2, 0, 180, false).replace("M", "L") + " M" + ch + "," + y3 + " L" + ch + "," + y6;
      }
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "wedgeEllipseCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = -20833 * refr;
      let sAdj22, adj2 = 62500 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          }
        }
      }
      let d_val;
      let cnstVal1 = 1e5 * slideFactor;
      let angVal1 = 11 * Math.PI / 180;
      let ss = Math.min(w, h);
      let dxPos, dyPos, xPos, yPos, sdx, sdy, pang, stAng, enAng, dx1, dy1, x1, y1, dx2, dy2, x2, y2, stAng1, enAng1, swAng1, swAng2, swAng, vc = h / 2, hc = w / 2;
      dxPos = w * adj1 / cnstVal1;
      dyPos = h * adj2 / cnstVal1;
      xPos = hc + dxPos;
      yPos = vc + dyPos;
      sdx = dxPos * h;
      sdy = dyPos * w;
      pang = Math.atan(sdy / sdx);
      stAng = pang + angVal1;
      enAng = pang - angVal1;
      console.log("dxPos: ", dxPos, "dyPos: ", dyPos);
      dx1 = hc * Math.cos(stAng);
      dy1 = vc * Math.sin(stAng);
      dx2 = hc * Math.cos(enAng);
      dy2 = vc * Math.sin(enAng);
      if (dxPos >= 0) {
        x1 = hc + dx1;
        y1 = vc + dy1;
        x2 = hc + dx2;
        y2 = vc + dy2;
      } else {
        x1 = hc - dx1;
        y1 = vc - dy1;
        x2 = hc - dx2;
        y2 = vc - dy2;
      }
      d_val = "M" + x1 + "," + y1 + " L" + xPos + "," + yPos + " L" + x2 + "," + y2 + //" z" +
      shapeArc(hc, vc, hc, vc, 0, 360, true);
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "wedgeRectCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = -20833 * refr;
      let sAdj22, adj2 = 62500 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          }
        }
      }
      let d_val;
      let cnstVal1 = 1e5 * slideFactor;
      let dxPos, dyPos, xPos, yPos, dx, dy, dq, ady, adq, dz, xg1, xg2, x1, x2, yg1, yg2, y1, y2, t1, xl, t2, xt, t3, xr, t4, xb, t5, yl, t6, yt, t7, yr, t8, yb, vc = h / 2, hc = w / 2;
      dxPos = w * adj1 / cnstVal1;
      dyPos = h * adj2 / cnstVal1;
      xPos = hc + dxPos;
      yPos = vc + dyPos;
      dx = xPos - hc;
      dy = yPos - vc;
      dq = dxPos * h / w;
      ady = Math.abs(dyPos);
      adq = Math.abs(dq);
      dz = ady - adq;
      xg1 = dxPos > 0 ? 7 : 2;
      xg2 = dxPos > 0 ? 10 : 5;
      x1 = w * xg1 / 12;
      x2 = w * xg2 / 12;
      yg1 = dyPos > 0 ? 7 : 2;
      yg2 = dyPos > 0 ? 10 : 5;
      y1 = h * yg1 / 12;
      y2 = h * yg2 / 12;
      t1 = dxPos > 0 ? 0 : xPos;
      xl = dz > 0 ? 0 : t1;
      t2 = dyPos > 0 ? x1 : xPos;
      xt = dz > 0 ? t2 : x1;
      t3 = dxPos > 0 ? xPos : w;
      xr = dz > 0 ? w : t3;
      t4 = dyPos > 0 ? xPos : x1;
      xb = dz > 0 ? t4 : x1;
      t5 = dxPos > 0 ? y1 : yPos;
      yl = dz > 0 ? y1 : t5;
      t6 = dyPos > 0 ? 0 : yPos;
      yt = dz > 0 ? t6 : 0;
      t7 = dxPos > 0 ? yPos : y1;
      yr = dz > 0 ? y1 : t7;
      t8 = dyPos > 0 ? yPos : h;
      yb = dz > 0 ? t8 : h;
      d_val = "M0,0 L" + x1 + ",0 L" + xt + "," + yt + " L" + x2 + ",0 L" + w + ",0 L" + w + "," + y1 + " L" + xr + "," + yr + " L" + w + "," + y2 + " L" + w + "," + h + " L" + x2 + "," + h + " L" + xb + "," + yb + " L" + x1 + "," + h + " L0," + h + " L0," + y2 + " L" + xl + "," + yl + " L0," + y1 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "wedgeRoundRectCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = -20833 * refr;
      let sAdj22, adj2 = 62500 * refr;
      let sAdj3, adj3 = 16667 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * refr;
          }
        }
      }
      let d_val;
      let cnstVal1 = 1e5 * slideFactor;
      let ss = Math.min(w, h);
      let dxPos, dyPos, xPos, yPos, dq, ady, adq, dz, xg1, xg2, x1, x2, yg1, yg2, y1, y2, t1, xl, t2, xt, t3, xr, t4, xb, t5, yl, t6, yt, t7, yr, t8, yb, u1, u2, v2, vc = h / 2, hc = w / 2;
      dxPos = w * adj1 / cnstVal1;
      dyPos = h * adj2 / cnstVal1;
      xPos = hc + dxPos;
      yPos = vc + dyPos;
      dq = dxPos * h / w;
      ady = Math.abs(dyPos);
      adq = Math.abs(dq);
      dz = ady - adq;
      xg1 = dxPos > 0 ? 7 : 2;
      xg2 = dxPos > 0 ? 10 : 5;
      x1 = w * xg1 / 12;
      x2 = w * xg2 / 12;
      yg1 = dyPos > 0 ? 7 : 2;
      yg2 = dyPos > 0 ? 10 : 5;
      y1 = h * yg1 / 12;
      y2 = h * yg2 / 12;
      t1 = dxPos > 0 ? 0 : xPos;
      xl = dz > 0 ? 0 : t1;
      t2 = dyPos > 0 ? x1 : xPos;
      xt = dz > 0 ? t2 : x1;
      t3 = dxPos > 0 ? xPos : w;
      xr = dz > 0 ? w : t3;
      t4 = dyPos > 0 ? xPos : x1;
      xb = dz > 0 ? t4 : x1;
      t5 = dxPos > 0 ? y1 : yPos;
      yl = dz > 0 ? y1 : t5;
      t6 = dyPos > 0 ? 0 : yPos;
      yt = dz > 0 ? t6 : 0;
      t7 = dxPos > 0 ? yPos : y1;
      yr = dz > 0 ? y1 : t7;
      t8 = dyPos > 0 ? yPos : h;
      yb = dz > 0 ? t8 : h;
      u1 = ss * adj3 / cnstVal1;
      u2 = w - u1;
      v2 = h - u1;
      d_val = "M0," + u1 + shapeArc(u1, u1, u1, u1, 180, 270, false).replace("M", "L") + " L" + x1 + ",0 L" + xt + "," + yt + " L" + x2 + ",0 L" + u2 + ",0" + shapeArc(u2, u1, u1, u1, 270, 360, false).replace("M", "L") + " L" + w + "," + y1 + " L" + xr + "," + yr + " L" + w + "," + y2 + " L" + w + "," + v2 + shapeArc(u2, v2, u1, u1, 0, 90, false).replace("M", "L") + " L" + x2 + "," + h + " L" + xb + "," + yb + " L" + x1 + "," + h + " L" + u1 + "," + h + shapeArc(u1, v2, u1, u1, 90, 180, false).replace("M", "L") + " L0," + y2 + " L" + xl + "," + yl + " L0," + y1 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "accentBorderCallout1":
    case "accentBorderCallout2":
    case "accentBorderCallout3":
    case "borderCallout1":
    case "borderCallout2":
    case "borderCallout3":
    case "accentCallout1":
    case "accentCallout2":
    case "accentCallout3":
    case "callout1":
    case "callout2":
    case "callout3": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = 18750 * refr;
      let sAdj22, adj2 = -8333 * refr;
      let sAdj3, adj3 = 18750 * refr;
      let sAdj4, adj4 = -16667 * refr;
      let sAdj5, adj5 = 1e5 * refr;
      let sAdj6, adj6 = -16667 * refr;
      let sAdj7, adj7 = 112963 * refr;
      let sAdj8, adj8 = -8333 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * refr;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * refr;
          } else if (sAdj_name == "adj5") {
            sAdj5 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj5 = parseInt(sAdj5.substr(4)) * refr;
          } else if (sAdj_name == "adj6") {
            sAdj6 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj6 = parseInt(sAdj6.substr(4)) * refr;
          } else if (sAdj_name == "adj7") {
            sAdj7 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj7 = parseInt(sAdj7.substr(4)) * refr;
          } else if (sAdj_name == "adj8") {
            sAdj8 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj8 = parseInt(sAdj8.substr(4)) * refr;
          }
        }
      }
      let d_val;
      let cnstVal1 = 1e5 * refr;
      let isBorder = true;
      switch (shapType) {
        case "borderCallout1":
        case "callout1": {
          if (shapType == "borderCallout1") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 112500 * refr;
            adj4 = -38333 * refr;
          }
          let y1, x1, y2, x2;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2;
          break;
        }
        case "borderCallout2":
        case "callout2": {
          if (shapType == "borderCallout2") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 18750 * refr;
            adj4 = -16667 * refr;
            adj5 = 112500 * refr;
            adj6 = -46667 * refr;
          }
          let y1, x1, y2, x2, y3, x3;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          y3 = h * adj5 / cnstVal1;
          x3 = w * adj6 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2 + " L" + x3 + "," + y3 + " L" + x2 + "," + y2;
          break;
        }
        case "borderCallout3":
        case "callout3": {
          if (shapType == "borderCallout3") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 18750 * refr;
            adj4 = -16667 * refr;
            adj5 = 1e5 * refr;
            adj6 = -16667 * refr;
            adj7 = 112963 * refr;
            adj8 = -8333 * refr;
          }
          let y1, x1, y2, x2, y3, x3, y4, x4;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          y3 = h * adj5 / cnstVal1;
          x3 = w * adj6 / cnstVal1;
          y4 = h * adj7 / cnstVal1;
          x4 = w * adj8 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2 + " L" + x3 + "," + y3 + " L" + x4 + "," + y4 + " L" + x3 + "," + y3 + " L" + x2 + "," + y2;
          break;
        }
        case "accentBorderCallout1":
        case "accentCallout1": {
          if (shapType == "accentBorderCallout1") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 112500 * refr;
            adj4 = -38333 * refr;
          }
          let y1, x1, y2, x2;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2 + " M" + x1 + ",0 L" + x1 + "," + h;
          break;
        }
        case "accentBorderCallout2":
        case "accentCallout2": {
          if (shapType == "accentBorderCallout2") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 18750 * refr;
            adj4 = -16667 * refr;
            adj5 = 112500 * refr;
            adj6 = -46667 * refr;
          }
          let y1, x1, y2, x2, y3, x3;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          y3 = h * adj5 / cnstVal1;
          x3 = w * adj6 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2 + " L" + x3 + "," + y3 + " L" + x2 + "," + y2 + " M" + x1 + ",0 L" + x1 + "," + h;
          break;
        }
        case "accentBorderCallout3":
        case "accentCallout3": {
          if (shapType == "accentBorderCallout3") {
            isBorder = true;
          } else {
            isBorder = false;
          }
          isBorder = true;
          if (shapAdjst_ary2 === void 0) {
            adj1 = 18750 * refr;
            adj2 = -8333 * refr;
            adj3 = 18750 * refr;
            adj4 = -16667 * refr;
            adj5 = 1e5 * refr;
            adj6 = -16667 * refr;
            adj7 = 112963 * refr;
            adj8 = -8333 * refr;
          }
          let y1, x1, y2, x2, y3, x3, y4, x4;
          y1 = h * adj1 / cnstVal1;
          x1 = w * adj2 / cnstVal1;
          y2 = h * adj3 / cnstVal1;
          x2 = w * adj4 / cnstVal1;
          y3 = h * adj5 / cnstVal1;
          x3 = w * adj6 / cnstVal1;
          y4 = h * adj7 / cnstVal1;
          x4 = w * adj8 / cnstVal1;
          d_val = "M0,0 L" + w + ",0 L" + w + "," + h + " L0," + h + " z M" + x1 + "," + y1 + " L" + x2 + "," + y2 + " L" + x3 + "," + y3 + " L" + x4 + "," + y4 + " L" + x3 + "," + y3 + " L" + x2 + "," + y2 + " M" + x1 + ",0 L" + x1 + "," + h;
          break;
        }
      }
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftRightRibbon": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = 5e4 * refr;
      let sAdj22, adj2 = 5e4 * refr;
      let sAdj3, adj3 = 16667 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * refr;
          }
        }
      }
      let d_val;
      let cnstVal1 = 33333 * refr;
      let cnstVal2 = 1e5 * refr;
      let cnstVal3 = 2e5 * refr;
      let cnstVal4 = 4e5 * refr;
      let ss = Math.min(w, h);
      let a3, maxAdj1, a1, w1, maxAdj2, a2, x1, x4, dy1, dy2, ly1, ry4, ly2, ry3, ly4, ry1, ly3, ry2, hR, x2, x3, y1, y2, wd32 = w / 32, vc = h / 2, hc = w / 2;
      a3 = adj3 < 0 ? 0 : adj3 > cnstVal1 ? cnstVal1 : adj3;
      maxAdj1 = cnstVal2 - a3;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      w1 = hc - wd32;
      maxAdj2 = cnstVal2 * w1 / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      x1 = ss * a2 / cnstVal2;
      x4 = w - x1;
      dy1 = h * a1 / cnstVal3;
      dy2 = h * a3 / -cnstVal3;
      ly1 = vc + dy2 - dy1;
      ry4 = vc + dy1 - dy2;
      ly2 = ly1 + dy1;
      ry3 = h - ly2;
      ly4 = ly2 * 2;
      ry1 = h - ly4;
      ly3 = ly4 - ly1;
      ry2 = h - ly3;
      hR = a3 * ss / cnstVal4;
      x2 = hc - wd32;
      x3 = hc + wd32;
      y1 = ly1 + hR;
      y2 = ry2 - hR;
      d_val = "M0," + ly2 + "L" + x1 + ",0L" + x1 + "," + ly1 + "L" + hc + "," + ly1 + shapeArc(hc, y1, wd32, hR, 270, 450, false).replace("M", "L") + shapeArc(hc, y2, wd32, hR, 270, 90, false).replace("M", "L") + "L" + x4 + "," + ry2 + "L" + x4 + "," + ry1 + "L" + w + "," + ry3 + "L" + x4 + "," + h + "L" + x4 + "," + ry4 + "L" + hc + "," + ry4 + shapeArc(hc, ry4 - hR, wd32, hR, 90, 180, false).replace("M", "L") + "L" + x2 + "," + ly3 + "L" + x1 + "," + ly3 + "L" + x1 + "," + ly4 + " zM" + x3 + "," + y1 + "L" + x3 + "," + ry2 + "M" + x2 + "," + y2 + "L" + x2 + "," + ly3;
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "ribbon":
    case "ribbon2": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 16667 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let d_val;
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal2 = 33333 * slideFactor;
      let cnstVal3 = 75e3 * slideFactor;
      let cnstVal4 = 1e5 * slideFactor;
      let cnstVal5 = 2e5 * slideFactor;
      let cnstVal6 = 4e5 * slideFactor;
      let hc = w / 2, t = 0, l = 0, b = h, r = w, wd8 = w / 8, wd32 = w / 32;
      let a1, a2, x10, dx2, x2, x9, x3, x8, x5, x6, x4, x7, y1, y2, y4, y3, hR, y6;
      a1 = adj1 < 0 ? 0 : adj1 > cnstVal2 ? cnstVal2 : adj1;
      a2 = adj2 < cnstVal1 ? cnstVal1 : adj2 > cnstVal3 ? cnstVal3 : adj2;
      x10 = r - wd8;
      dx2 = w * a2 / cnstVal5;
      x2 = hc - dx2;
      x9 = hc + dx2;
      x3 = x2 + wd32;
      x8 = x9 - wd32;
      x5 = x2 + wd8;
      x6 = x9 - wd8;
      x4 = x5 - wd32;
      x7 = x6 + wd32;
      hR = h * a1 / cnstVal6;
      if (shapType == "ribbon2") {
        let dy1, dy2, y7;
        dy1 = h * a1 / cnstVal5;
        y1 = b - dy1;
        dy2 = h * a1 / cnstVal4;
        y2 = b - dy2;
        y4 = t + dy2;
        y3 = (y4 + b) / 2;
        y6 = b - hR;
        y7 = y1 - hR;
        d_val = "M" + l + "," + b + " L" + wd8 + "," + y3 + " L" + l + "," + y4 + " L" + x2 + "," + y4 + " L" + x2 + "," + hR + shapeArc(x3, hR, wd32, hR, 180, 270, false).replace("M", "L") + " L" + x8 + "," + t + shapeArc(x8, hR, wd32, hR, 270, 360, false).replace("M", "L") + " L" + x9 + "," + y4 + " L" + x9 + "," + y4 + " L" + r + "," + y4 + " L" + x10 + "," + y3 + " L" + r + "," + b + " L" + x7 + "," + b + shapeArc(x7, y6, wd32, hR, 90, 270, false).replace("M", "L") + " L" + x8 + "," + y1 + shapeArc(x8, y7, wd32, hR, 90, -90, false).replace("M", "L") + " L" + x3 + "," + y2 + shapeArc(x3, y7, wd32, hR, 270, 90, false).replace("M", "L") + " L" + x4 + "," + y1 + shapeArc(x4, y6, wd32, hR, 270, 450, false).replace("M", "L") + " z M" + x5 + "," + y2 + " L" + x5 + "," + y6 + "M" + x6 + "," + y6 + " L" + x6 + "," + y2 + "M" + x2 + "," + y7 + " L" + x2 + "," + y4 + "M" + x9 + "," + y4 + " L" + x9 + "," + y7;
      } else if (shapType == "ribbon") {
        let y5;
        y1 = h * a1 / cnstVal5;
        y2 = h * a1 / cnstVal4;
        y4 = b - y2;
        y3 = y4 / 2;
        y5 = b - hR;
        y6 = y2 - hR;
        d_val = "M" + l + "," + t + " L" + x4 + "," + t + shapeArc(x4, hR, wd32, hR, 270, 450, false).replace("M", "L") + " L" + x3 + "," + y1 + shapeArc(x3, y6, wd32, hR, 270, 90, false).replace("M", "L") + " L" + x8 + "," + y2 + shapeArc(x8, y6, wd32, hR, 90, -90, false).replace("M", "L") + " L" + x7 + "," + y1 + shapeArc(x7, hR, wd32, hR, 90, 270, false).replace("M", "L") + " L" + r + "," + t + " L" + x10 + "," + y3 + " L" + r + "," + y4 + " L" + x9 + "," + y4 + " L" + x9 + "," + y5 + shapeArc(x8, y5, wd32, hR, 0, 90, false).replace("M", "L") + " L" + x3 + "," + b + shapeArc(x3, y5, wd32, hR, 90, 180, false).replace("M", "L") + " L" + x2 + "," + y4 + " L" + l + "," + y4 + " L" + wd8 + "," + y3 + " z M" + x5 + "," + hR + " L" + x5 + "," + y2 + "M" + x6 + "," + y2 + " L" + x6 + "," + hR + "M" + x2 + "," + y4 + " L" + x2 + "," + y6 + "M" + x9 + "," + y6 + " L" + x9 + "," + y4;
      }
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "doubleWave":
    case "wave": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = shapType == "doubleWave" ? 6250 * slideFactor : 12500 * slideFactor;
      let sAdj22, adj2 = 0;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let d_val;
      let cnstVal2 = -1e4 * slideFactor;
      let cnstVal3 = 5e4 * slideFactor;
      let cnstVal4 = 1e5 * slideFactor;
      let hc = w / 2, t = 0, l = 0, b = h, r = w, wd8 = w / 8, wd32 = w / 32;
      if (shapType == "doubleWave") {
        let cnstVal1 = 12500 * slideFactor;
        let a1, a2, y1, dy2, y2, y3, y4, y5, y6, of2, dx2, x2, dx8, x8, dx3, x3, dx4, x4, x5, x6, x7, x9, x15, x10, x11, x12, x13, x14;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal1 ? cnstVal1 : adj1;
        a2 = adj2 < cnstVal2 ? cnstVal2 : adj2 > cnstVal4 ? cnstVal4 : adj2;
        y1 = h * a1 / cnstVal4;
        dy2 = y1 * 10 / 3;
        y2 = y1 - dy2;
        y3 = y1 + dy2;
        y4 = b - y1;
        y5 = y4 - dy2;
        y6 = y4 + dy2;
        of2 = w * a2 / cnstVal3;
        dx2 = of2 > 0 ? 0 : of2;
        x2 = l - dx2;
        dx8 = of2 > 0 ? of2 : 0;
        x8 = r - dx8;
        dx3 = (dx2 + x8) / 6;
        x3 = x2 + dx3;
        dx4 = (dx2 + x8) / 3;
        x4 = x2 + dx4;
        x5 = (x2 + x8) / 2;
        x6 = x5 + dx3;
        x7 = (x6 + x8) / 2;
        x9 = l + dx8;
        x15 = r + dx2;
        x10 = x9 + dx3;
        x11 = x9 + dx4;
        x12 = (x9 + x15) / 2;
        x13 = x12 + dx3;
        x14 = (x13 + x15) / 2;
        d_val = "M" + x2 + "," + y1 + " C" + x3 + "," + y2 + " " + x4 + "," + y3 + " " + x5 + "," + y1 + " C" + x6 + "," + y2 + " " + x7 + "," + y3 + " " + x8 + "," + y1 + " L" + x15 + "," + y4 + " C" + x14 + "," + y6 + " " + x13 + "," + y5 + " " + x12 + "," + y4 + " C" + x11 + "," + y6 + " " + x10 + "," + y5 + " " + x9 + "," + y4 + " z";
      } else if (shapType == "wave") {
        let cnstVal5 = 2e4 * slideFactor;
        let a1, a2, y1, dy2, y2, y3, y4, y5, y6, of2, dx2, x2, dx5, x5, dx3, x3, x4, x6, x10, x7, x8;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal5 ? cnstVal5 : adj1;
        a2 = adj2 < cnstVal2 ? cnstVal2 : adj2 > cnstVal4 ? cnstVal4 : adj2;
        y1 = h * a1 / cnstVal4;
        dy2 = y1 * 10 / 3;
        y2 = y1 - dy2;
        y3 = y1 + dy2;
        y4 = b - y1;
        y5 = y4 - dy2;
        y6 = y4 + dy2;
        of2 = w * a2 / cnstVal3;
        dx2 = of2 > 0 ? 0 : of2;
        x2 = l - dx2;
        dx5 = of2 > 0 ? of2 : 0;
        x5 = r - dx5;
        dx3 = (dx2 + x5) / 3;
        x3 = x2 + dx3;
        x4 = (x3 + x5) / 2;
        x6 = l + dx5;
        x10 = r + dx2;
        x7 = x6 + dx3;
        x8 = (x7 + x10) / 2;
        d_val = "M" + x2 + "," + y1 + " C" + x3 + "," + y2 + " " + x4 + "," + y3 + " " + x5 + "," + y1 + " L" + x10 + "," + y4 + " C" + x8 + "," + y6 + " " + x7 + "," + y5 + " " + x6 + "," + y4 + " z";
      }
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "ellipseRibbon":
    case "ellipseRibbon2": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let sAdj3, adj3 = 12500 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let d_val;
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal3 = 75e3 * slideFactor;
      let cnstVal4 = 1e5 * slideFactor;
      let cnstVal5 = 2e5 * slideFactor;
      let hc = w / 2, t = 0, l = 0, b = h, r = w, wd8 = w / 8;
      let a1, a2, q10, q11, q12, minAdj3, a3, dx2, x2, x3, x4, x5, x6, dy1, f1, q1, q2, cx1, cx2, dy3, q3, q4, q5, rh, q8, cx4, q9, cx5;
      a1 = adj1 < 0 ? 0 : adj1 > cnstVal4 ? cnstVal4 : adj1;
      a2 = adj2 < cnstVal1 ? cnstVal1 : adj2 > cnstVal3 ? cnstVal3 : adj2;
      q10 = cnstVal4 - a1;
      q11 = q10 / 2;
      q12 = a1 - q11;
      minAdj3 = 0 > q12 ? 0 : q12;
      a3 = adj3 < minAdj3 ? minAdj3 : adj3 > a1 ? a1 : adj3;
      dx2 = w * a2 / cnstVal5;
      x2 = hc - dx2;
      x3 = x2 + wd8;
      x4 = r - x3;
      x5 = r - x2;
      x6 = r - wd8;
      dy1 = h * a3 / cnstVal4;
      f1 = 4 * dy1 / w;
      q1 = x3 * x3 / w;
      q2 = x3 - q1;
      cx1 = x3 / 2;
      cx2 = r - cx1;
      q1 = h * a1 / cnstVal4;
      dy3 = q1 - dy1;
      q3 = x2 * x2 / w;
      q4 = x2 - q3;
      q5 = f1 * q4;
      rh = b - q1;
      q8 = dy1 * 14 / 16;
      cx4 = x2 / 2;
      q9 = f1 * cx4;
      cx5 = r - cx4;
      if (shapType == "ellipseRibbon") {
        let y1, cy1, y3, q6, q7, cy3, y2, y5, y6, cy4, cy6, y7, cy7, y8;
        y1 = f1 * q2;
        cy1 = f1 * cx1;
        y3 = q5 + dy3;
        q6 = dy1 + dy3 - y3;
        q7 = q6 + dy1;
        cy3 = q7 + dy3;
        y2 = (q8 + rh) / 2;
        y5 = q5 + rh;
        y6 = y3 + rh;
        cy4 = q9 + rh;
        cy6 = cy3 + rh;
        y7 = y1 + dy3;
        cy7 = q1 + q1 - y7;
        y8 = b - dy1;
        d_val = "M" + l + "," + t + " Q" + cx1 + "," + cy1 + " " + x3 + "," + y1 + " L" + x2 + "," + y3 + " Q" + hc + "," + cy3 + " " + x5 + "," + y3 + " L" + x4 + "," + y1 + " Q" + cx2 + "," + cy1 + " " + r + "," + t + " L" + x6 + "," + y2 + " L" + r + "," + rh + " Q" + cx5 + "," + cy4 + " " + x5 + "," + y5 + " L" + x5 + "," + y6 + " Q" + hc + "," + cy6 + " " + x2 + "," + y6 + " L" + x2 + "," + y5 + " Q" + cx4 + "," + cy4 + " " + l + "," + rh + " L" + wd8 + "," + y2 + " zM" + x2 + "," + y5 + " L" + x2 + "," + y3 + "M" + x5 + "," + y3 + " L" + x5 + "," + y5 + "M" + x3 + "," + y1 + " L" + x3 + "," + y7 + "M" + x4 + "," + y7 + " L" + x4 + "," + y1;
      } else if (shapType == "ellipseRibbon2") {
        let u1, y1, cu1, cy1, q32, q52, u3, y3, q6, q7, cu3, cy3, rh2, q82, u2, y2, u5, y5, u6, y6, cu4, cy4, cu6, cy6, u7, y7, cu7, cy7;
        u1 = f1 * q2;
        y1 = b - u1;
        cu1 = f1 * cx1;
        cy1 = b - cu1;
        u3 = q52 + dy3;
        y3 = b - u3;
        q6 = dy1 + dy3 - u3;
        q7 = q6 + dy1;
        cu3 = q7 + dy3;
        cy3 = b - cu3;
        u2 = (q82 + rh2) / 2;
        y2 = b - u2;
        u5 = q52 + rh2;
        y5 = b - u5;
        u6 = u3 + rh2;
        y6 = b - u6;
        cu4 = q9 + rh2;
        cy4 = b - cu4;
        cu6 = cu3 + rh2;
        cy6 = b - cu6;
        u7 = u1 + dy3;
        y7 = b - u7;
        cu7 = q1 + q1 - u7;
        cy7 = b - cu7;
        d_val = "M" + l + "," + b + " L" + wd8 + "," + y2 + " L" + l + "," + q1 + " Q" + cx4 + "," + cy4 + " " + x2 + "," + y5 + " L" + x2 + "," + y6 + " Q" + hc + "," + cy6 + " " + x5 + "," + y6 + " L" + x5 + "," + y5 + " Q" + cx5 + "," + cy4 + " " + r + "," + q1 + " L" + x6 + "," + y2 + " L" + r + "," + b + " Q" + cx2 + "," + cy1 + " " + x4 + "," + y1 + " L" + x5 + "," + y3 + " Q" + hc + "," + cy3 + " " + x2 + "," + y3 + " L" + x3 + "," + y1 + " Q" + cx1 + "," + cy1 + " " + l + "," + b + " zM" + x2 + "," + y3 + " L" + x2 + "," + y5 + "M" + x5 + "," + y5 + " L" + x5 + "," + y3 + "M" + x3 + "," + y7 + " L" + x3 + "," + y1 + "M" + x4 + "," + y1 + " L" + x4 + "," + y7;
      }
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "line":
    case "straightConnector1":
    case "bentConnector4":
    case "bentConnector5":
    case "curvedConnector2":
    case "curvedConnector3":
    case "curvedConnector4":
    case "curvedConnector5":
      result += "<line x1='0' y1='0' x2='" + w + "' y2='" + h + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' ";
      if (markerStart) {
        result += markerStart;
      }
      if (markerEnd) {
        result += markerEnd;
      }
      result += "/>";
      break;
    case "rightArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.25;
      let sAdj22, sAdj2_val2 = 0.5;
      let max_sAdj2_const2 = w / h;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = 0.5 - parseInt(sAdj12.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            let sAdj2_val22 = parseInt(sAdj22.substr(4)) / 1e5;
            sAdj2_val2 = 1 - sAdj2_val22 / max_sAdj2_const2;
          }
        }
      }
      result += " <polygon points='" + w + " " + h / 2 + "," + sAdj2_val2 * w + " 0," + sAdj2_val2 * w + " " + sAdj1_val2 * h + ",0 " + sAdj1_val2 * h + ",0 " + (1 - sAdj1_val2) * h + "," + sAdj2_val2 * w + " " + (1 - sAdj1_val2) * h + ", " + sAdj2_val2 * w + " " + h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftArrow":
      let shapAdjst_ary = shapAdjstArr;
      let sAdj1, sAdj1_val = 0.25;
      let sAdj2, sAdj2_val = 0.5;
      let max_sAdj2_const = w / h;
      if (shapAdjst_ary !== void 0) {
        for (var i = 0; i < shapAdjst_ary.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj1 = getTextByPathList(shapAdjst_ary[i], ["attrs", "fmla"]);
            sAdj1_val = 0.5 - parseInt(sAdj1.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj2 = getTextByPathList(shapAdjst_ary[i], ["attrs", "fmla"]);
            let sAdj2_val2 = parseInt(sAdj2.substr(4)) / 1e5;
            sAdj2_val = sAdj2_val2 / max_sAdj2_const;
          }
        }
      }
      result += " <polygon points='0 " + h / 2 + "," + sAdj2_val * w + " " + h + "," + sAdj2_val * w + " " + (1 - sAdj1_val) * h + "," + w + " " + (1 - sAdj1_val) * h + "," + w + " " + sAdj1_val * h + "," + sAdj2_val * w + " " + sAdj1_val * h + ", " + sAdj2_val * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    case "downArrow":
    case "flowChartOffpageConnector": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.25;
      let sAdj22, sAdj2_val2 = 0.5;
      let max_sAdj2_const2 = h / w;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            let sAdj2_val22 = parseInt(sAdj22.substr(4)) / 1e5;
            sAdj2_val2 = sAdj2_val22 / max_sAdj2_const2;
          }
        }
      }
      if (shapType == "flowChartOffpageConnector") {
        sAdj1_val2 = 0.5;
        sAdj2_val2 = 0.212;
      }
      result += " <polygon points='" + (0.5 - sAdj1_val2) * w + " 0," + (0.5 - sAdj1_val2) * w + " " + (1 - sAdj2_val2) * h + ",0 " + (1 - sAdj2_val2) * h + "," + w / 2 + " " + h + "," + w + " " + (1 - sAdj2_val2) * h + "," + (0.5 + sAdj1_val2) * w + " " + (1 - sAdj2_val2) * h + ", " + (0.5 + sAdj1_val2) * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "upArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.25;
      let sAdj22, sAdj2_val2 = 0.5;
      let max_sAdj2_const2 = h / w;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = parseInt(sAdj12.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            let sAdj2_val22 = parseInt(sAdj22.substr(4)) / 1e5;
            sAdj2_val2 = sAdj2_val22 / max_sAdj2_const2;
          }
        }
      }
      result += " <polygon points='" + w / 2 + " 0,0 " + sAdj2_val2 * h + "," + (0.5 - sAdj1_val2) * w + " " + sAdj2_val2 * h + "," + (0.5 - sAdj1_val2) * w + " " + h + "," + (0.5 + sAdj1_val2) * w + " " + h + "," + (0.5 + sAdj1_val2) * w + " " + sAdj2_val2 * h + ", " + w + " " + sAdj2_val2 * h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftRightArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.25;
      let sAdj22, sAdj2_val2 = 0.25;
      let max_sAdj2_const2 = w / h;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = 0.5 - parseInt(sAdj12.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            let sAdj2_val22 = parseInt(sAdj22.substr(4)) / 1e5;
            sAdj2_val2 = sAdj2_val22 / max_sAdj2_const2;
          }
        }
      }
      result += " <polygon points='0 " + h / 2 + "," + sAdj2_val2 * w + " " + h + "," + sAdj2_val2 * w + " " + (1 - sAdj1_val2) * h + "," + (1 - sAdj2_val2) * w + " " + (1 - sAdj1_val2) * h + "," + (1 - sAdj2_val2) * w + " " + h + "," + w + " " + h / 2 + ", " + (1 - sAdj2_val2) * w + " 0," + (1 - sAdj2_val2) * w + " " + sAdj1_val2 * h + "," + sAdj2_val2 * w + " " + sAdj1_val2 * h + "," + sAdj2_val2 * w + " 0' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "upDownArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, sAdj1_val2 = 0.25;
      let sAdj22, sAdj2_val2 = 0.25;
      let max_sAdj2_const2 = h / w;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            sAdj1_val2 = 0.5 - parseInt(sAdj12.substr(4)) / 2e5;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            let sAdj2_val22 = parseInt(sAdj22.substr(4)) / 1e5;
            sAdj2_val2 = sAdj2_val22 / max_sAdj2_const2;
          }
        }
      }
      result += " <polygon points='" + w / 2 + " 0,0 " + sAdj2_val2 * h + "," + sAdj1_val2 * w + " " + sAdj2_val2 * h + "," + sAdj1_val2 * w + " " + (1 - sAdj2_val2) * h + ",0 " + (1 - sAdj2_val2) * h + "," + w / 2 + " " + h + ", " + w + " " + (1 - sAdj2_val2) * h + "," + (1 - sAdj1_val2) * w + " " + (1 - sAdj2_val2) * h + "," + (1 - sAdj1_val2) * w + " " + sAdj2_val2 * h + "," + w + " " + sAdj2_val2 * h + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "quadArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 22500 * slideFactor;
      let sAdj22, adj2 = 22500 * slideFactor;
      let sAdj3, adj3 = 22500 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, a1, a2, a3, q1, x1, x2, dx2, x3, dx3, x4, x5, x6, y2, y3, y4, y5, y6, maxAdj1, maxAdj3;
      let minWH = Math.min(w, h);
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      q1 = cnstVal2 - maxAdj1;
      maxAdj3 = q1 / 2;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > maxAdj3) a3 = maxAdj3;
      else a3 = adj3;
      x1 = minWH * a3 / cnstVal2;
      dx2 = minWH * a2 / cnstVal2;
      x2 = hc - dx2;
      x5 = hc + dx2;
      dx3 = minWH * a1 / cnstVal3;
      x3 = hc - dx3;
      x4 = hc + dx3;
      x6 = w - x1;
      y2 = vc - dx2;
      y5 = vc + dx2;
      y3 = vc - dx3;
      y4 = vc + dx3;
      y6 = h - x1;
      let d_val = "M0," + vc + " L" + x1 + "," + y2 + " L" + x1 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + x1 + " L" + x2 + "," + x1 + " L" + hc + ",0 L" + x5 + "," + x1 + " L" + x4 + "," + x1 + " L" + x4 + "," + y3 + " L" + x6 + "," + y3 + " L" + x6 + "," + y2 + " L" + w + "," + vc + " L" + x6 + "," + y5 + " L" + x6 + "," + y4 + " L" + x4 + "," + y4 + " L" + x4 + "," + y6 + " L" + x5 + "," + y6 + " L" + hc + "," + h + " L" + x2 + "," + y6 + " L" + x3 + "," + y6 + " L" + x3 + "," + y4 + " L" + x1 + "," + y4 + " L" + x1 + "," + y5 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftRightUpArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, a1, a2, a3, q1, x1, x2, dx2, x3, dx3, x4, x5, x6, y2, dy2, y3, y4, y5, maxAdj1, maxAdj3;
      let minWH = Math.min(w, h);
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      q1 = cnstVal2 - maxAdj1;
      maxAdj3 = q1 / 2;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > maxAdj3) a3 = maxAdj3;
      else a3 = adj3;
      x1 = minWH * a3 / cnstVal2;
      dx2 = minWH * a2 / cnstVal2;
      x2 = hc - dx2;
      x5 = hc + dx2;
      dx3 = minWH * a1 / cnstVal3;
      x3 = hc - dx3;
      x4 = hc + dx3;
      x6 = w - x1;
      dy2 = minWH * a2 / cnstVal1;
      y2 = h - dy2;
      y4 = h - dx2;
      y3 = y4 - dx3;
      y5 = y4 + dx3;
      let d_val = "M0," + y4 + " L" + x1 + "," + y2 + " L" + x1 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + x1 + " L" + x2 + "," + x1 + " L" + hc + ",0 L" + x5 + "," + x1 + " L" + x4 + "," + x1 + " L" + x4 + "," + y3 + " L" + x6 + "," + y3 + " L" + x6 + "," + y2 + " L" + w + "," + y4 + " L" + x6 + "," + h + " L" + x6 + "," + y5 + " L" + x1 + "," + y5 + " L" + x1 + "," + h + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftUpArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, a1, a2, a3, x1, x2, dx2, dx4, dx3, x3, x4, x5, y2, y3, y4, y5, maxAdj1, maxAdj3;
      let minWH = Math.min(w, h);
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      maxAdj3 = cnstVal2 - maxAdj1;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > maxAdj3) a3 = maxAdj3;
      else a3 = adj3;
      x1 = minWH * a3 / cnstVal2;
      dx2 = minWH * a2 / cnstVal1;
      x2 = w - dx2;
      y2 = h - dx2;
      dx4 = minWH * a2 / cnstVal2;
      x4 = w - dx4;
      y4 = h - dx4;
      dx3 = minWH * a1 / cnstVal3;
      x3 = x4 - dx3;
      x5 = x4 + dx3;
      y3 = y4 - dx3;
      y5 = y4 + dx3;
      let d_val = "M0," + y4 + " L" + x1 + "," + y2 + " L" + x1 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + x1 + " L" + x2 + "," + x1 + " L" + x4 + ",0 L" + w + "," + x1 + " L" + x5 + "," + x1 + " L" + x5 + "," + y5 + " L" + x1 + "," + y5 + " L" + x1 + "," + h + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bentUpArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, a1, a2, a3, dx1, x1, dx2, x2, dx3, x3, x4, y1, y2, dy2, maxAdj1, maxAdj3;
      let minWH = Math.min(w, h);
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnstVal1) a1 = cnstVal1;
      else a1 = adj1;
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      maxAdj3 = cnstVal2 - maxAdj1;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > maxAdj3) a3 = maxAdj3;
      else a3 = adj3;
      y1 = minWH * a3 / cnstVal2;
      dx1 = minWH * a2 / cnstVal1;
      x1 = w - dx1;
      dx3 = minWH * a2 / cnstVal2;
      x3 = w - dx3;
      dx2 = minWH * a1 / cnstVal3;
      x2 = x3 - dx2;
      x4 = x3 + dx2;
      dy2 = minWH * a1 / cnstVal2;
      y2 = h - dy2;
      let d_val = "M0," + y2 + " L" + x2 + "," + y2 + " L" + x2 + "," + y1 + " L" + x1 + "," + y1 + " L" + x3 + ",0 L" + w + "," + y1 + " L" + x4 + "," + y1 + " L" + x4 + "," + h + " L0," + h + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "bentArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 43750 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let a1, a2, a3, a4, x3, x4, y3, y4, y5, y6, maxAdj1, maxAdj4;
      let minWH = Math.min(w, h);
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > cnstVal1) a3 = cnstVal1;
      else a3 = adj3;
      let aw2, th2, dh2, ah, bw, bh, bs, bd, bd3, bd2, th = minWH * a1 / cnstVal2;
      aw2 = minWH * a2 / cnstVal2;
      th2 = th / 2;
      dh2 = aw2 - th2;
      ah = minWH * a3 / cnstVal2;
      bw = w - ah;
      bh = h - dh2;
      bs = bw < bh ? bw : bh;
      maxAdj4 = cnstVal2 * bs / minWH;
      if (adj4 < 0) a4 = 0;
      else if (adj4 > maxAdj4) a4 = maxAdj4;
      else a4 = adj4;
      bd = minWH * a4 / cnstVal2;
      bd3 = bd - th;
      bd2 = bd3 > 0 ? bd3 : 0;
      x3 = th + bd2;
      x4 = w - ah;
      y3 = dh2 + th;
      y4 = y3 + dh2;
      y5 = dh2 + bd;
      y6 = y3 + bd2;
      let d_val = "M0," + h + " L0," + y5 + shapeArc(bd, y5, bd, bd, 180, 270, false).replace("M", "L") + " L" + x4 + "," + dh2 + " L" + x4 + ",0 L" + w + "," + aw2 + " L" + x4 + "," + y4 + " L" + x4 + "," + y3 + " L" + x3 + "," + y3 + shapeArc(x3, y6, bd2, bd2, 270, 180, false).replace("M", "L") + " L" + th + "," + h + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "uturnArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 43750 * slideFactor;
      let sAdj5, adj5 = 75e3 * slideFactor;
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj5") {
            sAdj5 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj5 = parseInt(sAdj5.substr(4)) * slideFactor;
          }
        }
      }
      let a1, a2, a3, a4, a5, q1, q2, q3, x3, x4, x5, x6, x7, x8, x9, y4, y5, minAdj5, maxAdj1, maxAdj3, maxAdj4;
      let minWH = Math.min(w, h);
      if (adj2 < 0) a2 = 0;
      else if (adj2 > cnstVal1) a2 = cnstVal1;
      else a2 = adj2;
      maxAdj1 = 2 * a2;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > maxAdj1) a1 = maxAdj1;
      else a1 = adj1;
      q2 = a1 * minWH / h;
      q3 = cnstVal2 - q2;
      maxAdj3 = q3 * h / minWH;
      if (adj3 < 0) a3 = 0;
      else if (adj3 > maxAdj3) a3 = maxAdj3;
      else a3 = adj3;
      q1 = a3 + a1;
      minAdj5 = q1 * minWH / h;
      if (adj5 < minAdj5) a5 = minAdj5;
      else if (adj5 > cnstVal2) a5 = cnstVal2;
      else a5 = adj5;
      let aw2, th2, dh2, ah, bw, bs, bd, bd3, bd2, cx, th = minWH * a1 / cnstVal2;
      aw2 = minWH * a2 / cnstVal2;
      th2 = th / 2;
      dh2 = aw2 - th2;
      y5 = h * a5 / cnstVal2;
      ah = minWH * a3 / cnstVal2;
      y4 = y5 - ah;
      x9 = w - dh2;
      bw = x9 / 2;
      bs = bw < y4 ? bw : y4;
      maxAdj4 = cnstVal2 * bs / minWH;
      if (adj4 < 0) a4 = 0;
      else if (adj4 > maxAdj4) a4 = maxAdj4;
      else a4 = adj4;
      bd = minWH * a4 / cnstVal2;
      bd3 = bd - th;
      bd2 = bd3 > 0 ? bd3 : 0;
      x3 = th + bd2;
      x8 = w - aw2;
      x6 = x8 - aw2;
      x7 = x6 + dh2;
      x4 = x9 - bd;
      x5 = x7 - bd2;
      cx = (th + x7) / 2;
      let cy = (y4 + th) / 2;
      let d_val = "M0," + h + " L0," + bd + shapeArc(bd, bd, bd, bd, 180, 270, false).replace("M", "L") + " L" + x4 + ",0" + shapeArc(x4, bd, bd, bd, 270, 360, false).replace("M", "L") + " L" + x9 + "," + y4 + " L" + w + "," + y4 + " L" + x8 + "," + y5 + " L" + x6 + "," + y4 + " L" + x7 + "," + y4 + " L" + x7 + "," + x3 + shapeArc(x5, x3, bd2, bd2, 0, -90, false).replace("M", "L") + " L" + x3 + "," + th + shapeArc(x3, x3, bd2, bd2, 270, 180, false).replace("M", "L") + " L" + th + "," + h + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "stripedRightArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 5e4 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let cnstVal2 = 2e5 * slideFactor;
      let cnstVal3 = 84375 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let a1, a2, x4, x5, dx5, x6, dx6, y1, dy1, y2, maxAdj2, vc = h / 2;
      let minWH = Math.min(w, h);
      maxAdj2 = cnstVal3 * w / minWH;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnstVal1) a1 = cnstVal1;
      else a1 = adj1;
      if (adj2 < 0) a2 = 0;
      else if (adj2 > maxAdj2) a2 = maxAdj2;
      else a2 = adj2;
      x4 = minWH * 5 / 32;
      dx5 = minWH * a2 / cnstVal1;
      x5 = w - dx5;
      dy1 = h * a1 / cnstVal2;
      y1 = vc - dy1;
      y2 = vc + dy1;
      let ssd8 = minWH / 8, ssd16 = minWH / 16, ssd32 = minWH / 32;
      let d_val = "M0," + y1 + " L" + ssd32 + "," + y1 + " L" + ssd32 + "," + y2 + " L0," + y2 + " z M" + ssd16 + "," + y1 + " L" + ssd8 + "," + y1 + " L" + ssd8 + "," + y2 + " L" + ssd16 + "," + y2 + " z M" + x4 + "," + y1 + " L" + x5 + "," + y1 + " L" + x5 + ",0 L" + w + "," + vc + " L" + x5 + "," + h + " L" + x5 + "," + y2 + " L" + x4 + "," + y2 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "notchedRightArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 5e4 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      let cnstVal2 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          }
        }
      }
      let a1, a2, x1, x2, dx2, y1, dy1, y2, maxAdj2, vc = h / 2, hd2 = vc;
      let minWH = Math.min(w, h);
      maxAdj2 = cnstVal1 * w / minWH;
      if (adj1 < 0) a1 = 0;
      else if (adj1 > cnstVal1) a1 = cnstVal1;
      else a1 = adj1;
      if (adj2 < 0) a2 = 0;
      else if (adj2 > maxAdj2) a2 = maxAdj2;
      else a2 = adj2;
      dx2 = minWH * a2 / cnstVal1;
      x2 = w - dx2;
      dy1 = h * a1 / cnstVal2;
      y1 = vc - dy1;
      y2 = vc + dy1;
      x1 = dy1 * dx2 / hd2;
      let d_val = "M0," + y1 + " L" + x2 + "," + y1 + " L" + x2 + ",0 L" + w + "," + vc + " L" + x2 + "," + h + " L" + x2 + "," + y2 + " L0," + y2 + " L" + x1 + "," + vc + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "homePlate": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a, x1, dx1, maxAdj, vc = h / 2;
      let minWH = Math.min(w, h);
      maxAdj = cnstVal1 * w / minWH;
      if (adj < 0) a = 0;
      else if (adj > maxAdj) a = maxAdj;
      else a = adj;
      dx1 = minWH * a / cnstVal1;
      x1 = w - dx1;
      let d_val = "M0,0 L" + x1 + ",0 L" + w + "," + vc + " L" + x1 + "," + h + " L0," + h + " z";
      result += "<path  d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "chevron": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 5e4 * slideFactor;
      let cnstVal1 = 1e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let a, x1, dx1, x2, maxAdj, vc = h / 2;
      let minWH = Math.min(w, h);
      maxAdj = cnstVal1 * w / minWH;
      if (adj < 0) a = 0;
      else if (adj > maxAdj) a = maxAdj;
      else a = adj;
      x1 = minWH * a / cnstVal1;
      x2 = w - x1;
      let d_val = "M0,0 L" + x2 + ",0 L" + w + "," + vc + " L" + x2 + "," + h + " L0," + h + " L" + x1 + "," + vc + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "rightArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 64977 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let maxAdj2, a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dy1, dy2, y1, y2, y3, y4, dx3, x3, x2, x1;
      let vc = h / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      maxAdj2 = cnstVal1 * h / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal2 * w / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * ss / w;
      maxAdj4 = cnstVal3 - q2;
      a4 = adj4 < 0 ? 0 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dy1 = ss * a2 / cnstVal2;
      dy2 = ss * a1 / cnstVal3;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc + dy2;
      y4 = vc + dy1;
      dx3 = ss * a3 / cnstVal2;
      x3 = r - dx3;
      x2 = w * a4 / cnstVal2;
      x1 = x2 / 2;
      let d_val = "M" + l + "," + t + " L" + x2 + "," + t + " L" + x2 + "," + y2 + " L" + x3 + "," + y2 + " L" + x3 + "," + y1 + " L" + r + "," + vc + " L" + x3 + "," + y4 + " L" + x3 + "," + y3 + " L" + x2 + "," + y3 + " L" + x2 + "," + b + " L" + l + "," + b + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "downArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 64977 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let maxAdj2, a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dx1, dx2, x1, x2, x3, x4, dy3, y3, y2, y1;
      let hc = w / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      maxAdj2 = cnstVal1 * w / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal2 * h / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * ss / h;
      maxAdj4 = cnstVal2 - q2;
      a4 = adj4 < 0 ? 0 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dx1 = ss * a2 / cnstVal2;
      dx2 = ss * a1 / cnstVal3;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc + dx2;
      x4 = hc + dx1;
      dy3 = ss * a3 / cnstVal2;
      y3 = b - dy3;
      y2 = h * a4 / cnstVal2;
      y1 = y2 / 2;
      let d_val = "M" + l + "," + t + " L" + r + "," + t + " L" + r + "," + y2 + " L" + x3 + "," + y2 + " L" + x3 + "," + y3 + " L" + x4 + "," + y3 + " L" + hc + "," + b + " L" + x1 + "," + y3 + " L" + x2 + "," + y3 + " L" + x2 + "," + y2 + " L" + l + "," + y2 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 64977 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let maxAdj2, a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dy1, dy2, y1, y2, y3, y4, x1, dx2, x2, x3;
      let vc = h / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      maxAdj2 = cnstVal1 * h / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal2 * w / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * ss / w;
      maxAdj4 = cnstVal2 - q2;
      a4 = adj4 < 0 ? 0 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dy1 = ss * a2 / cnstVal2;
      dy2 = ss * a1 / cnstVal3;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc + dy2;
      y4 = vc + dy1;
      x1 = ss * a3 / cnstVal2;
      dx2 = w * a4 / cnstVal2;
      x2 = r - dx2;
      x3 = (x2 + r) / 2;
      let d_val = "M" + l + "," + vc + " L" + x1 + "," + y1 + " L" + x1 + "," + y2 + " L" + x2 + "," + y2 + " L" + x2 + "," + t + " L" + r + "," + t + " L" + r + "," + b + " L" + x2 + "," + b + " L" + x2 + "," + y3 + " L" + x1 + "," + y3 + " L" + x1 + "," + y4 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "upArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 64977 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let maxAdj2, a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dx1, dx2, x1, x2, x3, x4, y1, dy2, y2, y3;
      let hc = w / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      maxAdj2 = cnstVal1 * w / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal2 * h / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * ss / h;
      maxAdj4 = cnstVal2 - q2;
      a4 = adj4 < 0 ? 0 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dx1 = ss * a2 / cnstVal2;
      dx2 = ss * a1 / cnstVal3;
      x1 = hc - dx1;
      x2 = hc - dx2;
      x3 = hc + dx2;
      x4 = hc + dx1;
      y1 = ss * a3 / cnstVal2;
      dy2 = h * a4 / cnstVal2;
      y2 = b - dy2;
      y3 = (y2 + b) / 2;
      let d_val = "M" + l + "," + y2 + " L" + x2 + "," + y2 + " L" + x2 + "," + y1 + " L" + x1 + "," + y1 + " L" + hc + "," + t + " L" + x4 + "," + y1 + " L" + x3 + "," + y1 + " L" + x3 + "," + y2 + " L" + r + "," + y2 + " L" + r + "," + b + " L" + l + "," + b + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftRightArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 25e3 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let sAdj4, adj4 = 48123 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let maxAdj2, a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dy1, dy2, y1, y2, y3, y4, x1, x4, dx2, x2, x3;
      let vc = h / 2, hc = w / 2, wd2 = w / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      maxAdj2 = cnstVal1 * h / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal1 * w / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * ss / wd2;
      maxAdj4 = cnstVal2 - q2;
      a4 = adj4 < 0 ? 0 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dy1 = ss * a2 / cnstVal2;
      dy2 = ss * a1 / cnstVal3;
      y1 = vc - dy1;
      y2 = vc - dy2;
      y3 = vc + dy2;
      y4 = vc + dy1;
      x1 = ss * a3 / cnstVal2;
      x4 = r - x1;
      dx2 = w * a4 / cnstVal3;
      x2 = hc - dx2;
      x3 = hc + dx2;
      let d_val = "M" + l + "," + vc + " L" + x1 + "," + y1 + " L" + x1 + "," + y2 + " L" + x2 + "," + y2 + " L" + x2 + "," + t + " L" + x3 + "," + t + " L" + x3 + "," + y2 + " L" + x4 + "," + y2 + " L" + x4 + "," + y1 + " L" + r + "," + vc + " L" + x4 + "," + y4 + " L" + x4 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + b + " L" + x2 + "," + b + " L" + x2 + "," + y3 + " L" + x1 + "," + y3 + " L" + x1 + "," + y4 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "quadArrowCallout": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 18515 * slideFactor;
      let sAdj22, adj2 = 18515 * slideFactor;
      let sAdj3, adj3 = 18515 * slideFactor;
      let sAdj4, adj4 = 48123 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, r = w, b = h, l = 0, t = 0;
      let ss = Math.min(w, h);
      let a2, maxAdj1, a1, maxAdj3, a3, q2, maxAdj4, a4, dx2, dx3, ah, dx1, dy1, x8, x2, x7, x3, x6, x4, x5, y8, y2, y7, y3, y6, y4, y5;
      a2 = adj2 < 0 ? 0 : adj2 > cnstVal1 ? cnstVal1 : adj2;
      maxAdj1 = a2 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      maxAdj3 = cnstVal1 - a2;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      q2 = a3 * 2;
      maxAdj4 = cnstVal2 - q2;
      a4 = adj4 < a1 ? a1 : adj4 > maxAdj4 ? maxAdj4 : adj4;
      dx2 = ss * a2 / cnstVal2;
      dx3 = ss * a1 / cnstVal3;
      ah = ss * a3 / cnstVal2;
      dx1 = w * a4 / cnstVal3;
      dy1 = h * a4 / cnstVal3;
      x8 = r - ah;
      x2 = hc - dx1;
      x7 = hc + dx1;
      x3 = hc - dx2;
      x6 = hc + dx2;
      x4 = hc - dx3;
      x5 = hc + dx3;
      y8 = b - ah;
      y2 = vc - dy1;
      y7 = vc + dy1;
      y3 = vc - dx2;
      y6 = vc + dx2;
      y4 = vc - dx3;
      y5 = vc + dx3;
      let d_val = "M" + l + "," + vc + " L" + ah + "," + y3 + " L" + ah + "," + y4 + " L" + x2 + "," + y4 + " L" + x2 + "," + y2 + " L" + x4 + "," + y2 + " L" + x4 + "," + ah + " L" + x3 + "," + ah + " L" + hc + "," + t + " L" + x6 + "," + ah + " L" + x5 + "," + ah + " L" + x5 + "," + y2 + " L" + x7 + "," + y2 + " L" + x7 + "," + y4 + " L" + x8 + "," + y4 + " L" + x8 + "," + y3 + " L" + r + "," + vc + " L" + x8 + "," + y6 + " L" + x8 + "," + y5 + " L" + x7 + "," + y5 + " L" + x7 + "," + y7 + " L" + x5 + "," + y7 + " L" + x5 + "," + y8 + " L" + x6 + "," + y8 + " L" + hc + "," + b + " L" + x3 + "," + y8 + " L" + x4 + "," + y8 + " L" + x4 + "," + y7 + " L" + x2 + "," + y7 + " L" + x2 + "," + y5 + " L" + ah + "," + y5 + " L" + ah + "," + y6 + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "curvedDownArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, wd2 = w / 2, r = w, b = h, l = 0, t = 0, c3d4 = 270, cd2 = 180, cd4 = 90;
      let ss = Math.min(w, h);
      let maxAdj2, a2, a1, th, aw, q1, wR, q7, q8, q9, q10, q11, idy, maxAdj3, a3, ah, x3, q2, q3, q4, q5, dx, x5, x7, q6, dh, x4, x8, aw2, x6, y1, swAng, mswAng, iy, ix, q12, dang2, stAng, stAng2, swAng2, swAng3;
      maxAdj2 = cnstVal1 * w / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      a1 = adj1 < 0 ? 0 : adj1 > cnstVal2 ? cnstVal2 : adj1;
      th = ss * a1 / cnstVal2;
      aw = ss * a2 / cnstVal2;
      q1 = (th + aw) / 4;
      wR = wd2 - q1;
      q7 = wR * 2;
      q8 = q7 * q7;
      q9 = th * th;
      q10 = q8 - q9;
      q11 = Math.sqrt(q10);
      idy = q11 * h / q7;
      maxAdj3 = cnstVal2 * idy / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      ah = ss * adj3 / cnstVal2;
      x3 = wR + th;
      q2 = h * h;
      q3 = ah * ah;
      q4 = q2 - q3;
      q5 = Math.sqrt(q4);
      dx = q5 * wR / h;
      x5 = wR + dx;
      x7 = x3 + dx;
      q6 = aw - th;
      dh = q6 / 2;
      x4 = x5 - dh;
      x8 = x7 + dh;
      aw2 = aw / 2;
      x6 = r - aw2;
      y1 = b - ah;
      swAng = Math.atan(dx / ah);
      let swAngDeg = swAng * 180 / Math.PI;
      mswAng = -swAngDeg;
      iy = b - idy;
      ix = (wR + x3) / 2;
      q12 = th / 2;
      dang2 = Math.atan(q12 / idy);
      let dang2Deg = dang2 * 180 / Math.PI;
      stAng = c3d4 + swAngDeg;
      stAng2 = c3d4 - dang2Deg;
      swAng2 = dang2Deg - cd4;
      swAng3 = cd4 + dang2Deg;
      let d_val = "M" + x6 + "," + b + " L" + x4 + "," + y1 + " L" + x5 + "," + y1 + shapeArc(wR, h, wR, h, stAng, stAng + mswAng, false).replace("M", "L") + " L" + x3 + "," + t + shapeArc(x3, h, wR, h, c3d4, c3d4 + swAngDeg, false).replace("M", "L") + " L" + (x5 + th) + "," + y1 + " L" + x8 + "," + y1 + " zM" + x3 + "," + t + shapeArc(x3, h, wR, h, stAng2, stAng2 + swAng2, false).replace("M", "L") + shapeArc(wR, h, wR, h, cd2, cd2 + swAng3, false).replace("M", "L");
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "curvedLeftArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, hd2 = h / 2, r = w, b = h, l = 0, t = 0, c3d4 = 270, cd2 = 180, cd4 = 90;
      let ss = Math.min(w, h);
      let maxAdj2, a2, a1, th, aw, q1, hR, q7, q8, q9, q10, q11, iDx, maxAdj3, a3, ah, y3, q2, q3, q4, q5, dy, y5, y7, q6, dh, y4, y8, aw2, y6, x1, swAng, mswAng, ix, iy, q12, dang2, swAng2, swAng3, stAng3;
      maxAdj2 = cnstVal1 * h / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      a1 = adj1 < 0 ? 0 : adj1 > a2 ? a2 : adj1;
      th = ss * a1 / cnstVal2;
      aw = ss * a2 / cnstVal2;
      q1 = (th + aw) / 4;
      hR = hd2 - q1;
      q7 = hR * 2;
      q8 = q7 * q7;
      q9 = th * th;
      q10 = q8 - q9;
      q11 = Math.sqrt(q10);
      iDx = q11 * w / q7;
      maxAdj3 = cnstVal2 * iDx / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      ah = ss * a3 / cnstVal2;
      y3 = hR + th;
      q2 = w * w;
      q3 = ah * ah;
      q4 = q2 - q3;
      q5 = Math.sqrt(q4);
      dy = q5 * hR / w;
      y5 = hR + dy;
      y7 = y3 + dy;
      q6 = aw - th;
      dh = q6 / 2;
      y4 = y5 - dh;
      y8 = y7 + dh;
      aw2 = aw / 2;
      y6 = b - aw2;
      x1 = l + ah;
      swAng = Math.atan(dy / ah);
      mswAng = -swAng;
      ix = l + iDx;
      iy = (hR + y3) / 2;
      q12 = th / 2;
      dang2 = Math.atan(q12 / iDx);
      swAng2 = dang2 - swAng;
      swAng3 = swAng + dang2;
      stAng3 = -dang2;
      let swAngDg, swAng2Dg, swAng3Dg, stAng3dg;
      swAngDg = swAng * 180 / Math.PI;
      swAng2Dg = swAng2 * 180 / Math.PI;
      swAng3Dg = swAng3 * 180 / Math.PI;
      stAng3dg = stAng3 * 180 / Math.PI;
      let d_val = "M" + r + "," + y3 + shapeArc(l, hR, w, hR, 0, -cd4, false).replace("M", "L") + " L" + l + "," + t + shapeArc(l, y3, w, hR, c3d4, c3d4 + cd4, false).replace("M", "L") + " L" + r + "," + y3 + shapeArc(l, y3, w, hR, 0, swAngDg, false).replace("M", "L") + " L" + x1 + "," + y7 + " L" + x1 + "," + y8 + " L" + l + "," + y6 + " L" + x1 + "," + y4 + " L" + x1 + "," + y5 + shapeArc(l, hR, w, hR, swAngDg, swAngDg + swAng2Dg, false).replace("M", "L") + shapeArc(l, hR, w, hR, 0, -cd4, false).replace("M", "L") + shapeArc(l, y3, w, hR, c3d4, c3d4 + cd4, false).replace("M", "L");
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "curvedRightArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, hd2 = h / 2, r = w, b = h, l = 0, t = 0, c3d4 = 270, cd2 = 180, cd4 = 90;
      let ss = Math.min(w, h);
      let maxAdj2, a2, a1, th, aw, q1, hR, q7, q8, q9, q10, q11, iDx, maxAdj3, a3, ah, y3, q2, q3, q4, q5, dy, y5, y7, q6, dh, y4, y8, aw2, y6, x1, swAng, stAng, mswAng, ix, iy, q12, dang2, swAng2, swAng3, stAng3;
      maxAdj2 = cnstVal1 * h / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      a1 = adj1 < 0 ? 0 : adj1 > a2 ? a2 : adj1;
      th = ss * a1 / cnstVal2;
      aw = ss * a2 / cnstVal2;
      q1 = (th + aw) / 4;
      hR = hd2 - q1;
      q7 = hR * 2;
      q8 = q7 * q7;
      q9 = th * th;
      q10 = q8 - q9;
      q11 = Math.sqrt(q10);
      iDx = q11 * w / q7;
      maxAdj3 = cnstVal2 * iDx / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      ah = ss * a3 / cnstVal2;
      y3 = hR + th;
      q2 = w * w;
      q3 = ah * ah;
      q4 = q2 - q3;
      q5 = Math.sqrt(q4);
      dy = q5 * hR / w;
      y5 = hR + dy;
      y7 = y3 + dy;
      q6 = aw - th;
      dh = q6 / 2;
      y4 = y5 - dh;
      y8 = y7 + dh;
      aw2 = aw / 2;
      y6 = b - aw2;
      x1 = r - ah;
      swAng = Math.atan(dy / ah);
      stAng = Math.PI + 0 - swAng;
      mswAng = -swAng;
      ix = r - iDx;
      iy = (hR + y3) / 2;
      q12 = th / 2;
      dang2 = Math.atan(q12 / iDx);
      swAng2 = dang2 - Math.PI / 2;
      swAng3 = Math.PI / 2 + dang2;
      stAng3 = Math.PI - dang2;
      let stAngDg, mswAngDg, swAngDg, swAng2dg;
      stAngDg = stAng * 180 / Math.PI;
      mswAngDg = mswAng * 180 / Math.PI;
      swAngDg = swAng * 180 / Math.PI;
      swAng2dg = swAng2 * 180 / Math.PI;
      let d_val = "M" + l + "," + hR + shapeArc(w, hR, w, hR, cd2, cd2 + mswAngDg, false).replace("M", "L") + " L" + x1 + "," + y5 + " L" + x1 + "," + y4 + " L" + r + "," + y6 + " L" + x1 + "," + y8 + " L" + x1 + "," + y7 + shapeArc(w, y3, w, hR, stAngDg, stAngDg + swAngDg, false).replace("M", "L") + " L" + l + "," + hR + shapeArc(w, hR, w, hR, cd2, cd2 + cd4, false).replace("M", "L") + " L" + r + "," + th + shapeArc(w, y3, w, hR, c3d4, c3d4 + swAng2dg, false).replace("M", "L");
      "";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "curvedUpArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 25e3 * slideFactor;
      let sAdj22, adj2 = 5e4 * slideFactor;
      let sAdj3, adj3 = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, wd2 = w / 2, r = w, b = h, l = 0, t = 0, c3d4 = 270, cd2 = 180, cd4 = 90;
      let ss = Math.min(w, h);
      let maxAdj2, a2, a1, th, aw, q1, wR, q7, q8, q9, q10, q11, idy, maxAdj3, a3, ah, x3, q2, q3, q4, q5, dx, x5, x7, q6, dh, x4, x8, aw2, x6, y1, swAng, mswAng, iy, ix, q12, dang2, swAng2, mswAng2, stAng3, swAng3, stAng2;
      maxAdj2 = cnstVal1 * w / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      a1 = adj1 < 0 ? 0 : adj1 > cnstVal2 ? cnstVal2 : adj1;
      th = ss * a1 / cnstVal2;
      aw = ss * a2 / cnstVal2;
      q1 = (th + aw) / 4;
      wR = wd2 - q1;
      q7 = wR * 2;
      q8 = q7 * q7;
      q9 = th * th;
      q10 = q8 - q9;
      q11 = Math.sqrt(q10);
      idy = q11 * h / q7;
      maxAdj3 = cnstVal2 * idy / ss;
      a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
      ah = ss * adj3 / cnstVal2;
      x3 = wR + th;
      q2 = h * h;
      q3 = ah * ah;
      q4 = q2 - q3;
      q5 = Math.sqrt(q4);
      dx = q5 * wR / h;
      x5 = wR + dx;
      x7 = x3 + dx;
      q6 = aw - th;
      dh = q6 / 2;
      x4 = x5 - dh;
      x8 = x7 + dh;
      aw2 = aw / 2;
      x6 = r - aw2;
      y1 = t + ah;
      swAng = Math.atan(dx / ah);
      mswAng = -swAng;
      iy = t + idy;
      ix = (wR + x3) / 2;
      q12 = th / 2;
      dang2 = Math.atan(q12 / idy);
      swAng2 = dang2 - swAng;
      mswAng2 = -swAng2;
      stAng3 = Math.PI / 2 - swAng;
      swAng3 = swAng + dang2;
      stAng2 = Math.PI / 2 - dang2;
      let stAng2dg, swAng2dg, swAngDg, stAng3dg;
      stAng2dg = stAng2 * 180 / Math.PI;
      swAng2dg = swAng2 * 180 / Math.PI;
      stAng3dg = stAng3 * 180 / Math.PI;
      swAngDg = swAng * 180 / Math.PI;
      let d_val = (
        //"M" + ix + "," +iy + 
        shapeArc(wR, 0, wR, h, stAng2dg, stAng2dg + swAng2dg, false) + //.replace("M","L") +
        " L" + x5 + "," + y1 + " L" + x4 + "," + y1 + " L" + x6 + "," + t + " L" + x8 + "," + y1 + " L" + x7 + "," + y1 + shapeArc(x3, 0, wR, h, stAng3dg, stAng3dg + swAngDg, false).replace("M", "L") + " L" + wR + "," + b + shapeArc(wR, 0, wR, h, cd4, cd2, false).replace("M", "L") + " L" + th + "," + t + shapeArc(x3, 0, wR, h, cd2, cd4, false).replace("M", "L")
      );
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "mathDivide":
    case "mathEqual":
    case "mathMinus":
    case "mathMultiply":
    case "mathNotEqual":
    case "mathPlus": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1;
      let sAdj22, adj2;
      let sAdj3, adj3;
      if (shapAdjst_ary2 !== void 0) {
        if (shapAdjst_ary2.constructor === Array) {
          for (var i = 0; i < shapAdjst_ary2.length; i++) {
            let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
            if (sAdj_name == "adj1") {
              sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
              adj1 = parseInt(sAdj12.substr(4));
            } else if (sAdj_name == "adj2") {
              sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
              adj2 = parseInt(sAdj22.substr(4));
            } else if (sAdj_name == "adj3") {
              sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
              adj3 = parseInt(sAdj3.substr(4));
            }
          }
        } else {
          sAdj12 = getTextByPathList(shapAdjst_ary2, ["attrs", "fmla"]);
          adj1 = parseInt(sAdj12.substr(4));
        }
      }
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let cnstVal3 = 2e5 * slideFactor;
      let dVal;
      let hc = w / 2, vc = h / 2, hd2 = h / 2;
      if (shapType == "mathNotEqual") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
          adj2 = 110 * Math.PI / 180;
          adj3 = 11760 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
          adj2 = adj2 / 6e4 * Math.PI / 180;
          adj3 = adj3 * slideFactor;
        }
        let a1, crAng, a2a1, maxAdj3, a3, dy1, dy2, dx1, x1, x8, y2, y3, y1, y4, cadj2, xadj2, len, bhw, bhw2, x7, dx67, x6, dx57, x5, dx47, x4, dx37, x3, dx27, x2, rx7, rx6, rx5, rx4, rx3, rx2, dx7, rxt, lxt, rx, lx, dy3, dy4, ry, ly, dlx, drx, dly, dry, xC1, xC2, yC1, yC2, yC3, yC4;
        let angVal1 = 70 * Math.PI / 180, angVal2 = 110 * Math.PI / 180;
        let cnstVal4 = 73490 * slideFactor;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal1 ? cnstVal1 : adj1;
        crAng = adj2 < angVal1 ? angVal1 : adj2 > angVal2 ? angVal2 : adj2;
        a2a1 = a1 * 2;
        maxAdj3 = cnstVal2 - a2a1;
        a3 = adj3 < 0 ? 0 : adj3 > maxAdj3 ? maxAdj3 : adj3;
        dy1 = h * a1 / cnstVal2;
        dy2 = h * a3 / cnstVal3;
        dx1 = w * cnstVal4 / cnstVal3;
        x1 = hc - dx1;
        x8 = hc + dx1;
        y2 = vc - dy2;
        y3 = vc + dy2;
        y1 = y2 - dy1;
        y4 = y3 + dy1;
        cadj2 = crAng - Math.PI / 2;
        xadj2 = hd2 * Math.tan(cadj2);
        len = Math.sqrt(xadj2 * xadj2 + hd2 * hd2);
        bhw = len * dy1 / hd2;
        bhw2 = bhw / 2;
        x7 = hc + xadj2 - bhw2;
        dx67 = xadj2 * y1 / hd2;
        x6 = x7 - dx67;
        dx57 = xadj2 * y2 / hd2;
        x5 = x7 - dx57;
        dx47 = xadj2 * y3 / hd2;
        x4 = x7 - dx47;
        dx37 = xadj2 * y4 / hd2;
        x3 = x7 - dx37;
        dx27 = xadj2 * 2;
        x2 = x7 - dx27;
        rx7 = x7 + bhw;
        rx6 = x6 + bhw;
        rx5 = x5 + bhw;
        rx4 = x4 + bhw;
        rx3 = x3 + bhw;
        rx2 = x2 + bhw;
        dx7 = dy1 * hd2 / len;
        rxt = x7 + dx7;
        lxt = rx7 - dx7;
        rx = cadj2 > 0 ? rxt : rx7;
        lx = cadj2 > 0 ? x7 : lxt;
        dy3 = dy1 * xadj2 / len;
        dy4 = -dy3;
        ry = cadj2 > 0 ? dy3 : 0;
        ly = cadj2 > 0 ? 0 : dy4;
        dlx = w - rx;
        drx = w - lx;
        dly = h - ry;
        dry = h - ly;
        xC1 = (rx + lx) / 2;
        xC2 = (drx + dlx) / 2;
        yC1 = (ry + ly) / 2;
        yC2 = (y1 + y2) / 2;
        yC3 = (y3 + y4) / 2;
        yC4 = (dry + dly) / 2;
        dVal = "M" + x1 + "," + y1 + " L" + x6 + "," + y1 + " L" + lx + "," + ly + " L" + rx + "," + ry + " L" + rx6 + "," + y1 + " L" + x8 + "," + y1 + " L" + x8 + "," + y2 + " L" + rx5 + "," + y2 + " L" + rx4 + "," + y3 + " L" + x8 + "," + y3 + " L" + x8 + "," + y4 + " L" + rx3 + "," + y4 + " L" + drx + "," + dry + " L" + dlx + "," + dly + " L" + x3 + "," + y4 + " L" + x1 + "," + y4 + " L" + x1 + "," + y3 + " L" + x4 + "," + y3 + " L" + x5 + "," + y2 + " L" + x1 + "," + y2 + " z";
      } else if (shapType == "mathDivide") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
          adj2 = 5880 * slideFactor;
          adj3 = 11760 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
          adj2 = adj2 * slideFactor;
          adj3 = adj3 * slideFactor;
        }
        let a1, ma1, ma3h, ma3w, maxAdj3, a3, m4a3, maxAdj2, a2, dy1, yg, rad, dx1, y3, y4, a, y2, y1, y5, x1, x3, x2;
        let cnstVal4 = 1e3 * slideFactor;
        let cnstVal5 = 36745 * slideFactor;
        let cnstVal6 = 73490 * slideFactor;
        a1 = adj1 < cnstVal4 ? cnstVal4 : adj1 > cnstVal5 ? cnstVal5 : adj1;
        ma1 = -a1;
        ma3h = (cnstVal6 + ma1) / 4;
        ma3w = cnstVal5 * w / h;
        maxAdj3 = ma3h < ma3w ? ma3h : ma3w;
        a3 = adj3 < cnstVal4 ? cnstVal4 : adj3 > maxAdj3 ? maxAdj3 : adj3;
        m4a3 = -4 * a3;
        maxAdj2 = cnstVal6 + m4a3 - a1;
        a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
        dy1 = h * a1 / cnstVal3;
        yg = h * a2 / cnstVal2;
        rad = h * a3 / cnstVal2;
        dx1 = w * cnstVal6 / cnstVal3;
        y3 = vc - dy1;
        y4 = vc + dy1;
        a = yg + rad;
        y2 = y3 - a;
        y1 = y2 - rad;
        y5 = h - y1;
        x1 = hc - dx1;
        x3 = hc + dx1;
        x2 = hc - rad;
        let cd4 = 90, c3d4 = 270;
        let cX1 = hc - Math.cos(c3d4 * Math.PI / 180) * rad;
        let cY1 = y1 - Math.sin(c3d4 * Math.PI / 180) * rad;
        let cX2 = hc - Math.cos(Math.PI / 2) * rad;
        let cY2 = y5 - Math.sin(Math.PI / 2) * rad;
        dVal = "M" + hc + "," + y1 + shapeArc(cX1, cY1, rad, rad, c3d4, c3d4 + 360, false).replace("M", "L") + " z M" + hc + "," + y5 + shapeArc(cX2, cY2, rad, rad, cd4, cd4 + 360, false).replace("M", "L") + " z M" + x1 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + y4 + " L" + x1 + "," + y4 + " z";
      } else if (shapType == "mathEqual") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
          adj2 = 11760 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
          adj2 = adj2 * slideFactor;
        }
        let cnstVal5 = 36745 * slideFactor;
        let cnstVal6 = 73490 * slideFactor;
        let a1, a2a1, mAdj2, a2, dy1, dy2, dx1, y2, y3, y1, y4, x1, x2, yC1, yC2;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal5 ? cnstVal5 : adj1;
        a2a1 = a1 * 2;
        mAdj2 = cnstVal2 - a2a1;
        a2 = adj2 < 0 ? 0 : adj2 > mAdj2 ? mAdj2 : adj2;
        dy1 = h * a1 / cnstVal2;
        dy2 = h * a2 / cnstVal3;
        dx1 = w * cnstVal6 / cnstVal3;
        y2 = vc - dy2;
        y3 = vc + dy2;
        y1 = y2 - dy1;
        y4 = y3 + dy1;
        x1 = hc - dx1;
        x2 = hc + dx1;
        yC1 = (y1 + y2) / 2;
        yC2 = (y3 + y4) / 2;
        dVal = "M" + x1 + "," + y1 + " L" + x2 + "," + y1 + " L" + x2 + "," + y2 + " L" + x1 + "," + y2 + " zM" + x1 + "," + y3 + " L" + x2 + "," + y3 + " L" + x2 + "," + y4 + " L" + x1 + "," + y4 + " z";
      } else if (shapType == "mathMinus") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
        }
        let cnstVal6 = 73490 * slideFactor;
        let a1, dy1, dx1, y1, y2, x1, x2;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal2 ? cnstVal2 : adj1;
        dy1 = h * a1 / cnstVal3;
        dx1 = w * cnstVal6 / cnstVal3;
        y1 = vc - dy1;
        y2 = vc + dy1;
        x1 = hc - dx1;
        x2 = hc + dx1;
        dVal = "M" + x1 + "," + y1 + " L" + x2 + "," + y1 + " L" + x2 + "," + y2 + " L" + x1 + "," + y2 + " z";
      } else if (shapType == "mathMultiply") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
        }
        let cnstVal6 = 51965 * slideFactor;
        let a1, th, a, sa, ca, ta, dl, rw, lM, xM, yM, dxAM, dyAM, xA, yA, xB, yB, xBC, yBC, yC, xD, xE, yFE, xFE, xF, xL, yG, yH, yI, xC2, yC3;
        let ss = Math.min(w, h);
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal6 ? cnstVal6 : adj1;
        th = ss * a1 / cnstVal2;
        a = Math.atan(h / w);
        sa = 1 * Math.sin(a);
        ca = 1 * Math.cos(a);
        ta = 1 * Math.tan(a);
        dl = Math.sqrt(w * w + h * h);
        rw = dl * cnstVal6 / cnstVal2;
        lM = dl - rw;
        xM = ca * lM / 2;
        yM = sa * lM / 2;
        dxAM = sa * th / 2;
        dyAM = ca * th / 2;
        xA = xM - dxAM;
        yA = yM + dyAM;
        xB = xM + dxAM;
        yB = yM - dyAM;
        xBC = hc - xB;
        yBC = xBC * ta;
        yC = yBC + yB;
        xD = w - xB;
        xE = w - xA;
        yFE = vc - yA;
        xFE = yFE / ta;
        xF = xE - xFE;
        xL = xA + xFE;
        yG = h - yA;
        yH = h - yB;
        yI = h - yC;
        xC2 = w - xM;
        yC3 = h - yM;
        dVal = "M" + xA + "," + yA + " L" + xB + "," + yB + " L" + hc + "," + yC + " L" + xD + "," + yB + " L" + xE + "," + yA + " L" + xF + "," + vc + " L" + xE + "," + yG + " L" + xD + "," + yH + " L" + hc + "," + yI + " L" + xB + "," + yH + " L" + xA + "," + yG + " L" + xL + "," + vc + " z";
      } else if (shapType == "mathPlus") {
        if (shapAdjst_ary2 === void 0) {
          adj1 = 23520 * slideFactor;
        } else {
          adj1 = adj1 * slideFactor;
        }
        let cnstVal6 = 73490 * slideFactor;
        let ss = Math.min(w, h);
        let a1, dx1, dy1, dx2, x1, x2, x3, x4, y1, y2, y3, y4;
        a1 = adj1 < 0 ? 0 : adj1 > cnstVal6 ? cnstVal6 : adj1;
        dx1 = w * cnstVal6 / cnstVal3;
        dy1 = h * cnstVal6 / cnstVal3;
        dx2 = ss * a1 / cnstVal3;
        x1 = hc - dx1;
        x2 = hc - dx2;
        x3 = hc + dx2;
        x4 = hc + dx1;
        y1 = vc - dy1;
        y2 = vc - dx2;
        y3 = vc + dx2;
        y4 = vc + dy1;
        dVal = "M" + x1 + "," + y2 + " L" + x2 + "," + y2 + " L" + x2 + "," + y1 + " L" + x3 + "," + y1 + " L" + x3 + "," + y2 + " L" + x4 + "," + y2 + " L" + x4 + "," + y3 + " L" + x3 + "," + y3 + " L" + x3 + "," + y4 + " L" + x2 + "," + y4 + " L" + x2 + "," + y3 + " L" + x1 + "," + y3 + " z";
      }
      result += "<path d='" + dVal + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "can":
    case "flowChartMagneticDisk":
    case "flowChartMagneticDrum": {
      let shapAdjst = getTextByPathList(shapAdjstArr, ["attrs", "fmla"]);
      let adj = 25e3 * slideFactor;
      let cnstVal1 = 5e4 * slideFactor;
      let cnstVal2 = 2e5 * slideFactor;
      if (shapAdjst !== void 0) {
        adj = parseInt(shapAdjst.substr(4)) * slideFactor;
      }
      let ss = Math.min(w, h);
      let maxAdj, a, y1, y2, y3, dVal;
      if (shapType == "flowChartMagneticDisk" || shapType == "flowChartMagneticDrum") {
        adj = 5e4 * slideFactor;
      }
      maxAdj = cnstVal1 * h / ss;
      a = adj < 0 ? 0 : adj > maxAdj ? maxAdj : adj;
      y1 = ss * a / cnstVal2;
      y2 = y1 + y1;
      y3 = h - y1;
      let cd2 = 180, wd2 = w / 2;
      let tranglRott = "";
      if (shapType == "flowChartMagneticDrum") {
        tranglRott = "transform='rotate(90 " + w / 2 + "," + h / 2 + ")'";
      }
      dVal = shapeArc(wd2, y1, wd2, y1, 0, cd2, false) + shapeArc(wd2, y1, wd2, y1, cd2, cd2 + cd2, false).replace("M", "L") + " L" + w + "," + y3 + shapeArc(wd2, y3, wd2, y1, 0, cd2, false).replace("M", "L") + " L0," + y1;
      result += "<path " + tranglRott + " d='" + dVal + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "swooshArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let refr = slideFactor;
      let sAdj12, adj1 = 25e3 * refr;
      let sAdj22, adj2 = 16667 * refr;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * refr;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) * refr;
          }
        }
      }
      let cnstVal1 = 1 * refr;
      let cnstVal2 = 7e4 * refr;
      let cnstVal3 = 75e3 * refr;
      let cnstVal4 = 1e5 * refr;
      let ss = Math.min(w, h);
      let ssd8 = ss / 8;
      let hd6 = h / 6;
      let a1, maxAdj2, a2, ad1, ad2, xB, yB, alfa, dx0, xC, dx1, yF, xF, xE, yE, dy2, dy22, dy3, yD, dy4, yP1, xP1, dy5, yP2, xP2;
      a1 = adj1 < cnstVal1 ? cnstVal1 : adj1 > cnstVal3 ? cnstVal3 : adj1;
      maxAdj2 = cnstVal2 * w / ss;
      a2 = adj2 < 0 ? 0 : adj2 > maxAdj2 ? maxAdj2 : adj2;
      ad1 = h * a1 / cnstVal4;
      ad2 = ss * a2 / cnstVal4;
      xB = w - ad2;
      yB = ssd8;
      alfa = Math.PI / 2 / 14;
      dx0 = ssd8 * Math.tan(alfa);
      xC = xB - dx0;
      dx1 = ad1 * Math.tan(alfa);
      yF = yB + ad1;
      xF = xB + dx1;
      xE = xF + dx0;
      yE = yF + ssd8;
      dy2 = yE - 0;
      dy22 = dy2 / 2;
      dy3 = h / 20;
      yD = dy22 - dy3;
      dy4 = hd6;
      yP1 = hd6 + dy4;
      xP1 = w / 6;
      dy5 = hd6 / 2;
      yP2 = yF + dy5;
      xP2 = w / 4;
      let dVal = "M0," + h + " Q" + xP1 + "," + yP1 + " " + xB + "," + yB + " L" + xC + ",0 L" + w + "," + yD + " L" + xE + "," + yE + " L" + xF + "," + yF + " Q" + xP2 + "," + yP2 + " 0," + h + " z";
      result += "<path d='" + dVal + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "circularArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 12500 * slideFactor;
      let sAdj22, adj2 = 1142319 / 6e4 * Math.PI / 180;
      let sAdj3, adj3 = 20457681 / 6e4 * Math.PI / 180;
      let sAdj4, adj4 = 108e5 / 6e4 * Math.PI / 180;
      let sAdj5, adj5 = 12500 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj5") {
            sAdj5 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj5 = parseInt(sAdj5.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, r = w, b = h, l = 0, t = 0, wd2 = w / 2, hd2 = h / 2;
      let cd2 = 180;
      let ss = Math.min(w, h);
      let a5, maxAdj1, a1, enAng, stAng, th, thh, th2, rw1, rh1, rw2, rh2, rw3, rh3, wtH, htH, dxH, dyH, xH, yH, rI, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15, u16, u17, u18, u19, u20, u21, maxAng, aAng, ptAng, wtA, htA, dxA, dyA, xA, yA, wtE, htE, dxE, dyE, xE, yE, dxG, dyG, xG, yG, dxB, dyB, xB, yB, sx1, sy1, sx2, sy2, rO, x1O, y1O, x2O, y2O, dxO, dyO, dO, q1, q2, DO, q3, q4, q5, q6, q7, q8, sdelO, ndyO, sdyO, q9, q10, q11, dxF1, q12, dxF2, adyO, q13, q14, dyF1, q15, dyF2, q16, q17, q18, q19, q20, q21, q22, dxF, dyF, sdxF, sdyF, xF, yF, x1I, y1I, x2I, y2I, dxI, dyI, dI, v1, v2, DI, v3, v4, v5, v6, v7, v8, sdelI, v9, v10, v11, dxC1, v12, dxC2, adyI, v13, v14, dyC1, v15, dyC2, v16, v17, v18, v19, v20, v21, v22, dxC, dyC, sdxC, sdyC, xC, yC, ist0, ist1, istAng, isw1, isw2, iswAng, p1, p2, p3, p4, p5, xGp, yGp, xBp, yBp, en0, en1, en2, sw0, sw1, swAng;
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let rdAngVal1 = 1 / 6e4 * Math.PI / 180;
      let rdAngVal2 = 21599999 / 6e4 * Math.PI / 180;
      let rdAngVal3 = 2 * Math.PI;
      a5 = adj5 < 0 ? 0 : adj5 > cnstVal1 ? cnstVal1 : adj5;
      maxAdj1 = a5 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      enAng = adj3 < rdAngVal1 ? rdAngVal1 : adj3 > rdAngVal2 ? rdAngVal2 : adj3;
      stAng = adj4 < 0 ? 0 : adj4 > rdAngVal2 ? rdAngVal2 : adj4;
      th = ss * a1 / cnstVal2;
      thh = ss * a5 / cnstVal2;
      th2 = th / 2;
      rw1 = wd2 + th2 - thh;
      rh1 = hd2 + th2 - thh;
      rw2 = rw1 - th;
      rh2 = rh1 - th;
      rw3 = rw2 + th2;
      rh3 = rh2 + th2;
      wtH = rw3 * Math.sin(enAng);
      htH = rh3 * Math.cos(enAng);
      dxH = rw3 * Math.cos(Math.atan2(wtH, htH));
      dyH = rh3 * Math.sin(Math.atan2(wtH, htH));
      xH = hc + dxH;
      yH = vc + dyH;
      rI = rw2 < rh2 ? rw2 : rh2;
      u1 = dxH * dxH;
      u2 = dyH * dyH;
      u3 = rI * rI;
      u4 = u1 - u3;
      u5 = u2 - u3;
      u6 = u4 * u5 / u1;
      u7 = u6 / u2;
      u8 = 1 - u7;
      u9 = Math.sqrt(u8);
      u10 = u4 / dxH;
      u11 = u10 / dyH;
      u12 = (1 + u9) / u11;
      u13 = Math.atan2(u12, 1);
      u14 = u13 + rdAngVal3;
      u15 = u13 > 0 ? u13 : u14;
      u16 = u15 - enAng;
      u17 = u16 + rdAngVal3;
      u18 = u16 > 0 ? u16 : u17;
      u19 = u18 - cd2;
      u20 = u18 - rdAngVal3;
      u21 = u19 > 0 ? u20 : u18;
      maxAng = Math.abs(u21);
      aAng = adj2 < 0 ? 0 : adj2 > maxAng ? maxAng : adj2;
      ptAng = enAng + aAng;
      wtA = rw3 * Math.sin(ptAng);
      htA = rh3 * Math.cos(ptAng);
      dxA = rw3 * Math.cos(Math.atan2(wtA, htA));
      dyA = rh3 * Math.sin(Math.atan2(wtA, htA));
      xA = hc + dxA;
      yA = vc + dyA;
      wtE = rw1 * Math.sin(stAng);
      htE = rh1 * Math.cos(stAng);
      dxE = rw1 * Math.cos(Math.atan2(wtE, htE));
      dyE = rh1 * Math.sin(Math.atan2(wtE, htE));
      xE = hc + dxE;
      yE = vc + dyE;
      dxG = thh * Math.cos(ptAng);
      dyG = thh * Math.sin(ptAng);
      xG = xH + dxG;
      yG = yH + dyG;
      dxB = thh * Math.cos(ptAng);
      dyB = thh * Math.sin(ptAng);
      xB = xH - dxB;
      yB = yH - dyB;
      sx1 = xB - hc;
      sy1 = yB - vc;
      sx2 = xG - hc;
      sy2 = yG - vc;
      rO = rw1 < rh1 ? rw1 : rh1;
      x1O = sx1 * rO / rw1;
      y1O = sy1 * rO / rh1;
      x2O = sx2 * rO / rw1;
      y2O = sy2 * rO / rh1;
      dxO = x2O - x1O;
      dyO = y2O - y1O;
      dO = Math.sqrt(dxO * dxO + dyO * dyO);
      q1 = x1O * y2O;
      q2 = x2O * y1O;
      DO = q1 - q2;
      q3 = rO * rO;
      q4 = dO * dO;
      q5 = q3 * q4;
      q6 = DO * DO;
      q7 = q5 - q6;
      q8 = q7 > 0 ? q7 : 0;
      sdelO = Math.sqrt(q8);
      ndyO = dyO * -1;
      sdyO = ndyO > 0 ? -1 : 1;
      q9 = sdyO * dxO;
      q10 = q9 * sdelO;
      q11 = DO * dyO;
      dxF1 = (q11 + q10) / q4;
      q12 = q11 - q10;
      dxF2 = q12 / q4;
      adyO = Math.abs(dyO);
      q13 = adyO * sdelO;
      q14 = DO * dxO / -1;
      dyF1 = (q14 + q13) / q4;
      q15 = q14 - q13;
      dyF2 = q15 / q4;
      q16 = x2O - dxF1;
      q17 = x2O - dxF2;
      q18 = y2O - dyF1;
      q19 = y2O - dyF2;
      q20 = Math.sqrt(q16 * q16 + q18 * q18);
      q21 = Math.sqrt(q17 * q17 + q19 * q19);
      q22 = q21 - q20;
      dxF = q22 > 0 ? dxF1 : dxF2;
      dyF = q22 > 0 ? dyF1 : dyF2;
      sdxF = dxF * rw1 / rO;
      sdyF = dyF * rh1 / rO;
      xF = hc + sdxF;
      yF = vc + sdyF;
      x1I = sx1 * rI / rw2;
      y1I = sy1 * rI / rh2;
      x2I = sx2 * rI / rw2;
      y2I = sy2 * rI / rh2;
      dxI = x2I - x1I;
      dyI = y2I - y1I;
      dI = Math.sqrt(dxI * dxI + dyI * dyI);
      v1 = x1I * y2I;
      v2 = x2I * y1I;
      DI = v1 - v2;
      v3 = rI * rI;
      v4 = dI * dI;
      v5 = v3 * v4;
      v6 = DI * DI;
      v7 = v5 - v6;
      v8 = v7 > 0 ? v7 : 0;
      sdelI = Math.sqrt(v8);
      v9 = sdyO * dxI;
      v10 = v9 * sdelI;
      v11 = DI * dyI;
      dxC1 = (v11 + v10) / v4;
      v12 = v11 - v10;
      dxC2 = v12 / v4;
      adyI = Math.abs(dyI);
      v13 = adyI * sdelI;
      v14 = DI * dxI / -1;
      dyC1 = (v14 + v13) / v4;
      v15 = v14 - v13;
      dyC2 = v15 / v4;
      v16 = x1I - dxC1;
      v17 = x1I - dxC2;
      v18 = y1I - dyC1;
      v19 = y1I - dyC2;
      v20 = Math.sqrt(v16 * v16 + v18 * v18);
      v21 = Math.sqrt(v17 * v17 + v19 * v19);
      v22 = v21 - v20;
      dxC = v22 > 0 ? dxC1 : dxC2;
      dyC = v22 > 0 ? dyC1 : dyC2;
      sdxC = dxC * rw2 / rI;
      sdyC = dyC * rh2 / rI;
      xC = hc + sdxC;
      yC = vc + sdyC;
      ist0 = Math.atan2(sdyC, sdxC);
      ist1 = ist0 + rdAngVal3;
      istAng = ist0 > 0 ? ist0 : ist1;
      isw1 = stAng - istAng;
      isw2 = isw1 - rdAngVal3;
      iswAng = isw1 > 0 ? isw2 : isw1;
      p1 = xF - xC;
      p2 = yF - yC;
      p3 = Math.sqrt(p1 * p1 + p2 * p2);
      p4 = p3 / 2;
      p5 = p4 - thh;
      xGp = p5 > 0 ? xF : xG;
      yGp = p5 > 0 ? yF : yG;
      xBp = p5 > 0 ? xC : xB;
      yBp = p5 > 0 ? yC : yB;
      en0 = Math.atan2(sdyF, sdxF);
      en1 = en0 + rdAngVal3;
      en2 = en0 > 0 ? en0 : en1;
      sw0 = en2 - stAng;
      sw1 = sw0 + rdAngVal3;
      swAng = sw0 > 0 ? sw0 : sw1;
      let strtAng = stAng * 180 / Math.PI;
      let endAng = strtAng + swAng * 180 / Math.PI;
      let stiAng = istAng * 180 / Math.PI;
      let swiAng = iswAng * 180 / Math.PI;
      let ediAng = stiAng + swiAng;
      let d_val = shapeArc(w / 2, h / 2, rw1, rh1, strtAng, endAng, false) + " L" + xGp + "," + yGp + " L" + xA + "," + yA + " L" + xBp + "," + yBp + " L" + xC + "," + yC + shapeArc(w / 2, h / 2, rw2, rh2, stiAng, ediAng, false).replace("M", "L") + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftCircularArrow": {
      let shapAdjst_ary2 = shapAdjstArr;
      let sAdj12, adj1 = 12500 * slideFactor;
      let sAdj22, adj2 = -1142319 / 6e4 * Math.PI / 180;
      let sAdj3, adj3 = 1142319 / 6e4 * Math.PI / 180;
      let sAdj4, adj4 = 108e5 / 6e4 * Math.PI / 180;
      let sAdj5, adj5 = 12500 * slideFactor;
      if (shapAdjst_ary2 !== void 0) {
        for (var i = 0; i < shapAdjst_ary2.length; i++) {
          let sAdj_name = getTextByPathList(shapAdjst_ary2[i], ["attrs", "name"]);
          if (sAdj_name == "adj1") {
            sAdj12 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj1 = parseInt(sAdj12.substr(4)) * slideFactor;
          } else if (sAdj_name == "adj2") {
            sAdj22 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj2 = parseInt(sAdj22.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj3") {
            sAdj3 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj3 = parseInt(sAdj3.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj4") {
            sAdj4 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj4 = parseInt(sAdj4.substr(4)) / 6e4 * Math.PI / 180;
          } else if (sAdj_name == "adj5") {
            sAdj5 = getTextByPathList(shapAdjst_ary2[i], ["attrs", "fmla"]);
            adj5 = parseInt(sAdj5.substr(4)) * slideFactor;
          }
        }
      }
      let vc = h / 2, hc = w / 2, r = w, b = h, l = 0, t = 0, wd2 = w / 2, hd2 = h / 2, cd2 = 180;
      let ss = Math.min(w, h);
      let cnstVal1 = 25e3 * slideFactor;
      let cnstVal2 = 1e5 * slideFactor;
      let rdAngVal1 = 1 / 6e4 * Math.PI / 180;
      let rdAngVal2 = 21599999 / 6e4 * Math.PI / 180;
      let rdAngVal3 = 2 * Math.PI;
      let a5, maxAdj1, a1, enAng, stAng, th, thh, th2, rw1, rh1, rw2, rh2, rw3, rh3, wtH, htH, dxH, dyH, xH, yH, rI, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15, u16, u17, u18, u19, u20, u21, u22, minAng, u23, a2, aAng, ptAng, wtA, htA, dxA, dyA, xA, yA, wtE, htE, dxE, dyE, xE, yE, wtD, htD, dxD, dyD, xD, yD, dxG, dyG, xG, yG, dxB, dyB, xB, yB, sx1, sy1, sx2, sy2, rO, x1O, y1O, x2O, y2O, dxO, dyO, dO, q1, q2, DO, q3, q4, q5, q6, q7, q8, sdelO, ndyO, sdyO, q9, q10, q11, dxF1, q12, dxF2, adyO, q13, q14, dyF1, q15, dyF2, q16, q17, q18, q19, q20, q21, q22, dxF, dyF, sdxF, sdyF, xF, yF, x1I, y1I, x2I, y2I, dxI, dyI, dI, v1, v2, DI, v3, v4, v5, v6, v7, v8, sdelI, v9, v10, v11, dxC1, v12, dxC2, adyI, v13, v14, dyC1, v15, dyC2, v16, v17, v18, v19, v20, v21, v22, dxC, dyC, sdxC, sdyC, xC, yC, ist0, ist1, istAng0, isw1, isw2, iswAng0, istAng, iswAng, p1, p2, p3, p4, p5, xGp, yGp, xBp, yBp, en0, en1, en2, sw0, sw1, swAng, stAng0;
      a5 = adj5 < 0 ? 0 : adj5 > cnstVal1 ? cnstVal1 : adj5;
      maxAdj1 = a5 * 2;
      a1 = adj1 < 0 ? 0 : adj1 > maxAdj1 ? maxAdj1 : adj1;
      enAng = adj3 < rdAngVal1 ? rdAngVal1 : adj3 > rdAngVal2 ? rdAngVal2 : adj3;
      stAng = adj4 < 0 ? 0 : adj4 > rdAngVal2 ? rdAngVal2 : adj4;
      th = ss * a1 / cnstVal2;
      thh = ss * a5 / cnstVal2;
      th2 = th / 2;
      rw1 = wd2 + th2 - thh;
      rh1 = hd2 + th2 - thh;
      rw2 = rw1 - th;
      rh2 = rh1 - th;
      rw3 = rw2 + th2;
      rh3 = rh2 + th2;
      wtH = rw3 * Math.sin(enAng);
      htH = rh3 * Math.cos(enAng);
      dxH = rw3 * Math.cos(Math.atan2(wtH, htH));
      dyH = rh3 * Math.sin(Math.atan2(wtH, htH));
      xH = hc + dxH;
      yH = vc + dyH;
      rI = rw2 < rh2 ? rw2 : rh2;
      u1 = dxH * dxH;
      u2 = dyH * dyH;
      u3 = rI * rI;
      u4 = u1 - u3;
      u5 = u2 - u3;
      u6 = u4 * u5 / u1;
      u7 = u6 / u2;
      u8 = 1 - u7;
      u9 = Math.sqrt(u8);
      u10 = u4 / dxH;
      u11 = u10 / dyH;
      u12 = (1 + u9) / u11;
      u13 = Math.atan2(u12, 1);
      u14 = u13 + rdAngVal3;
      u15 = u13 > 0 ? u13 : u14;
      u16 = u15 - enAng;
      u17 = u16 + rdAngVal3;
      u18 = u16 > 0 ? u16 : u17;
      u19 = u18 - cd2;
      u20 = u18 - rdAngVal3;
      u21 = u19 > 0 ? u20 : u18;
      u22 = Math.abs(u21);
      minAng = u22 * -1;
      u23 = Math.abs(adj2);
      a2 = u23 * -1;
      aAng = a2 < minAng ? minAng : a2 > 0 ? 0 : a2;
      ptAng = enAng + aAng;
      wtA = rw3 * Math.sin(ptAng);
      htA = rh3 * Math.cos(ptAng);
      dxA = rw3 * Math.cos(Math.atan2(wtA, htA));
      dyA = rh3 * Math.sin(Math.atan2(wtA, htA));
      xA = hc + dxA;
      yA = vc + dyA;
      wtE = rw1 * Math.sin(stAng);
      htE = rh1 * Math.cos(stAng);
      dxE = rw1 * Math.cos(Math.atan2(wtE, htE));
      dyE = rh1 * Math.sin(Math.atan2(wtE, htE));
      xE = hc + dxE;
      yE = vc + dyE;
      wtD = rw2 * Math.sin(stAng);
      htD = rh2 * Math.cos(stAng);
      dxD = rw2 * Math.cos(Math.atan2(wtD, htD));
      dyD = rh2 * Math.sin(Math.atan2(wtD, htD));
      xD = hc + dxD;
      yD = vc + dyD;
      dxG = thh * Math.cos(ptAng);
      dyG = thh * Math.sin(ptAng);
      xG = xH + dxG;
      yG = yH + dyG;
      dxB = thh * Math.cos(ptAng);
      dyB = thh * Math.sin(ptAng);
      xB = xH - dxB;
      yB = yH - dyB;
      sx1 = xB - hc;
      sy1 = yB - vc;
      sx2 = xG - hc;
      sy2 = yG - vc;
      rO = rw1 < rh1 ? rw1 : rh1;
      x1O = sx1 * rO / rw1;
      y1O = sy1 * rO / rh1;
      x2O = sx2 * rO / rw1;
      y2O = sy2 * rO / rh1;
      dxO = x2O - x1O;
      dyO = y2O - y1O;
      dO = Math.sqrt(dxO * dxO + dyO * dyO);
      q1 = x1O * y2O;
      q2 = x2O * y1O;
      DO = q1 - q2;
      q3 = rO * rO;
      q4 = dO * dO;
      q5 = q3 * q4;
      q6 = DO * DO;
      q7 = q5 - q6;
      q8 = q7 > 0 ? q7 : 0;
      sdelO = Math.sqrt(q8);
      ndyO = dyO * -1;
      sdyO = ndyO > 0 ? -1 : 1;
      q9 = sdyO * dxO;
      q10 = q9 * sdelO;
      q11 = DO * dyO;
      dxF1 = (q11 + q10) / q4;
      q12 = q11 - q10;
      dxF2 = q12 / q4;
      adyO = Math.abs(dyO);
      q13 = adyO * sdelO;
      q14 = DO * dxO / -1;
      dyF1 = (q14 + q13) / q4;
      q15 = q14 - q13;
      dyF2 = q15 / q4;
      q16 = x2O - dxF1;
      q17 = x2O - dxF2;
      q18 = y2O - dyF1;
      q19 = y2O - dyF2;
      q20 = Math.sqrt(q16 * q16 + q18 * q18);
      q21 = Math.sqrt(q17 * q17 + q19 * q19);
      q22 = q21 - q20;
      dxF = q22 > 0 ? dxF1 : dxF2;
      dyF = q22 > 0 ? dyF1 : dyF2;
      sdxF = dxF * rw1 / rO;
      sdyF = dyF * rh1 / rO;
      xF = hc + sdxF;
      yF = vc + sdyF;
      x1I = sx1 * rI / rw2;
      y1I = sy1 * rI / rh2;
      x2I = sx2 * rI / rw2;
      y2I = sy2 * rI / rh2;
      dxI = x2I - x1I;
      dyI = y2I - y1I;
      dI = Math.sqrt(dxI * dxI + dyI * dyI);
      v1 = x1I * y2I;
      v2 = x2I * y1I;
      DI = v1 - v2;
      v3 = rI * rI;
      v4 = dI * dI;
      v5 = v3 * v4;
      v6 = DI * DI;
      v7 = v5 - v6;
      v8 = v7 > 0 ? v7 : 0;
      sdelI = Math.sqrt(v8);
      v9 = sdyO * dxI;
      v10 = v9 * sdelI;
      v11 = DI * dyI;
      dxC1 = (v11 + v10) / v4;
      v12 = v11 - v10;
      dxC2 = v12 / v4;
      adyI = Math.abs(dyI);
      v13 = adyI * sdelI;
      v14 = DI * dxI / -1;
      dyC1 = (v14 + v13) / v4;
      v15 = v14 - v13;
      dyC2 = v15 / v4;
      v16 = x1I - dxC1;
      v17 = x1I - dxC2;
      v18 = y1I - dyC1;
      v19 = y1I - dyC2;
      v20 = Math.sqrt(v16 * v16 + v18 * v18);
      v21 = Math.sqrt(v17 * v17 + v19 * v19);
      v22 = v21 - v20;
      dxC = v22 > 0 ? dxC1 : dxC2;
      dyC = v22 > 0 ? dyC1 : dyC2;
      sdxC = dxC * rw2 / rI;
      sdyC = dyC * rh2 / rI;
      xC = hc + sdxC;
      yC = vc + sdyC;
      ist0 = Math.atan2(sdyC, sdxC);
      ist1 = ist0 + rdAngVal3;
      istAng0 = ist0 > 0 ? ist0 : ist1;
      isw1 = stAng - istAng0;
      isw2 = isw1 + rdAngVal3;
      iswAng0 = isw1 > 0 ? isw1 : isw2;
      istAng = istAng0 + iswAng0;
      iswAng = -iswAng0;
      p1 = xF - xC;
      p2 = yF - yC;
      p3 = Math.sqrt(p1 * p1 + p2 * p2);
      p4 = p3 / 2;
      p5 = p4 - thh;
      xGp = p5 > 0 ? xF : xG;
      yGp = p5 > 0 ? yF : yG;
      xBp = p5 > 0 ? xC : xB;
      yBp = p5 > 0 ? yC : yB;
      en0 = Math.atan2(sdyF, sdxF);
      en1 = en0 + rdAngVal3;
      en2 = en0 > 0 ? en0 : en1;
      sw0 = en2 - stAng;
      sw1 = sw0 - rdAngVal3;
      swAng = sw0 > 0 ? sw1 : sw0;
      stAng0 = stAng + swAng;
      let strtAng = stAng0 * 180 / Math.PI;
      let endAng = stAng * 180 / Math.PI;
      let stiAng = istAng * 180 / Math.PI;
      let swiAng = iswAng * 180 / Math.PI;
      let ediAng = stiAng + swiAng;
      let d_val = "M" + xE + "," + yE + " L" + xD + "," + yD + shapeArc(w / 2, h / 2, rw2, rh2, stiAng, ediAng, false).replace("M", "L") + " L" + xBp + "," + yBp + " L" + xA + "," + yA + " L" + xGp + "," + yGp + " L" + xF + "," + yF + shapeArc(w / 2, h / 2, rw1, rh1, strtAng, endAng, false).replace("M", "L") + " z";
      result += "<path d='" + d_val + "' fill='" + fill + "' stroke='" + border.color + "' stroke-width='" + border.width + "' stroke-dasharray='" + border.strokeDasharray + "' />";
      break;
    }
    case "leftRightCircularArrow":
    case "chartPlus":
    case "chartStar":
    case "chartX":
    case "cornerTabs":
    case "flowChartOfflineStorage":
    case "folderCorner":
    case "funnel":
    case "lineInv":
    case "nonIsoscelesTrapezoid":
    case "plaqueTabs":
    case "squareTabs":
    case "upDownArrowCallout": {
      console.log(shapType, " -unsupported shape type.");
      break;
    }
    case void 0:
    default: {
      console.warn("Undefine shape type.(" + shapType + ")");
      break;
    }
  }
  return result;
};

// src/helpers/pptx/utils/file.ts
var urlRegex = /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/;
var isVideoLink = (vdoFile) => {
  return urlRegex.test(vdoFile);
};
var extractFileExtension = (filename) => {
  var _a;
  return (_a = filename == null ? void 0 : filename.slice((filename == null ? void 0 : filename.lastIndexOf(".")) + 1)) == null ? void 0 : _a.toLowerCase();
};
var getMimeType = (imgFileExt) => {
  let mimeType = "";
  switch (imgFileExt == null ? void 0 : imgFileExt.toLowerCase()) {
    case "jpg":
    case "jpeg":
      mimeType = "image/jpeg";
      break;
    case "png":
      mimeType = "image/png";
      break;
    case "gif":
      mimeType = "image/gif";
      break;
    case "emf":
      mimeType = "image/x-emf";
      break;
    case "wmf":
      mimeType = "image/x-wmf";
      break;
    case "svg":
      mimeType = "image/svg+xml";
      break;
    case "mp4":
      mimeType = "video/mp4";
      break;
    case "webm":
      mimeType = "video/webm";
      break;
    case "ogg":
      mimeType = "video/ogg";
      break;
    case "avi":
      mimeType = "video/avi";
      break;
    case "mpg":
      mimeType = "video/mpg";
      break;
    case "wmv":
      mimeType = "video/wmv";
      break;
    case "mp3":
      mimeType = "audio/mpeg";
      break;
    case "wav":
      mimeType = "audio/wav";
      break;
    // case "emf":
    //     mimeType = "image/emf";
    //     break;
    // case "wmf":
    //     mimeType = "image/wmf";
    //     break;
    case "tif":
    case "tiff":
      mimeType = "image/tiff";
      break;
  }
  return mimeType;
};

// src/helpers/pptx/utils/color.ts


var applyShade = (rgbStr, shadeValue, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  const adjustedShade = Math.min(shadeValue, 1);
  const calcL = Math.min(color.l * adjustedShade, 1);
  return isAlpha ? _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex();
};
var applyTint = (rgbStr, tintValue, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  const adjustedTint = Math.min(tintValue, 1);
  const calcL = color.l * adjustedTint + (1 - adjustedTint);
  return isAlpha ? _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex();
};
var applyLumOff = (rgbStr, offset, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  const lum = Math.min(offset + color.l, 1);
  return isAlpha ? _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: lum, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: lum, a: color.a }).toHex();
};
var applyLumMod = (rgbStr, multiplier, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  const calcL = Math.min(color.l * multiplier, 1);
  return isAlpha ? _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: color.h, s: color.s, l: calcL, a: color.a }).toHex();
};
var applyHueMod = (rgbStr, multiplier, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  let calcH = color.h * multiplier;
  calcH = calcH >= 360 ? calcH - 360 : calcH;
  return isAlpha ? _tinycolor22.default.call(void 0, { h: calcH, s: color.s, l: color.l, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: calcH, s: color.s, l: color.l, a: color.a }).toHex();
};
var applySatMod = (rgbStr, multiplier, isAlpha) => {
  const color = _tinycolor22.default.call(void 0, rgbStr).toHsl();
  const calcS = Math.min(color.s * multiplier, 1);
  return isAlpha ? _tinycolor22.default.call(void 0, { h: color.h, s: calcS, l: color.l, a: color.a }).toHex8() : _tinycolor22.default.call(void 0, { h: color.h, s: calcS, l: color.l, a: color.a }).toHex();
};
var angleToDegrees = (angle) => {
  if (_2.isEmpty(angle) || _2.isNil(angle)) {
    return 0;
  }
  return Math.round(Number(angle) / 6e4);
};
var colorMap = /* @__PURE__ */ new Map([
  ["white", "ffffff"],
  ["AliceBlue", "f0f8ff"],
  ["AntiqueWhite", "faebd7"],
  ["Aqua", "00ffff"],
  ["Aquamarine", "7fffd4"],
  ["Azure", "f0ffff"],
  ["Beige", "f5f5dc"],
  ["Bisque", "ffe4c4"],
  ["black", "000000"],
  ["BlanchedAlmond", "ffebcd"],
  ["Blue", "0000ff"],
  ["BlueViolet", "8a2be2"],
  ["Brown", "a52a2a"],
  ["BurlyWood", "deb887"],
  ["CadetBlue", "5f9ea0"],
  ["Chartreuse", "7fff00"],
  ["Chocolate", "d2691e"],
  ["Coral", "ff7f50"],
  ["CornflowerBlue", "6495ed"],
  ["Cornsilk", "fff8dc"],
  ["Crimson", "dc143c"],
  ["Cyan", "00ffff"],
  ["DarkBlue", "00008b"],
  ["DarkCyan", "008b8b"],
  ["DarkGoldenRod", "b8860b"],
  ["DarkGray", "a9a9a9"],
  ["DarkGrey", "a9a9a9"],
  ["DarkGreen", "006400"],
  ["DarkKhaki", "bdb76b"],
  ["DarkMagenta", "8b008b"],
  ["DarkOliveGreen", "556b2f"],
  ["DarkOrange", "ff8c00"],
  ["DarkOrchid", "9932cc"],
  ["DarkRed", "8b0000"],
  ["DarkSalmon", "e9967a"],
  ["DarkSeaGreen", "8fbc8f"],
  ["DarkSlateBlue", "483d8b"],
  ["DarkSlateGray", "2f4f4f"],
  ["DarkSlateGrey", "2f4f4f"],
  ["DarkTurquoise", "00ced1"],
  ["DarkViolet", "9400d3"],
  ["DeepPink", "ff1493"],
  ["DeepSkyBlue", "00bfff"],
  ["DimGray", "696969"],
  ["DimGrey", "696969"],
  ["DodgerBlue", "1e90ff"],
  ["FireBrick", "b22222"],
  ["FloralWhite", "fffaf0"],
  ["ForestGreen", "228b22"],
  ["Fuchsia", "ff00ff"],
  ["Gainsboro", "dcdcdc"],
  ["GhostWhite", "f8f8ff"],
  ["Gold", "ffd700"],
  ["GoldenRod", "daa520"],
  ["Gray", "808080"],
  ["Grey", "808080"],
  ["Green", "008000"],
  ["GreenYellow", "adff2f"],
  ["HoneyDew", "f0fff0"],
  ["HotPink", "ff69b4"],
  ["IndianRed", "cd5c5c"],
  ["Indigo", "4b0082"],
  ["Ivory", "fffff0"],
  ["Khaki", "f0e68c"],
  ["Lavender", "e6e6fa"],
  ["LavenderBlush", "fff0f5"],
  ["LawnGreen", "7cfc00"],
  ["LemonChiffon", "fffacd"],
  ["LightBlue", "add8e6"],
  ["LightCoral", "f08080"],
  ["LightCyan", "e0ffff"],
  ["LightGoldenRodYellow", "fafad2"],
  ["LightGray", "d3d3d3"],
  ["LightGrey", "d3d3d3"],
  ["LightGreen", "90ee90"],
  ["LightPink", "ffb6c1"],
  ["LightSalmon", "ffa07a"],
  ["LightSeaGreen", "20b2aa"],
  ["LightSkyBlue", "87cefa"],
  ["LightSlateGray", "778899"],
  ["LightSlateGrey", "778899"],
  ["LightSteelBlue", "b0c4de"],
  ["LightYellow", "ffffe0"],
  ["Lime", "00ff00"],
  ["LimeGreen", "32cd32"],
  ["Linen", "faf0e6"],
  ["Magenta", "ff00ff"],
  ["Maroon", "800000"],
  ["MediumAquaMarine", "66cdaa"],
  ["MediumBlue", "0000cd"],
  ["MediumOrchid", "ba55d3"],
  ["MediumPurple", "9370db"],
  ["MediumSeaGreen", "3cb371"],
  ["MediumSlateBlue", "7b68ee"],
  ["MediumSpringGreen", "00fa9a"],
  ["MediumTurquoise", "48d1cc"],
  ["MediumVioletRed", "c71585"],
  ["MidnightBlue", "191970"],
  ["MintCream", "f5fffa"],
  ["MistyRose", "ffe4e1"],
  ["Moccasin", "ffe4b5"],
  ["NavajoWhite", "ffdead"],
  ["Navy", "000080"],
  ["OldLace", "fdf5e6"],
  ["Olive", "808000"],
  ["OliveDrab", "6b8e23"],
  ["Orange", "ffa500"],
  ["OrangeRed", "ff4500"],
  ["Orchid", "da70d6"],
  ["PaleGoldenRod", "eee8aa"],
  ["PaleGreen", "98fb98"],
  ["PaleTurquoise", "afeeee"],
  ["PaleVioletRed", "db7093"],
  ["PapayaWhip", "ffefd5"],
  ["PeachPuff", "ffdab9"],
  ["Peru", "cd853f"],
  ["Pink", "ffc0cb"],
  ["Plum", "dda0dd"],
  ["PowderBlue", "b0e0e6"],
  ["Purple", "800080"],
  ["RebeccaPurple", "663399"],
  ["Red", "ff0000"],
  ["RosyBrown", "bc8f8f"],
  ["RoyalBlue", "4169e1"],
  ["SaddleBrown", "8b4513"],
  ["Salmon", "fa8072"],
  ["SandyBrown", "f4a460"],
  ["SeaGreen", "2e8b57"],
  ["SeaShell", "fff5ee"],
  ["Sienna", "a0522d"],
  ["Silver", "c0c0c0"],
  ["SkyBlue", "87ceeb"],
  ["SlateBlue", "6a5acd"],
  ["SlateGray", "708090"],
  ["SlateGrey", "708090"],
  ["Snow", "fffafa"],
  ["SpringGreen", "00ff7f"],
  ["SteelBlue", "4682b4"],
  ["Tan", "d2b48c"],
  ["Teal", "008080"],
  ["Thistle", "d8bfd8"],
  ["Tomato", "ff6347"],
  ["Turquoise", "40e0d0"],
  ["Violet", "ee82ee"],
  ["Wheat", "f5deb3"],
  ["White", "ffffff"],
  ["WhiteSmoke", "f5f5f5"],
  ["Yellow", "ffff00"],
  ["YellowGreen", "9acd32"]
]);
var rtlLangs = ["he-IL", "ar-AE", "ar-SA", "dv-MV", "fa-IR", "ur-PK"];
var toHex = (n) => {
  let hex = n.toString(16);
  while (hex.length < 2) {
    hex = "0" + hex;
  }
  return hex;
};
var hslToRgb = (hue, sat, light) => {
  let t1, t2, r, g, b;
  hue = hue / 60;
  if (light <= 0.5) {
    t2 = light * (sat + 1);
  } else {
    t2 = light + sat - light * sat;
  }
  t1 = light * 2 - t2;
  r = hueToRgb(t1, t2, hue + 2) * 255;
  g = hueToRgb(t1, t2, hue) * 255;
  b = hueToRgb(t1, t2, hue - 2) * 255;
  return { r, g, b };
};
var hueToRgb = (t1, t2, hue) => {
  if (hue < 0) hue += 6;
  if (hue >= 6) hue -= 6;
  if (hue < 1) return (t2 - t1) * hue + t1;
  else if (hue < 3) return t2;
  else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;
  else return t1;
};

// src/helpers/pptx/utils/shape/genCustShape.ts
var genCustShape = (moveToNode, lnToNodes, cubicBezToNodes, arcToNodes, closeNode, cX, cY, fill, border) => {
  var _a;
  let result = "";
  let multiSapeAry = [];
  if (moveToNode.length > 0) {
    Object.keys(moveToNode).forEach((key) => {
      let moveToPtNode = moveToNode[key]["a:pt"];
      if (moveToPtNode !== void 0) {
        if (!Array.isArray(moveToPtNode)) {
          moveToPtNode = [moveToPtNode];
        }
        Object.keys(moveToPtNode).forEach(function(key2) {
          var _a2, _b, _c;
          let ptObj = {};
          let moveToNoPt = moveToPtNode[key2];
          let spX = (_a2 = moveToNoPt["attrs"]) == null ? void 0 : _a2["x"];
          let spY = (_b = moveToNoPt["attrs"]) == null ? void 0 : _b["y"];
          let ptOrdr = (_c = moveToNoPt["attrs"]) == null ? void 0 : _c["order"];
          ptObj.type = "movto";
          ptObj.order = ptOrdr;
          ptObj.x = spX;
          ptObj.y = spY;
          multiSapeAry.push(ptObj);
        });
      }
    });
    if (lnToNodes !== void 0) {
      Object.keys(lnToNodes).forEach((key) => {
        let lnToPtNode = lnToNodes[key]["a:pt"];
        if (lnToPtNode !== void 0) {
          if (!Array.isArray(lnToPtNode)) {
            lnToPtNode = [lnToPtNode];
          }
          Object.keys(lnToPtNode).forEach(function(key2) {
            var _a2, _b, _c;
            let ptObj = {};
            let lnToNoPt = lnToPtNode[key2];
            let ptX = (_a2 = lnToNoPt["attrs"]) == null ? void 0 : _a2["x"];
            let ptY = (_b = lnToNoPt["attrs"]) == null ? void 0 : _b["y"];
            let ptOrdr = (_c = lnToNoPt["attrs"]) == null ? void 0 : _c["order"];
            ptObj.type = "lnto";
            ptObj.order = ptOrdr;
            ptObj.x = ptX;
            ptObj.y = ptY;
            multiSapeAry.push(ptObj);
          });
        }
      });
    }
    if (cubicBezToNodes !== void 0) {
      let cubicBezToPtNodesAry = [];
      if (!Array.isArray(cubicBezToNodes)) {
        cubicBezToNodes = [cubicBezToNodes];
      }
      Object.keys(cubicBezToNodes).forEach((key) => {
        cubicBezToPtNodesAry.push(cubicBezToNodes[key]["a:pt"]);
      });
      cubicBezToPtNodesAry.forEach(function(key2) {
        var _a2;
        let nodeObj = {};
        nodeObj.type = "cubicBezTo";
        nodeObj.order = (_a2 = key2[0]["attrs"]) == null ? void 0 : _a2["order"];
        let pts_ary = [];
        key2.forEach(function(pt) {
          var _a3, _b;
          let pt_obj = {
            x: (_a3 = pt["attrs"]) == null ? void 0 : _a3["x"],
            y: (_b = pt["attrs"]) == null ? void 0 : _b["y"]
          };
          pts_ary.push(pt_obj);
        });
        nodeObj.cubBzPt = pts_ary;
        multiSapeAry.push(nodeObj);
      });
    }
    if (arcToNodes !== void 0) {
      let arcToNodesAttrs = (_a = arcToNodes["attrs"]) != null ? _a : {};
      let arcOrder = arcToNodesAttrs["order"];
      let hR = arcToNodesAttrs["hR"];
      let wR = arcToNodesAttrs["wR"];
      let stAng = arcToNodesAttrs["stAng"];
      let swAng = arcToNodesAttrs["swAng"];
      let shftX = 0;
      let shftY = 0;
      let arcToPtNode = getTextByPathList(arcToNodes, ["a:pt", "attrs"]);
      if (arcToPtNode !== void 0) {
        shftX = arcToPtNode["x"];
        shftY = arcToPtNode["y"];
      }
      let ptObj = {};
      ptObj.type = "arcTo";
      ptObj.order = arcOrder;
      ptObj.hR = hR;
      ptObj.wR = wR;
      ptObj.stAng = stAng;
      ptObj.swAng = swAng;
      ptObj.shftX = shftX;
      ptObj.shftY = shftY;
      multiSapeAry.push(ptObj);
    }
    if (closeNode !== void 0) {
      if (!Array.isArray(closeNode)) {
        closeNode = [closeNode];
      }
      Object.keys(closeNode).forEach((key) => {
        var _a2;
        let clsAttrs = (_a2 = closeNode[key]["attrs"]) != null ? _a2 : {};
        let clsOrder = clsAttrs["order"];
        let ptObj = {};
        ptObj.type = "close";
        ptObj.order = clsOrder;
        multiSapeAry.push(ptObj);
      });
    }
    multiSapeAry.sort(function(a, b) {
      return a.order - b.order;
    });
    let k = 0;
    let isClose = false;
    let d = "";
    while (k < multiSapeAry.length) {
      if (multiSapeAry[k].type == "movto") {
        let spX = parseInt(multiSapeAry[k].x) * cX;
        let spY = parseInt(multiSapeAry[k].y) * cY;
        d += " M" + spX + "," + spY;
      } else if (multiSapeAry[k].type == "lnto") {
        let Lx = parseInt(multiSapeAry[k].x) * cX;
        let Ly = parseInt(multiSapeAry[k].y) * cY;
        d += " L" + Lx + "," + Ly;
      } else if (multiSapeAry[k].type == "cubicBezTo") {
        let Cx1 = parseInt(multiSapeAry[k].cubBzPt[0].x) * cX;
        let Cy1 = parseInt(multiSapeAry[k].cubBzPt[0].y) * cY;
        let Cx2 = parseInt(multiSapeAry[k].cubBzPt[1].x) * cX;
        let Cy2 = parseInt(multiSapeAry[k].cubBzPt[1].y) * cY;
        let Cx3 = parseInt(multiSapeAry[k].cubBzPt[2].x) * cX;
        let Cy3 = parseInt(multiSapeAry[k].cubBzPt[2].y) * cY;
        d += " C" + Cx1 + "," + Cy1 + " " + Cx2 + "," + Cy2 + " " + Cx3 + "," + Cy3;
      } else if (multiSapeAry[k].type == "arcTo") {
        let hR = parseInt(multiSapeAry[k].hR) * cX;
        let wR = parseInt(multiSapeAry[k].wR) * cY;
        let stAng = parseInt(multiSapeAry[k].stAng) / 6e4;
        let swAng = parseInt(multiSapeAry[k].swAng) / 6e4;
        let endAng = stAng + swAng;
        d += shapeArc(wR, hR, wR, hR, stAng, endAng, false);
      } else if (multiSapeAry[k].type == "quadBezTo") {
        console.log("custShapType: quadBezTo - TODO");
      } else if (multiSapeAry[k].type == "close") {
        d += "z";
      }
      k++;
    }
    result += "<path d='" + d + "' fill='" + fill + "' stroke='" + (border === void 0 ? "" : border.color) + "' stroke-width='" + (border === void 0 ? "" : border.width) + "' stroke-dasharray='" + (border === void 0 ? "" : border.strokeDasharray) + "' ";
    result += "/>";
    return result;
  }
};

// src/helpers/pptx/Slide.ts
var Slide = class {
  constructor(options) {
    this.options = {
      processFullTheme: true,
      mediaProcess: false,
      slideFactor: 96 / 914400,
      fontSizeFactor: 4 / 3.2
    };
    this.isFirstBr = false;
    this.MsgQueue = [];
    this.postRenderDone = false;
    _2.default.assign(this.options, options);
  }
  readXmlFile(filename) {
    return __async(this, null, function* () {
      var _a;
      return (_a = this.options.resourceReader) == null ? void 0 : _a.readXmlFile(filename);
    });
  }
  processSingleSlide() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J;
      const sldFileName = this.options.fileName;
      const index = this.options.index;
      if (!sldFileName || !index) return "";
      let resName = sldFileName.replace("slides/slide", "slides/_rels/slide") + ".rels";
      let resContent = yield this.readXmlFile(resName);
      let RelationshipArray = resContent["Relationships"]["Relationship"];
      let layoutFilename = "";
      let diagramFilename = "";
      let slideResObj = {};
      if (RelationshipArray.constructor === Array) {
        for (var i = 0; i < RelationshipArray.length; i++) {
          switch ((_a = RelationshipArray[i]["attrs"]) == null ? void 0 : _a["Type"]) {
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout":
              layoutFilename = (_b = RelationshipArray[i]["attrs"]) == null ? void 0 : _b["Target"].replace("../", "ppt/");
              break;
            case "http://schemas.microsoft.com/office/2007/relationships/diagramDrawing":
              diagramFilename = (_c = RelationshipArray[i]["attrs"]) == null ? void 0 : _c["Target"].replace("../", "ppt/");
              slideResObj[(_d = RelationshipArray[i]["attrs"]) == null ? void 0 : _d["Id"]] = {
                "type": (_e = RelationshipArray[i]["attrs"]) == null ? void 0 : _e["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_f = RelationshipArray[i]["attrs"]) == null ? void 0 : _f["Target"].replace("../", "ppt/")
              };
              break;
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide":
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image":
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart":
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink":
            default:
              slideResObj[(_g = RelationshipArray[i]["attrs"]) == null ? void 0 : _g["Id"]] = {
                "type": (_h = RelationshipArray[i]["attrs"]) == null ? void 0 : _h["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_i = RelationshipArray[i]["attrs"]) == null ? void 0 : _i["Target"].replace("../", "ppt/")
              };
          }
        }
      } else {
        layoutFilename = (_j = RelationshipArray["attrs"]) == null ? void 0 : _j["Target"].replace("../", "ppt/");
      }
      let slideLayoutContent = yield this.readXmlFile(layoutFilename);
      let slideLayoutTables = this.indexNodes(slideLayoutContent);
      let sldLayoutClrOvr = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:clrMapOvr", "a:overrideClrMapping"]);
      if (sldLayoutClrOvr !== void 0) {
      }
      let slideLayoutResFilename = layoutFilename.replace("slideLayouts/slideLayout", "slideLayouts/_rels/slideLayout") + ".rels";
      let slideLayoutResContent = yield this.readXmlFile(slideLayoutResFilename);
      RelationshipArray = slideLayoutResContent["Relationships"]["Relationship"];
      let masterFilename = "";
      let layoutResObj = {};
      if (RelationshipArray.constructor === Array) {
        for (var i = 0; i < RelationshipArray.length; i++) {
          switch ((_k = RelationshipArray[i]["attrs"]) == null ? void 0 : _k["Type"]) {
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster":
              masterFilename = (_l = RelationshipArray[i]["attrs"]) == null ? void 0 : _l["Target"].replace("../", "ppt/");
              break;
            default:
              layoutResObj[(_m = RelationshipArray[i]["attrs"]) == null ? void 0 : _m["Id"]] = {
                "type": (_n = RelationshipArray[i]["attrs"]) == null ? void 0 : _n["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_o = RelationshipArray[i]["attrs"]) == null ? void 0 : _o["Target"].replace("../", "ppt/")
              };
          }
        }
      } else {
        masterFilename = (_p = RelationshipArray["attrs"]) == null ? void 0 : _p["Target"].replace("../", "ppt/");
      }
      let slideMasterResFilename = masterFilename.replace("slideMasters/slideMaster", "slideMasters/_rels/slideMaster") + ".rels";
      const [slideContent, slideMasterContent, slideMasterResContent] = yield Promise.all([
        this.readXmlFile(sldFileName),
        // Open slideMasterXX.xml
        this.readXmlFile(masterFilename),
        //Open slideMasterXX.xml.rels
        this.readXmlFile(slideMasterResFilename)
      ]);
      let slideMasterTextStyles = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:txStyles"]);
      let slideMasterTables = this.indexNodes(slideMasterContent);
      RelationshipArray = slideMasterResContent["Relationships"]["Relationship"];
      let themeFilename = "";
      let masterResObj = {};
      if (RelationshipArray.constructor === Array) {
        for (var i = 0; i < RelationshipArray.length; i++) {
          switch ((_q = RelationshipArray[i]["attrs"]) == null ? void 0 : _q["Type"]) {
            case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme":
              themeFilename = (_r = RelationshipArray[i]["attrs"]) == null ? void 0 : _r["Target"].replace("../", "ppt/");
              break;
            default:
              masterResObj[(_s = RelationshipArray[i]["attrs"]) == null ? void 0 : _s["Id"]] = {
                "type": (_t = RelationshipArray[i]["attrs"]) == null ? void 0 : _t["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_u = RelationshipArray[i]["attrs"]) == null ? void 0 : _u["Target"].replace("../", "ppt/")
              };
          }
        }
      } else {
        themeFilename = (_v = RelationshipArray["attrs"]) == null ? void 0 : _v["Target"].replace("../", "ppt/");
      }
      let themeResObj = {};
      let themeContent = null;
      if (themeFilename !== void 0) {
        let themeName = themeFilename.split("/").pop();
        let themeResFileName = themeFilename.replace(themeName, "_rels/" + themeName) + ".rels";
        themeContent = yield this.readXmlFile(themeFilename);
        let themeResContent = yield this.readXmlFile(themeResFileName);
        if (themeResContent !== null) {
          let relationshipArray = themeResContent["Relationships"]["Relationship"];
          if (relationshipArray !== void 0) {
            let themeFilename2 = "";
            if (relationshipArray.constructor === Array) {
              for (var i = 0; i < relationshipArray.length; i++) {
                themeResObj[(_w = relationshipArray[i]["attrs"]) == null ? void 0 : _w["Id"]] = {
                  "type": (_x = relationshipArray[i]["attrs"]) == null ? void 0 : _x["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                  "target": (_y = relationshipArray[i]["attrs"]) == null ? void 0 : _y["Target"].replace("../", "ppt/")
                };
              }
            } else {
              themeResObj[(_z = relationshipArray["attrs"]) == null ? void 0 : _z["Id"]] = {
                "type": (_A = relationshipArray["attrs"]) == null ? void 0 : _A["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_B = relationshipArray["attrs"]) == null ? void 0 : _B["Target"].replace("../", "ppt/")
              };
            }
          }
        }
      }
      let diagramResObj = {};
      let digramFileContent = {};
      if (diagramFilename !== void 0) {
        let diagName = diagramFilename.split("/").pop();
        let diagramResFileName = diagramFilename.replace(diagName, "_rels/" + diagName) + ".rels";
        digramFileContent = yield this.readXmlFile(diagramFilename);
        if (digramFileContent !== null && digramFileContent !== void 0 && digramFileContent != "") {
          let digramFileContentObjToStr = JSON.stringify(digramFileContent);
          digramFileContentObjToStr = digramFileContentObjToStr.replace(/dsp:/g, "p:");
          digramFileContent = JSON.parse(digramFileContentObjToStr);
        }
        let digramResContent = yield this.readXmlFile(diagramResFileName);
        if (digramResContent !== null) {
          let relationshipArray = digramResContent["Relationships"]["Relationship"];
          let themeFilename2 = "";
          if (relationshipArray.constructor === Array) {
            for (var i = 0; i < relationshipArray.length; i++) {
              diagramResObj[(_C = relationshipArray[i]["attrs"]) == null ? void 0 : _C["Id"]] = {
                "type": (_D = relationshipArray[i]["attrs"]) == null ? void 0 : _D["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
                "target": (_E = relationshipArray[i]["attrs"]) == null ? void 0 : _E["Target"].replace("../", "ppt/")
              };
            }
          } else {
            diagramResObj[(_F = relationshipArray["attrs"]) == null ? void 0 : _F["Id"]] = {
              "type": (_G = relationshipArray["attrs"]) == null ? void 0 : _G["Type"].replace("http://schemas.openxmlformats.org/officeDocument/2006/relationships/", ""),
              "target": (_H = relationshipArray["attrs"]) == null ? void 0 : _H["Target"].replace("../", "ppt/")
            };
          }
        }
      }
      let nodes = slideContent["p:sld"]["p:cSld"]["p:spTree"];
      this.resources = {
        "slideLayoutContent": slideLayoutContent,
        "slideLayoutTables": slideLayoutTables,
        "slideMasterContent": slideMasterContent,
        "slideMasterTables": slideMasterTables,
        "slideContent": slideContent,
        "slideResObj": slideResObj,
        "slideMasterTextStyles": slideMasterTextStyles,
        "layoutResObj": layoutResObj,
        "masterResObj": masterResObj,
        "themeContent": themeContent,
        "themeResObj": themeResObj,
        "digramFileContent": digramFileContent,
        "diagramResObj": diagramResObj
      };
      let bgResult = "";
      if (this.options.processFullTheme === true) {
        bgResult = yield this.getBackground();
      }
      let bgColor = "";
      if (this.options.processFullTheme == "colorsAndImageOnly") {
        bgColor = yield this.getSlideBackgroundFill();
      }
      let result = "<div class='slide' style='width:" + ((_I = this.options.basicInfo) == null ? void 0 : _I.width) + "px; height:" + ((_J = this.options.basicInfo) == null ? void 0 : _J.height) + "px;" + bgColor + "'>";
      result += bgResult;
      for (var nodeKey in nodes) {
        if (nodes[nodeKey].constructor === Array) {
          for (var i = 0; i < nodes[nodeKey].length; i++) {
            result += yield this.processNodesInSlide(nodeKey, nodes[nodeKey][i], nodes, "slide");
          }
        } else {
          result += yield this.processNodesInSlide(nodeKey, nodes[nodeKey], nodes, "slide");
        }
      }
      return result + "</div>";
    });
  }
  indexNodes(content) {
    let keys = Object.keys(content);
    let spTreeNode = content[keys[0]]["p:cSld"]["p:spTree"];
    let idTable = {};
    let idxTable = {};
    let typeTable = {};
    for (var key in spTreeNode) {
      if (key == "p:nvGrpSpPr" || key == "p:grpSpPr") {
        continue;
      }
      let targetNode = spTreeNode[key];
      if (targetNode.constructor === Array) {
        for (var i = 0; i < targetNode.length; i++) {
          let nvSpPrNode = targetNode[i]["p:nvSpPr"];
          let id = getTextByPathList(nvSpPrNode, ["p:cNvPr", "attrs", "id"]);
          let idx = getTextByPathList(nvSpPrNode, ["p:nvPr", "p:ph", "attrs", "idx"]);
          let type = getTextByPathList(nvSpPrNode, ["p:nvPr", "p:ph", "attrs", "type"]);
          if (id !== void 0) {
            idTable[id] = targetNode[i];
          }
          if (idx !== void 0) {
            idxTable[idx] = targetNode[i];
          }
          if (type !== void 0) {
            typeTable[type] = targetNode[i];
          }
        }
      } else {
        let nvSpPrNode = targetNode["p:nvSpPr"];
        let id = getTextByPathList(nvSpPrNode, ["p:cNvPr", "attrs", "id"]);
        let idx = getTextByPathList(nvSpPrNode, ["p:nvPr", "p:ph", "attrs", "idx"]);
        let type = getTextByPathList(nvSpPrNode, ["p:nvPr", "p:ph", "attrs", "type"]);
        if (id !== void 0) {
          idTable[id] = targetNode;
        }
        if (idx !== void 0) {
          idxTable[idx] = targetNode;
        }
        if (type !== void 0) {
          typeTable[type] = targetNode;
        }
      }
    }
    return { "idTable": idTable, "idxTable": idxTable, "typeTable": typeTable };
  }
  processNodesInSlide(nodeKey, nodeValue, nodes, source, sType) {
    return __async(this, null, function* () {
      let result = "";
      switch (nodeKey) {
        case "p:sp":
          result = yield this.processSpNode(nodeValue, nodes, source, sType);
          break;
        case "p:cxnSp":
          result = yield this.processCxnSpNode(nodeValue, nodes, source, sType);
          break;
        case "p:pic":
          result = yield this.processPicNode(nodeValue, nodes, source, sType);
          break;
        case "p:graphicFrame":
          result = yield this.processGraphicFrameNode(nodeValue, source, sType);
          break;
        case "p:grpSp":
          result = yield this.processGroupSpNode(nodeValue, source);
          break;
        case "mc:AlternateContent":
          let mcFallbackNode = getTextByPathList(nodeValue, ["mc:Fallback"]);
          result = yield this.processGroupSpNode(mcFallbackNode, source);
          break;
        default:
      }
      return result;
    });
  }
  processGroupSpNode(node, source) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      let xfrmNode = getTextByPathList(node, ["p:grpSpPr", "a:xfrm"]);
      let top, left, width, height, sType;
      let transform = "";
      if (xfrmNode !== void 0) {
        let x = parseInt((_a = xfrmNode["a:off"]["attrs"]) == null ? void 0 : _a["x"]) * this.options.slideFactor;
        let y = parseInt((_b = xfrmNode["a:off"]["attrs"]) == null ? void 0 : _b["y"]) * this.options.slideFactor;
        let chx = parseInt((_c = xfrmNode["a:chOff"]["attrs"]) == null ? void 0 : _c["x"]) * this.options.slideFactor;
        let chy = parseInt((_d = xfrmNode["a:chOff"]["attrs"]) == null ? void 0 : _d["y"]) * this.options.slideFactor;
        let cx = parseInt((_e = xfrmNode["a:ext"]["attrs"]) == null ? void 0 : _e["cx"]) * this.options.slideFactor;
        let cy = parseInt((_f = xfrmNode["a:ext"]["attrs"]) == null ? void 0 : _f["cy"]) * this.options.slideFactor;
        let chcx = parseInt((_g = xfrmNode["a:chExt"]["attrs"]) == null ? void 0 : _g["cx"]) * this.options.slideFactor;
        let chcy = parseInt((_h = xfrmNode["a:chExt"]["attrs"]) == null ? void 0 : _h["cy"]) * this.options.slideFactor;
        let rotate = parseInt((_i = xfrmNode["attrs"]) == null ? void 0 : _i["rot"]);
        top = chy, left = chx, width = chcx, height = chcy;
        sType = "group";
        if (x !== chx) {
          transform += " translateX(" + (x - chx) + "px)";
        }
        if (y !== chy) {
          transform += " translateY(" + (y - chy) + "px)";
        }
        if (cx !== chcx) {
          transform += " scaleX(" + cx / chcx + ")";
        }
        if (cy !== chcy) {
          transform += " scaleY(" + cy / chcy + ")";
        }
        if (!isNaN(rotate)) {
          rotate = angleToDegrees(rotate);
          transform += "rotate(" + rotate + "deg) ";
        }
      }
      let grpStyle = "";
      if (transform !== "") {
        grpStyle += "transform: " + transform + "; transform-origin: top left;";
      }
      if (top !== void 0) {
        grpStyle += "top: " + top + "px;";
      }
      if (left !== void 0) {
        grpStyle += "left: " + left + "px;";
      }
      if (width !== void 0) {
        grpStyle += "width:" + width + "px;";
      }
      if (height !== void 0) {
        grpStyle += "height: " + height + "px;";
      }
      let id = (_l = (_k = (_j = node["p:nvGrpSpPr"]) == null ? void 0 : _j["p:cNvPr"]) == null ? void 0 : _k["attrs"]) == null ? void 0 : _l["id"];
      let order = ((_m = node["attrs"]) == null ? void 0 : _m["order"]) || _2.default.toInteger(id);
      let result = "<div class='block group' style='z-index: " + order + ";" + grpStyle + "'>";
      result += "<div style='top: -" + top + "px; left: -" + left + "px; position: absolute;'>";
      for (var nodeKey in node) {
        if (node[nodeKey].constructor === Array) {
          for (var i = 0; i < node[nodeKey].length; i++) {
            result += yield this.processNodesInSlide(nodeKey, node[nodeKey][i], node, source, sType);
          }
        } else {
          result += yield this.processNodesInSlide(nodeKey, node[nodeKey], node, source, sType);
        }
      }
      result += "</div>";
      result += "</div>";
      return result;
    });
  }
  processSpNode(node, pNode, source, sType) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      let id = getTextByPathList(node, ["p:nvSpPr", "p:cNvPr", "attrs", "id"]);
      let name = getTextByPathList(node, ["p:nvSpPr", "p:cNvPr", "attrs", "name"]);
      let idx = getTextByPathList(node, ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "idx"]) === void 0 ? void 0 : getTextByPathList(node, ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "idx"]);
      let type = getTextByPathList(node, ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]) === void 0 ? void 0 : getTextByPathList(node, ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
      let order = getTextByPathList(node, ["attrs", "order"]) || _2.default.toInteger(id);
      let isUserDrawnBg;
      if (source == "slideLayoutBg" || source == "slideMasterBg") {
        let userDrawn = getTextByPathList(node, ["p:nvSpPr", "p:nvPr", "attrs", "userDrawn"]);
        if (userDrawn == "1") {
          isUserDrawnBg = true;
        } else {
          isUserDrawnBg = false;
        }
      }
      let slideLayoutSpNode = void 0;
      let slideMasterSpNode = void 0;
      if (idx !== void 0) {
        slideLayoutSpNode = (_a = this.resources) == null ? void 0 : _a.slideLayoutTables["idxTable"][idx];
        if (type !== void 0) {
          slideMasterSpNode = (_b = this.resources) == null ? void 0 : _b.slideMasterTables["typeTable"][type];
        } else {
          slideMasterSpNode = (_c = this.resources) == null ? void 0 : _c.slideMasterTables["idxTable"][idx];
        }
      } else {
        if (type !== void 0) {
          slideLayoutSpNode = (_d = this.resources) == null ? void 0 : _d.slideLayoutTables["typeTable"][type];
          slideMasterSpNode = (_e = this.resources) == null ? void 0 : _e.slideMasterTables["typeTable"][type];
        }
      }
      if (type === void 0) {
        const txBoxVal = getTextByPathList(node, ["p:nvSpPr", "p:cNvSpPr", "attrs", "txBox"]);
        if (txBoxVal == "1") {
          type = "textBox";
        }
      }
      if (type === void 0) {
        type = getTextByPathList(slideLayoutSpNode, ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
        if (type === void 0) {
          if (source == "diagramBg") {
            type = "diagram";
          } else {
            type = "obj";
          }
        }
      }
      return yield this.genShape(node, pNode, slideLayoutSpNode, slideMasterSpNode, id, name, idx, type, order, isUserDrawnBg, sType, source);
    });
  }
  processCxnSpNode(node, pNode, source, sType) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      let id = (_a = node["p:nvCxnSpPr"]["p:cNvPr"]["attrs"]) == null ? void 0 : _a["id"];
      let name = (_b = node["p:nvCxnSpPr"]["p:cNvPr"]["attrs"]) == null ? void 0 : _b["name"];
      let idx = node["p:nvCxnSpPr"]["p:nvPr"]["p:ph"] === void 0 ? void 0 : (_c = node["p:nvSpPr"]["p:nvPr"]["p:ph"]["attrs"]) == null ? void 0 : _c["idx"];
      let type = node["p:nvCxnSpPr"]["p:nvPr"]["p:ph"] === void 0 ? void 0 : (_d = node["p:nvSpPr"]["p:nvPr"]["p:ph"]["attrs"]) == null ? void 0 : _d["type"];
      let order = ((_e = node["attrs"]) == null ? void 0 : _e["order"]) || _2.default.toInteger(id);
      return yield this.genShape(node, pNode, void 0, void 0, id, name, idx, type, order, void 0, sType, source);
    });
  }
  genShape(node, pNode, slideLayoutSpNode, slideMasterSpNode, id, name, idx, type, order, isUserDrawnBg, sType, source) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      let xfrmList = ["p:spPr", "a:xfrm"];
      let slideXfrmNode = getTextByPathList(node, xfrmList);
      let slideLayoutXfrmNode = getTextByPathList(slideLayoutSpNode, xfrmList);
      let slideMasterXfrmNode = getTextByPathList(slideMasterSpNode, xfrmList);
      let result = "";
      let shpId = getTextByPathList(node, ["attrs", "order"]);
      let shapType = getTextByPathList(node, ["p:spPr", "a:prstGeom", "attrs", "prst"]);
      let custShapType = getTextByPathList(node, ["p:spPr", "a:custGeom"]);
      let isFlipV = false;
      let isFlipH = false;
      let flip = "";
      if (getTextByPathList(slideXfrmNode, ["attrs", "flipV"]) === "1") {
        isFlipV = true;
      }
      if (getTextByPathList(slideXfrmNode, ["attrs", "flipH"]) === "1") {
        isFlipH = true;
      }
      if (isFlipH && !isFlipV) {
        flip = " scale(-1,1)";
      } else if (!isFlipH && isFlipV) {
        flip = " scale(1,-1)";
      } else if (isFlipH && isFlipV) {
        flip = " scale(-1,-1)";
      }
      let rotate = angleToDegrees(getTextByPathList(slideXfrmNode, ["attrs", "rot"]));
      let txtRotate;
      let txtXframeNode = getTextByPathList(node, ["p:txXfrm"]);
      if (txtXframeNode !== void 0) {
        let txtXframeRot = getTextByPathList(txtXframeNode, ["attrs", "rot"]);
        if (txtXframeRot !== void 0) {
          txtRotate = angleToDegrees(txtXframeRot) + 90;
        }
      } else {
        txtRotate = rotate;
      }
      if (shapType == "gear9") {
        txtRotate = 0;
      }
      let border;
      let off, x, y, ext, w = 0, h = 0, grndFillFlg, imgFillFlg, clrFillType, fillColor, headEndNodeAttrs, tailEndNodeAttrs;
      let oShadowSvgUrlStr = "";
      if (shapType !== void 0 || custShapType !== void 0) {
        off = getTextByPathList(slideXfrmNode, ["a:off", "attrs"]);
        x = parseInt(off["x"]) * this.options.slideFactor;
        y = parseInt(off["y"]) * this.options.slideFactor;
        ext = getTextByPathList(slideXfrmNode, ["a:ext", "attrs"]);
        w = parseInt(ext["cx"]) * this.options.slideFactor;
        h = parseInt(ext["cy"]) * this.options.slideFactor;
        let svgCssName = "_svg_css_" + ((_a = this.options.styleTable) == null ? void 0 : _a.nextIndex()) + "_" + Math.floor(Math.random() * 1001);
        let effectsClassName = svgCssName + "_effects";
        result += "<svg class='drawing " + svgCssName + " " + effectsClassName + " ' _id='" + id + "' _idx='" + idx + "' _type='" + type + "' _name='" + name + "'' style='" + this.getPosition(slideXfrmNode, pNode, void 0, void 0, sType) + this.getSize(slideXfrmNode, pNode, void 0, void 0, sType) + " min-height: 1px; z-index: " + order + ";transform: rotate(" + (rotate !== void 0 ? rotate : 0) + "deg)" + flip + ";'>";
        result += "<defs>";
        fillColor = yield this.getShapeFill(node, pNode, true, source);
        grndFillFlg = false;
        imgFillFlg = false;
        clrFillType = this.getFillType(getTextByPathList(node, ["p:spPr"]));
        if (clrFillType == "GROUP_FILL") {
          clrFillType = this.getFillType(getTextByPathList(pNode, ["p:grpSpPr"]));
        }
        if (clrFillType == "GRADIENT_FILL") {
          grndFillFlg = true;
          let color_arry = fillColor.color;
          let angl = fillColor.rot + 90;
          let svgGrdnt = getSvgGradient(w, h, angl, color_arry, shpId);
          result += svgGrdnt;
        } else if (clrFillType == "PIC_FILL") {
          imgFillFlg = true;
          let svgBgImg = this.getSvgImagePattern(node, fillColor, shpId);
          result += svgBgImg;
        } else if (clrFillType == "PATTERN_FILL") {
          let styleText = fillColor;
          if ((_b = this.options.styleTable) == null ? void 0 : _b.has(styleText)) {
            styleText += "do-nothing: " + svgCssName + ";";
          }
          (_c = this.options.styleTable) == null ? void 0 : _c.update(styleText, {
            "name": svgCssName,
            "text": styleText
          });
          fillColor = "none";
        } else {
          if (clrFillType != "SOLID_FILL" && clrFillType != "PATTERN_FILL" && (shapType == "arc" || shapType == "bracketPair" || shapType == "bracePair" || shapType == "leftBracket" || shapType == "leftBrace" || shapType == "rightBrace" || shapType == "rightBracket")) {
            fillColor = "none";
          }
        }
        border = this.getBorder(node, pNode, true, "shape");
        headEndNodeAttrs = getTextByPathList(node, ["p:spPr", "a:ln", "a:headEnd", "attrs"]);
        tailEndNodeAttrs = getTextByPathList(node, ["p:spPr", "a:ln", "a:tailEnd", "attrs"]);
        let outerShdwNode = getTextByPathList(node, ["p:spPr", "a:effectLst", "a:outerShdw"]);
        if (outerShdwNode !== void 0) {
          let chdwClrNode = this.getSolidFill(outerShdwNode);
          let outerShdwAttrs = (_d = outerShdwNode["attrs"]) != null ? _d : {};
          let dir = outerShdwAttrs["dir"] ? parseInt(outerShdwAttrs["dir"]) / 6e4 : 0;
          let dist = parseInt(outerShdwAttrs["dist"]) * this.options.slideFactor;
          let blurRad = outerShdwAttrs["blurRad"] ? parseInt(outerShdwAttrs["blurRad"]) * this.options.slideFactor : "";
          let vx = dist * Math.sin(dir * Math.PI / 180);
          let hx = dist * Math.cos(dir * Math.PI / 180);
          let svg_css_shadow = "filter:drop-shadow(" + hx + "px " + vx + "px " + blurRad + "px #" + chdwClrNode + ");";
          if ((_e = this.options.styleTable) == null ? void 0 : _e.has(svg_css_shadow)) {
            svg_css_shadow += "do-nothing: " + svgCssName + ";";
          }
          (_f = this.options.styleTable) == null ? void 0 : _f.update(svg_css_shadow, {
            "name": effectsClassName,
            "text": svg_css_shadow
          });
        }
        if (headEndNodeAttrs !== void 0 && (headEndNodeAttrs["type"] === "triangle" || headEndNodeAttrs["type"] === "arrow") || tailEndNodeAttrs !== void 0 && (tailEndNodeAttrs["type"] === "triangle" || tailEndNodeAttrs["type"] === "arrow")) {
          let triangleMarker = "<marker id='markerTriangle_" + shpId + "' viewBox='0 0 10 10' refX='1' refY='5' markerWidth='5' markerHeight='5' stroke='" + border.color + "' fill='" + border.color + "' orient='auto-start-reverse' markerUnits='strokeWidth'><path d='M 0 0 L 10 5 L 0 10 z' /></marker>";
          result += triangleMarker;
        }
        result += "</defs>";
      }
      if (shapType !== void 0 && custShapType === void 0) {
        const fill = !imgFillFlg ? grndFillFlg ? "url(#linGrd_" + shpId + ")" : fillColor : "url(#imgPtrn_" + shpId + ")";
        const markerStart = headEndNodeAttrs !== void 0 && (headEndNodeAttrs["type"] === "triangle" || headEndNodeAttrs["type"] === "arrow") ? "marker-start='url(#markerTriangle_" + shpId + ")' " : "";
        const markerEnd = tailEndNodeAttrs !== void 0 && (tailEndNodeAttrs["type"] === "triangle" || tailEndNodeAttrs["type"] === "arrow") ? "marker-end='url(#markerTriangle_" + shpId + ")' " : "";
        result += genTypedShape(
          shapType,
          w,
          h,
          border,
          fill,
          this.options.slideFactor,
          getTextByPathList(node, ["p:spPr", "a:prstGeom", "a:avLst", "a:gd"]),
          oShadowSvgUrlStr,
          markerStart,
          markerEnd
        );
        result += "</svg>";
        result += "<div class='block " + this.getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + //block content
        " " + this.getContentDir(node, type) + "' _id='" + id + "' _idx='" + idx + "' _type='" + type + "' _name='" + name + "' style='" + this.getPosition(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + this.getSize(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + " z-index: " + order + ";transform: rotate(" + (txtRotate !== void 0 ? txtRotate : 0) + "deg);'>";
        if (node["p:txBody"] !== void 0 && (isUserDrawnBg === void 0 || isUserDrawnBg === true)) {
          if (type != "diagram" && type != "textBox") {
            type = "shape";
          }
          result += yield this.genTextBody(node["p:txBody"], node, slideLayoutSpNode, slideMasterSpNode, type, idx);
        }
        result += "</div>";
      } else if (custShapType !== void 0) {
        let pathLstNode = getTextByPathList(custShapType, ["a:pathLst"]);
        let pathNodes = getTextByPathList(pathLstNode, ["a:path"]);
        let maxX = parseInt((_g = pathNodes["attrs"]) == null ? void 0 : _g["w"]);
        let maxY = parseInt((_h = pathNodes["attrs"]) == null ? void 0 : _h["h"]);
        let cX = 1 / maxX * w;
        let cY = 1 / maxY * h;
        let moveToNode = getTextByPathList(pathNodes, ["a:moveTo"]);
        let total_shapes = moveToNode.length;
        let lnToNodes = pathNodes["a:lnTo"];
        let cubicBezToNodes = pathNodes["a:cubicBezTo"];
        let arcToNodes = pathNodes["a:arcTo"];
        let closeNode = getTextByPathList(pathNodes, ["a:close"]);
        if (!Array.isArray(moveToNode)) {
          moveToNode = [moveToNode];
        }
        const fill = !imgFillFlg ? grndFillFlg ? "url(#linGrd_" + shpId + ")" : fillColor : "url(#imgPtrn_" + shpId + ")";
        result += genCustShape(moveToNode, lnToNodes, cubicBezToNodes, arcToNodes, closeNode, cX, cY, fill, border);
        result += "</svg>";
        result += "<div class='block " + this.getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + //block content 
        " " + this.getContentDir(node, type) + "' _id='" + id + "' _idx='" + idx + "' _type='" + type + "' _name='" + name + "' style='" + this.getPosition(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + this.getSize(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + " z-index: " + order + ";transform: rotate(" + (txtRotate !== void 0 ? txtRotate : 0) + "deg);'>";
        if (node["p:txBody"] !== void 0 && (isUserDrawnBg === void 0 || isUserDrawnBg === true)) {
          if (type != "diagram" && type != "textBox") {
            type = "shape";
          }
          result += yield this.genTextBody(node["p:txBody"], node, slideLayoutSpNode, slideMasterSpNode, type, idx);
        }
        result += "</div>";
      } else {
        result += "<div class='block " + this.getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) + //block content 
        " " + this.getContentDir(node, type) + "' _id='" + id + "' _idx='" + idx + "' _type='" + type + "' _name='" + name + "' style='" + this.getPosition(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + this.getSize(slideXfrmNode, pNode, slideLayoutXfrmNode, slideMasterXfrmNode, sType) + this.getBorder(node, pNode, false, "shape") + (yield this.getShapeFill(node, pNode, false, source)) + " z-index: " + order + ";transform: rotate(" + (txtRotate !== void 0 ? txtRotate : 0) + "deg);'>";
        if (node["p:txBody"] !== void 0 && (isUserDrawnBg === void 0 || isUserDrawnBg === true)) {
          result += yield this.genTextBody(node["p:txBody"], node, slideLayoutSpNode, slideMasterSpNode, type, idx);
        }
        result += "</div>";
      }
      return result;
    });
  }
  /*
  shapePolygon(sidesNum) {
      let sides  = sidesNum;
      let radius = 100;
      let angle  = 2 * Math.PI / sides;
      let points = []; 
      
      for (var i = 0; i < sides; i++) {
          points.push(radius + radius * Math.sin(i * angle));
          points.push(radius - radius * Math.cos(i * angle));
      }
      
      return points;
  }
  */
  processPicNode(node, pNode, source, sType) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      let rtrnData = "";
      let mediaPicFlag = false;
      let id = getTextByPathList(node, ["p:nvPicPr", "p:cNvPr", "attrs", "id"]);
      let order = ((_a = node["attrs"]) == null ? void 0 : _a["order"]) || _2.default.toInteger(id);
      let rid = (_b = node["p:blipFill"]["a:blip"]["attrs"]) == null ? void 0 : _b["r:embed"];
      let resObj;
      if (source == "slideMasterBg") {
        resObj = (_c = this.resources) == null ? void 0 : _c.masterResObj;
      } else if (source == "slideLayoutBg") {
        resObj = (_d = this.resources) == null ? void 0 : _d.layoutResObj;
      } else {
        resObj = (_e = this.resources) == null ? void 0 : _e.slideResObj;
      }
      let imgName = resObj[rid]["target"];
      let xfrmNode = node["p:spPr"]["a:xfrm"];
      if (xfrmNode === void 0) {
        let idx = getTextByPathList(node, ["p:nvPicPr", "p:nvPr", "p:ph", "attrs", "idx"]);
        let type = getTextByPathList(node, ["p:nvPicPr", "p:nvPr", "p:ph", "attrs", "type"]);
        if (idx !== void 0) {
          xfrmNode = getTextByPathList((_f = this.resources) == null ? void 0 : _f.slideLayoutTables, ["idxTable", idx, "p:spPr", "a:xfrm"]);
        }
      }
      let rotate = 0;
      let rotateNode = getTextByPathList(node, ["p:spPr", "a:xfrm", "attrs", "rot"]);
      if (rotateNode !== void 0) {
        rotate = angleToDegrees(rotateNode);
      }
      let vdoNode = getTextByPathList(node, ["p:nvPicPr", "p:nvPr", "a:videoFile"]);
      let vdoRid, vdoFile, vdoFileExt, vdoMimeType, uInt8Array, blob, vdoBlob, mediaSupportFlag = false, isVdeoLink = false;
      let mediaProcess = this.options.mediaProcess;
      if (vdoNode !== void 0 && mediaProcess) {
        vdoRid = (_g = vdoNode["attrs"]) == null ? void 0 : _g["r:link"];
        vdoFile = resObj[vdoRid]["target"];
        let checkIfLink = isVideoLink(vdoFile);
        if (checkIfLink) {
          vdoFile = escapeHtml(vdoFile);
          isVdeoLink = true;
          mediaSupportFlag = true;
          mediaPicFlag = true;
        } else {
          vdoFileExt = extractFileExtension(vdoFile);
          if (vdoFileExt == "mp4" || vdoFileExt == "webm" || vdoFileExt == "ogg") {
            uInt8Array = yield (_h = this.options.resourceReader) == null ? void 0 : _h.getFile(vdoFile, "arraybuffer");
            vdoMimeType = getMimeType(vdoFileExt);
            blob = new Blob([uInt8Array], {
              type: vdoMimeType
            });
            vdoBlob = URL.createObjectURL(blob);
            mediaSupportFlag = true;
            mediaPicFlag = true;
          }
        }
      }
      let audioNode = getTextByPathList(node, ["p:nvPicPr", "p:nvPr", "a:audioFile"]);
      let audioRid, audioFile, audioFileExt, audioMimeType, uInt8ArrayAudio, blobAudio, audioBlob;
      let audioPlayerFlag = false;
      let audioObjc;
      if (audioNode !== void 0 && mediaProcess) {
        audioRid = (_i = audioNode["attrs"]) == null ? void 0 : _i["r:link"];
        audioFile = resObj[audioRid]["target"];
        audioFileExt = extractFileExtension(audioFile);
        if (audioFileExt == "mp3" || audioFileExt == "wav" || audioFileExt == "ogg") {
          uInt8ArrayAudio = yield (_j = this.options.resourceReader) == null ? void 0 : _j.getFile(audioFile, "arraybuffer");
          blobAudio = new Blob([uInt8ArrayAudio]);
          audioBlob = URL.createObjectURL(blobAudio);
          let cx = parseInt((_k = xfrmNode["a:ext"]["attrs"]) == null ? void 0 : _k["cx"]) * 20;
          let cy = (_l = xfrmNode["a:ext"]["attrs"]) == null ? void 0 : _l["cy"];
          let x = parseInt((_m = xfrmNode["a:off"]["attrs"]) == null ? void 0 : _m["x"]) / 2.5;
          let y = (_n = xfrmNode["a:off"]["attrs"]) == null ? void 0 : _n["y"];
          audioObjc = {
            "a:ext": {
              "attrs": {
                "cx": cx,
                "cy": cy
              }
            },
            "a:off": {
              "attrs": {
                "x": x,
                "y": y
              }
            }
          };
          audioPlayerFlag = true;
          mediaSupportFlag = true;
          mediaPicFlag = true;
        }
      }
      rtrnData = "<div class='block content' style='" + (mediaProcess && audioPlayerFlag ? this.getPosition(audioObjc, pNode, void 0, void 0) : this.getPosition(xfrmNode, pNode, void 0, void 0)) + (mediaProcess && audioPlayerFlag ? this.getSize(audioObjc, pNode, void 0, void 0, sType) : this.getSize(xfrmNode, pNode, void 0, void 0)) + this.getBorder(node, pNode, false, "shape") + " z-index: " + order + ";transform: rotate(" + rotate + "deg);'>";
      if (vdoNode === void 0 && audioNode === void 0 || !mediaProcess || !mediaSupportFlag) {
        rtrnData += "<img src='" + (yield (_o = this.options.resourceReader) == null ? void 0 : _o.getImgBase64Data(imgName)) + "' style='width: 100%; height: 100%'/>";
      } else if ((vdoNode !== void 0 || audioNode !== void 0) && mediaProcess && mediaSupportFlag) {
        if (vdoNode !== void 0 && !isVdeoLink) {
          rtrnData += "<video  src='" + vdoBlob + "' controls style='width: 100%; height: 100%'>Your browser does not support the video tag.</video>";
        } else if (vdoNode !== void 0 && isVdeoLink) {
          rtrnData += "<iframe   src='" + vdoFile + "' controls style='width: 100%; height: 100%'></iframe >";
        }
        if (audioNode !== void 0) {
          rtrnData += '<audio id="audio_player" controls ><source src="' + audioBlob + '"></audio>';
        }
      }
      if (!mediaSupportFlag && mediaPicFlag) {
        rtrnData += "<span style='color:red;font-size:40px;position: absolute;'>This media file Not supported by HTML5</span>";
      }
      if ((vdoNode !== void 0 || audioNode !== void 0) && !mediaProcess && mediaSupportFlag) {
        console.log("Founded supported media file but media process disabled (mediaProcess=false)");
      }
      rtrnData += "</div>";
      return rtrnData;
    });
  }
  processGraphicFrameNode(node, source, sType) {
    return __async(this, null, function* () {
      let result = "";
      let graphicTypeUri = getTextByPathList(node, ["a:graphic", "a:graphicData", "attrs", "uri"]);
      switch (graphicTypeUri) {
        case "http://schemas.openxmlformats.org/drawingml/2006/table":
          result = yield this.genTable(node);
          break;
        case "http://schemas.openxmlformats.org/drawingml/2006/chart":
          result = yield this.genChart(node);
          break;
        case "http://schemas.openxmlformats.org/drawingml/2006/diagram":
          result = yield this.genDiagram(node, source, sType);
          break;
        case "http://schemas.openxmlformats.org/presentationml/2006/ole":
          let oleObjNode = getTextByPathList(node, ["a:graphic", "a:graphicData", "mc:AlternateContent", "mc:Fallback", "p:oleObj"]);
          if (oleObjNode === void 0) {
            oleObjNode = getTextByPathList(node, ["a:graphic", "a:graphicData", "p:oleObj"]);
          }
          if (oleObjNode !== void 0) {
            result = yield this.processGroupSpNode(oleObjNode, source);
          }
          break;
        default:
      }
      return result;
    });
  }
  processSpPrNode(node) {
  }
  genTextBody(textBodyNode, spNode, slideLayoutSpNode, slideMasterSpNode, type, idx, tbl_col_width) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      let text = "";
      let slideMasterTextStyles = (_a = this.resources) == null ? void 0 : _a.slideMasterTextStyles;
      if (textBodyNode === void 0) {
        return text;
      }
      let pFontStyle = getTextByPathList(spNode, ["p:style", "a:fontRef"]);
      let apNode = textBodyNode["a:p"];
      if (apNode.constructor !== Array) {
        apNode = [apNode];
      }
      for (var i = 0; i < apNode.length; i++) {
        let pNode = apNode[i];
        let rNode = pNode["a:r"];
        let fldNode = pNode["a:fld"];
        let brNode = pNode["a:br"];
        if (rNode !== void 0) {
          rNode = rNode.constructor === Array ? rNode : [rNode];
        }
        if (rNode !== void 0 && fldNode !== void 0) {
          fldNode = fldNode.constructor === Array ? fldNode : [fldNode];
          rNode = rNode.concat(fldNode);
        }
        if (rNode !== void 0 && brNode !== void 0) {
          this.isFirstBr = true;
          brNode = brNode.constructor === Array ? brNode : [brNode];
          brNode.forEach(function(item) {
            item.type = "br";
          });
          if (brNode.length > 1) {
            brNode.shift();
          }
          rNode = rNode.concat(brNode);
          rNode.sort(function(a, b) {
            var _a2, _b2;
            return ((_a2 = a.attrs) == null ? void 0 : _a2.order) - ((_b2 = b.attrs) == null ? void 0 : _b2.order);
          });
        }
        let styleText = "";
        let marginsVer = this.getVerticalMargins(pNode, textBodyNode, type, idx);
        if (marginsVer != "") {
          styleText = marginsVer;
        }
        if (type == "body" || type == "obj" || type == "shape") {
          styleText += "font-size: 0px;";
          styleText += "font-weight: 100;";
          styleText += "font-style: normal;";
        }
        let cssName = "";
        if ((_b = this.options.styleTable) == null ? void 0 : _b.has(styleText)) {
          cssName = (_c = this.options.styleTable) == null ? void 0 : _c.get(styleText).name;
        } else {
          cssName = "_css_" + ((_d = this.options.styleTable) == null ? void 0 : _d.nextIndex());
          (_e = this.options.styleTable) == null ? void 0 : _e.update(styleText, {
            "name": cssName,
            "text": styleText
          });
        }
        let prg_width_node = getTextByPathList(spNode, ["p:spPr", "a:xfrm", "a:ext", "attrs", "cx"]);
        let prg_height_node = getTextByPathList(spNode, ["p:spPr", "a:xfrm", "a:ext", "attrs", "cy"]);
        let sld_prg_width = prg_width_node !== void 0 ? "width:" + parseInt(prg_width_node) * this.options.slideFactor + "px;" : "width:inherit;";
        let sld_prg_height = prg_height_node !== void 0 ? "height:" + parseInt(prg_height_node) * this.options.slideFactor + "px;" : "";
        let prg_dir = this.getPregraphDir(pNode, textBodyNode, idx, type);
        text += "<div style='display: flex;" + sld_prg_width + sld_prg_height + "' class='slide-prgrph " + this.getHorizontalAlign(pNode, textBodyNode, idx, type, prg_dir) + " " + prg_dir + " " + cssName + "' >";
        let buText_ary = yield this.genBuChar(pNode, i, spNode, textBodyNode, pFontStyle, idx, type);
        let isBullate = buText_ary ? true : false;
        let bu_width = buText_ary && buText_ary[1] !== void 0 && buText_ary[1] !== null && isBullate ? buText_ary[1] + buText_ary[2] : 0;
        text += buText_ary ? buText_ary[0] : "";
        let margin_ary = this.getPregraphMargn(pNode, idx, type, isBullate);
        let margin = margin_ary[0];
        let mrgin_val = margin_ary[1];
        if (prg_width_node === void 0 && tbl_col_width !== void 0 && prg_width_node != 0) {
          prg_width_node = tbl_col_width;
        }
        let prgrph_text = "";
        let total_text_len = 0;
        if (rNode === void 0 && pNode !== void 0) {
          let prgr_text = this.genSpanElement(pNode, void 0, spNode, textBodyNode, pFontStyle, slideLayoutSpNode, idx, type, 1, isBullate);
          if (isBullate) {
            total_text_len += estimateWidth(prgr_text);
          }
          prgrph_text += prgr_text;
        } else if (rNode !== void 0) {
          for (var j = 0; j < rNode.length; j++) {
            let prgr_text = this.genSpanElement(rNode[j], j, pNode, textBodyNode, pFontStyle, slideLayoutSpNode, idx, type, rNode.length, isBullate);
            if (isBullate) {
              total_text_len += estimateWidth(prgr_text);
            }
            prgrph_text += prgr_text;
          }
        }
        prg_width_node = parseInt(prg_width_node) * this.options.slideFactor - bu_width + mrgin_val;
        if (isBullate) {
          if (total_text_len < prg_width_node) {
            prg_width_node = total_text_len + bu_width + mrgin_val;
          }
        }
        let prg_width = prg_width_node !== void 0 ? "width:" + prg_width_node + "px;" : "width:inherit;";
        text += "<div style='height: 100%;direction: initial;overflow-wrap:break-word;word-wrap: break-word;" + prg_width + margin + "' >";
        text += prgrph_text;
        text += "</div>";
        text += "</div>";
      }
      return text;
    });
  }
  genBuChar(node, i, spNode, textBodyNode, pFontStyle, idx, type) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let sldMstrTxtStyles = (_a = this.resources) == null ? void 0 : _a.slideMasterTextStyles;
      let lstStyle = textBodyNode["a:lstStyle"];
      let rNode = getTextByPathList(node, ["a:r"]);
      if (rNode !== void 0 && rNode.constructor === Array) {
        rNode = rNode[0];
      }
      let lvl = parseInt(getTextByPathList(node["a:pPr"], ["attrs", "lvl"])) + 1;
      if (isNaN(lvl)) {
        lvl = 1;
      }
      let lvlStr = "a:lvl" + lvl + "pPr";
      let dfltBultColor, dfltBultSize, bultColor, bultSize, color_tye;
      if (rNode !== void 0) {
        dfltBultColor = this.getFontColorPr(rNode, spNode, lstStyle, pFontStyle, lvl, idx, type);
        color_tye = dfltBultColor[2];
        dfltBultSize = this.getFontSize(rNode, textBodyNode, pFontStyle, lvl, type);
      } else {
        return;
      }
      let bullet = "", marRStr = "", marLStr = "", margin_val = 0, font_val = 0;
      let pPrNode = node["a:pPr"];
      let BullNONE = getTextByPathList(pPrNode, ["a:buNone"]);
      if (BullNONE !== void 0) {
        return;
      }
      let buType = "TYPE_NONE";
      let layoutMasterNode = this.getLayoutAndMasterNode(node, idx, type);
      let pPrNodeLaout = layoutMasterNode.nodeLaout;
      let pPrNodeMaster = layoutMasterNode.nodeMaster;
      let buChar = getTextByPathList(pPrNode, ["a:buChar", "attrs", "char"]);
      let buNum = getTextByPathList(pPrNode, ["a:buAutoNum", "attrs", "type"]);
      let buPic = getTextByPathList(pPrNode, ["a:buBlip"]);
      if (buChar !== void 0) {
        buType = "TYPE_BULLET";
      }
      if (buNum !== void 0) {
        buType = "TYPE_NUMERIC";
      }
      if (buPic !== void 0) {
        buType = "TYPE_BULPIC";
      }
      let buFontSize = getTextByPathList(pPrNode, ["a:buSzPts", "attrs", "val"]);
      if (buFontSize === void 0) {
        buFontSize = getTextByPathList(pPrNode, ["a:buSzPct", "attrs", "val"]);
        if (buFontSize !== void 0) {
          let prcnt = parseInt(buFontSize) / 1e5;
          let dfltBultSizeNoPt = parseInt(dfltBultSize);
          bultSize = prcnt * dfltBultSizeNoPt + "px";
        }
      } else {
        bultSize = parseInt(buFontSize) / 100 * this.options.fontSizeFactor + "px";
      }
      let buClrNode = getTextByPathList(pPrNode, ["a:buClr"]);
      if (buChar === void 0 && buNum === void 0 && buPic === void 0) {
        if (lstStyle !== void 0) {
          BullNONE = getTextByPathList(lstStyle, [lvlStr, "a:buNone"]);
          if (BullNONE !== void 0) {
            return;
          }
          buType = "TYPE_NONE";
          buChar = getTextByPathList(lstStyle, [lvlStr, "a:buChar", "attrs", "char"]);
          buNum = getTextByPathList(lstStyle, [lvlStr, "a:buAutoNum", "attrs", "type"]);
          buPic = getTextByPathList(lstStyle, [lvlStr, "a:buBlip"]);
          if (buChar !== void 0) {
            buType = "TYPE_BULLET";
          }
          if (buNum !== void 0) {
            buType = "TYPE_NUMERIC";
          }
          if (buPic !== void 0) {
            buType = "TYPE_BULPIC";
          }
          if (buChar !== void 0 || buNum !== void 0 || buPic !== void 0) {
            pPrNode = lstStyle[lvlStr];
          }
        }
      }
      if (buChar === void 0 && buNum === void 0 && buPic === void 0) {
        if (pPrNodeLaout !== void 0) {
          BullNONE = getTextByPathList(pPrNodeLaout, ["a:buNone"]);
          if (BullNONE !== void 0) {
            return;
          }
          buType = "TYPE_NONE";
          buChar = getTextByPathList(pPrNodeLaout, ["a:buChar", "attrs", "char"]);
          buNum = getTextByPathList(pPrNodeLaout, ["a:buAutoNum", "attrs", "type"]);
          buPic = getTextByPathList(pPrNodeLaout, ["a:buBlip"]);
          if (buChar !== void 0) {
            buType = "TYPE_BULLET";
          }
          if (buNum !== void 0) {
            buType = "TYPE_NUMERIC";
          }
          if (buPic !== void 0) {
            buType = "TYPE_BULPIC";
          }
        }
        if (buChar === void 0 && buNum === void 0 && buPic === void 0) {
          if (pPrNodeMaster !== void 0) {
            BullNONE = getTextByPathList(pPrNodeMaster, ["a:buNone"]);
            if (BullNONE !== void 0) {
              return;
            }
            buType = "TYPE_NONE";
            buChar = getTextByPathList(pPrNodeMaster, ["a:buChar", "attrs", "char"]);
            buNum = getTextByPathList(pPrNodeMaster, ["a:buAutoNum", "attrs", "type"]);
            buPic = getTextByPathList(pPrNodeMaster, ["a:buBlip"]);
            if (buChar !== void 0) {
              buType = "TYPE_BULLET";
            }
            if (buNum !== void 0) {
              buType = "TYPE_NUMERIC";
            }
            if (buPic !== void 0) {
              buType = "TYPE_BULPIC";
            }
          }
        }
      }
      let getRtlVal = getTextByPathList(pPrNode, ["attrs", "rtl"]);
      if (getRtlVal === void 0) {
        getRtlVal = getTextByPathList(pPrNodeLaout, ["attrs", "rtl"]);
        if (getRtlVal === void 0 && type != "shape") {
          getRtlVal = getTextByPathList(pPrNodeMaster, ["attrs", "rtl"]);
        }
      }
      let isRTL = false;
      if (getRtlVal !== void 0 && getRtlVal == "1") {
        isRTL = true;
      }
      let alignNode = getTextByPathList(pPrNode, ["attrs", "algn"]);
      if (alignNode === void 0) {
        alignNode = getTextByPathList(pPrNodeLaout, ["attrs", "algn"]);
        if (alignNode === void 0) {
          alignNode = getTextByPathList(pPrNodeMaster, ["attrs", "algn"]);
        }
      }
      let indentNode = getTextByPathList(pPrNode, ["attrs", "indent"]);
      if (indentNode === void 0) {
        indentNode = getTextByPathList(pPrNodeLaout, ["attrs", "indent"]);
        if (indentNode === void 0) {
          indentNode = getTextByPathList(pPrNodeMaster, ["attrs", "indent"]);
        }
      }
      let indent = 0;
      if (indentNode !== void 0) {
        indent = parseInt(indentNode) * this.options.slideFactor;
      }
      let marLNode = getTextByPathList(pPrNode, ["attrs", "marL"]);
      if (marLNode === void 0) {
        marLNode = getTextByPathList(pPrNodeLaout, ["attrs", "marL"]);
        if (marLNode === void 0) {
          marLNode = getTextByPathList(pPrNodeMaster, ["attrs", "marL"]);
        }
      }
      if (marLNode !== void 0) {
        let marginLeft = parseInt(marLNode) * this.options.slideFactor;
        if (isRTL) {
          marLStr = "padding-right:";
        } else {
          marLStr = "padding-left:";
        }
        margin_val = marginLeft + indent < 0 ? 0 : marginLeft + indent;
        marLStr += margin_val + "px;";
      }
      let marRNode = getTextByPathList(pPrNode, ["attrs", "marR"]);
      if (marRNode === void 0 && marLNode === void 0) {
        marRNode = getTextByPathList(pPrNodeLaout, ["attrs", "marR"]);
        if (marRNode === void 0) {
          marRNode = getTextByPathList(pPrNodeMaster, ["attrs", "marR"]);
        }
      }
      if (marRNode !== void 0) {
        let marginRight = parseInt(marRNode) * this.options.slideFactor;
        if (isRTL) {
          marLStr = "padding-right:";
        } else {
          marLStr = "padding-left:";
        }
        marRStr += (marginRight + indent < 0 ? 0 : marginRight + indent) + "px;";
      }
      if (buType != "TYPE_NONE") {
      }
      if (buClrNode === void 0) {
        buClrNode = getTextByPathList(lstStyle, [lvlStr, "a:buClr"]);
      }
      if (buClrNode === void 0) {
        buClrNode = getTextByPathList(pPrNodeLaout, ["a:buClr"]);
        if (buClrNode === void 0) {
          buClrNode = getTextByPathList(pPrNodeMaster, ["a:buClr"]);
        }
      }
      let defBultColor;
      if (buClrNode !== void 0) {
        defBultColor = this.getSolidFill(buClrNode);
      } else {
        if (pFontStyle !== void 0) {
          defBultColor = this.getSolidFill(pFontStyle);
        }
      }
      if (defBultColor === void 0 || defBultColor == "NONE") {
        bultColor = dfltBultColor;
      } else {
        bultColor = [defBultColor, "", "solid"];
        color_tye = "solid";
      }
      if (buFontSize === void 0) {
        buFontSize = getTextByPathList(pPrNodeLaout, ["a:buSzPts", "attrs", "val"]);
        if (buFontSize === void 0) {
          buFontSize = getTextByPathList(pPrNodeLaout, ["a:buSzPct", "attrs", "val"]);
          if (buFontSize !== void 0) {
            let prcnt = parseInt(buFontSize) / 1e5;
            let dfltBultSizeNoPt = parseInt(dfltBultSize);
            bultSize = prcnt * dfltBultSizeNoPt + "px";
          }
        } else {
          bultSize = parseInt(buFontSize) / 100 * this.options.fontSizeFactor + "px";
        }
      }
      if (buFontSize === void 0) {
        buFontSize = getTextByPathList(pPrNodeMaster, ["a:buSzPts", "attrs", "val"]);
        if (buFontSize === void 0) {
          buFontSize = getTextByPathList(pPrNodeMaster, ["a:buSzPct", "attrs", "val"]);
          if (buFontSize !== void 0) {
            let prcnt = parseInt(buFontSize) / 1e5;
            let dfltBultSizeNoPt = parseInt(dfltBultSize);
            bultSize = prcnt * dfltBultSizeNoPt + "px";
          }
        } else {
          bultSize = parseInt(buFontSize) / 100 * this.options.fontSizeFactor + "px";
        }
      }
      if (buFontSize === void 0) {
        bultSize = dfltBultSize;
      }
      font_val = parseInt(bultSize);
      if (buType == "TYPE_BULLET") {
        let typefaceNode = getTextByPathList(pPrNode, ["a:buFont", "attrs", "typeface"]);
        let typeface = "";
        if (typefaceNode !== void 0) {
          typeface = "font-family: " + typefaceNode;
        }
        bullet = "<div style='height: 100%;" + typeface + ";" + marLStr + marRStr + "font-size:" + bultSize + ";";
        if (color_tye == "solid") {
          if (bultColor[0] !== void 0 && bultColor[0] != "") {
            bullet += "color:#" + bultColor[0] + "; ";
          }
          if (bultColor[1] !== void 0 && bultColor[1] != "" && bultColor[1] != ";") {
            bullet += "text-shadow:" + bultColor[1] + ";";
          }
        } else if (color_tye == "pattern" || color_tye == "pic" || color_tye == "gradient") {
          if (color_tye == "pattern") {
            bullet += "background:" + bultColor[0][0] + ";";
            if (bultColor[0][1] !== null && bultColor[0][1] !== void 0 && bultColor[0][1] != "") {
              bullet += "background-size:" + bultColor[0][1] + ";";
            }
            if (bultColor[0][2] !== null && bultColor[0][2] !== void 0 && bultColor[0][2] != "") {
              bullet += "background-position:" + bultColor[0][2] + ";";
            }
          } else if (color_tye == "pic") {
            bullet += bultColor[0] + ";";
          } else if (color_tye == "gradient") {
            let colorAry = bultColor[0].color;
            let rot = bultColor[0].rot;
            bullet += "background: linear-gradient(" + rot + "deg,";
            for (var i = 0; i < colorAry.length; i++) {
              if (i == colorAry.length - 1) {
                bullet += "#" + colorAry[i] + ");";
              } else {
                bullet += "#" + colorAry[i] + ", ";
              }
            }
          }
          bullet += "-webkit-background-clip: text;background-clip: text;color: transparent;";
          if (bultColor[1].border !== void 0 && bultColor[1].border !== "") {
            bullet += "-webkit-text-stroke: " + bultColor[1].border + ";";
          }
          if (bultColor[1].effcts !== void 0 && bultColor[1].effcts !== "") {
            bullet += "filter: " + bultColor[1].effcts + ";";
          }
        }
        if (isRTL) {
          bullet += "white-space: nowrap ;direction:rtl";
        }
        let isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
        let htmlBu = buChar;
        if (!isIE11) {
          htmlBu = getHtmlBullet(typefaceNode, buChar);
        }
        bullet += "'><div style='line-height: " + font_val / 2 + "px;'>" + htmlBu + "</div></div>";
      } else if (buType == "TYPE_NUMERIC") {
        bullet = "<div style='height: 100%;" + marLStr + marRStr + "color:#" + bultColor[0] + ";font-size:" + bultSize + ";";
        if (isRTL) {
          bullet += "display: inline-block;white-space: nowrap ;direction:rtl;";
        } else {
          bullet += "display: inline-block;white-space: nowrap ;direction:ltr;";
        }
        bullet += "' data-bulltname = '" + buNum + "' data-bulltlvl = '" + lvl + "' class='numeric-bullet-style'></div>";
      } else if (buType == "TYPE_BULPIC") {
        let buPicId = getTextByPathList(buPic, ["a:blip", "attrs", "r:embed"]);
        let svgPicPath = "";
        let buImg;
        if (buPicId !== void 0) {
          let imgPath = (_b = this.resources) == null ? void 0 : _b.slideResObj[buPicId]["target"];
          let imgBase64 = yield (_c = this.options.resourceReader) == null ? void 0 : _c.getImgBase64Data(imgPath);
          if (imgBase64) {
            buImg = "<img src='" + imgBase64 + "' style='width: 100%;'/>";
          }
        }
        if (buPicId === void 0) {
          buImg = "&#8227;";
        }
        bullet = "<div style='height: 100%;" + marLStr + marRStr + "width:" + bultSize + ";display: inline-block; ";
        if (isRTL) {
          bullet += "display: inline-block;white-space: nowrap ;direction:rtl;";
        }
        bullet += "'>" + buImg + "  </div>";
      }
      return [bullet, margin_val, font_val];
    });
  }
  getLayoutAndMasterNode(node, idx, type) {
    var _a, _b, _c, _d;
    let pPrNodeLaout, pPrNodeMaster;
    let pPrNode = node["a:pPr"];
    let lvl = 1;
    let lvlNode = getTextByPathList(pPrNode, ["attrs", "lvl"]);
    if (lvlNode !== void 0) {
      lvl = parseInt(lvlNode) + 1;
    }
    const slideLayoutTables = (_a = this.resources) == null ? void 0 : _a.slideLayoutTables;
    const slideMasterTextStyles = (_b = this.resources) == null ? void 0 : _b.slideMasterTextStyles;
    if (idx !== void 0) {
      pPrNodeLaout = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:lstStyle", "a:lvl" + lvl + "pPr"]);
      if (pPrNodeLaout === void 0) {
        pPrNodeLaout = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:p", "a:pPr"]);
        if (pPrNodeLaout === void 0) {
          pPrNodeLaout = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:p", lvl - 1, "a:pPr"]);
        }
      }
    }
    if (type !== void 0) {
      let lvlStr = "a:lvl" + lvl + "pPr";
      if (pPrNodeLaout === void 0) {
        pPrNodeLaout = getTextByPathList(slideLayoutTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlStr]);
      }
      if (type == "title" || type == "ctrTitle") {
        pPrNodeMaster = getTextByPathList(slideMasterTextStyles, ["p:titleStyle", lvlStr]);
      } else if (type == "body" || type == "obj" || type == "subTitle") {
        pPrNodeMaster = getTextByPathList(slideMasterTextStyles, ["p:bodyStyle", lvlStr]);
      } else if (type == "shape" || type == "diagram") {
        pPrNodeMaster = getTextByPathList(slideMasterTextStyles, ["p:otherStyle", lvlStr]);
      } else if (type == "textBox") {
        pPrNodeMaster = getTextByPathList((_c = this.options.basicInfo) == null ? void 0 : _c.defaultTextStyle, [lvlStr]);
      } else {
        pPrNodeMaster = getTextByPathList((_d = this.resources) == null ? void 0 : _d.slideMasterTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlStr]);
      }
    }
    return {
      "nodeLaout": pPrNodeLaout,
      "nodeMaster": pPrNodeMaster
    };
  }
  genSpanElement(node, rIndex, pNode, textBodyNode, pFontStyle, slideLayoutSpNode, idx, type, rNodeLength, isBullate) {
    var _a, _b, _c, _d;
    let text_style = "";
    let lstStyle = textBodyNode["a:lstStyle"];
    let text = node["a:t"];
    let openElemnt = "<span";
    let closeElemnt = "</span>";
    let styleText = "";
    if (text === void 0 && node["type"] !== void 0) {
      if (this.isFirstBr) {
        this.isFirstBr = false;
        return "<span class='line-break-br' ></span>";
      } else {
      }
      styleText += "display: block;";
    } else {
      this.isFirstBr = true;
    }
    if (typeof text !== "string") {
      text = getTextByPathList(node, ["a:fld", "a:t"]);
      if (typeof text !== "string") {
        text = "&nbsp;";
      }
    }
    let pPrNode = pNode["a:pPr"];
    let lvl = 1;
    let lvlNode = getTextByPathList(pPrNode, ["attrs", "lvl"]);
    if (lvlNode !== void 0) {
      lvl = parseInt(lvlNode) + 1;
    }
    let layoutMasterNode = this.getLayoutAndMasterNode(pNode, idx, type);
    let pPrNodeLaout = layoutMasterNode.nodeLaout;
    let pPrNodeMaster = layoutMasterNode.nodeMaster;
    let lang = getTextByPathList(node, ["a:rPr", "attrs", "lang"]);
    let isRtlLan = lang !== void 0 && rtlLangs.indexOf(lang) !== -1 ? true : false;
    let getRtlVal = getTextByPathList(pPrNode, ["attrs", "rtl"]);
    if (getRtlVal === void 0) {
      getRtlVal = getTextByPathList(pPrNodeLaout, ["attrs", "rtl"]);
      if (getRtlVal === void 0 && type != "shape") {
        getRtlVal = getTextByPathList(pPrNodeMaster, ["attrs", "rtl"]);
      }
    }
    let isRTL = false;
    let dirStr = "ltr";
    if (getRtlVal !== void 0 && getRtlVal == "1") {
      isRTL = true;
      dirStr = "rtl";
    }
    let linkID = getTextByPathList(node, ["a:rPr", "a:hlinkClick", "attrs", "r:id"]);
    let linkTooltip = "";
    let defLinkClr;
    if (linkID !== void 0) {
      linkTooltip = getTextByPathList(node, ["a:rPr", "a:hlinkClick", "attrs", "tooltip"]);
      if (linkTooltip !== void 0) {
        linkTooltip = "title='" + linkTooltip + "'";
      }
      defLinkClr = this.getSchemeColorFromTheme("a:hlink");
      let linkClrNode = getTextByPathList(node, ["a:rPr", "a:solidFill"]);
      let rPrlinkClr = this.getSolidFill(linkClrNode);
      if (rPrlinkClr !== void 0 && rPrlinkClr != "") {
        defLinkClr = rPrlinkClr;
      }
    }
    let fontClrPr = this.getFontColorPr(node, pNode, lstStyle, pFontStyle, lvl, idx, type);
    let fontClrType = fontClrPr[2];
    if (fontClrType == "solid") {
      if (linkID === void 0 && fontClrPr[0] !== void 0 && fontClrPr[0] != "") {
        styleText += "color: #" + fontClrPr[0] + ";";
      } else if (linkID !== void 0 && defLinkClr !== void 0) {
        styleText += "color: #" + defLinkClr + ";";
      }
      if (fontClrPr[1] !== void 0 && fontClrPr[1] != "" && fontClrPr[1] != ";") {
        styleText += "text-shadow:" + fontClrPr[1] + ";";
      }
      if (fontClrPr[3] !== void 0 && fontClrPr[3] != "") {
        styleText += "background-color: #" + fontClrPr[3] + ";";
      }
    } else if (fontClrType == "pattern" || fontClrType == "pic" || fontClrType == "gradient") {
      if (fontClrType == "pattern") {
        styleText += "background:" + fontClrPr[0][0] + ";";
        if (fontClrPr[0][1] !== null && fontClrPr[0][1] !== void 0 && fontClrPr[0][1] != "") {
          styleText += "background-size:" + fontClrPr[0][1] + ";";
        }
        if (fontClrPr[0][2] !== null && fontClrPr[0][2] !== void 0 && fontClrPr[0][2] != "") {
          styleText += "background-position:" + fontClrPr[0][2] + ";";
        }
      } else if (fontClrType == "pic") {
        styleText += fontClrPr[0] + ";";
      } else if (fontClrType == "gradient") {
        let colorAry = fontClrPr[0].color;
        let rot = fontClrPr[0].rot;
        styleText += "background: linear-gradient(" + rot + "deg,";
        for (var i = 0; i < colorAry.length; i++) {
          if (i == colorAry.length - 1) {
            styleText += "#" + colorAry[i] + ");";
          } else {
            styleText += "#" + colorAry[i] + ", ";
          }
        }
      }
      styleText += "-webkit-background-clip: text;background-clip: text;color: transparent;";
      if (fontClrPr[1].border !== void 0 && fontClrPr[1].border !== "") {
        styleText += "-webkit-text-stroke: " + fontClrPr[1].border + ";";
      }
      if (fontClrPr[1].effcts !== void 0 && fontClrPr[1].effcts !== "") {
        styleText += "filter: " + fontClrPr[1].effcts + ";";
      }
    }
    let font_size = this.getFontSize(node, textBodyNode, pFontStyle, lvl, type);
    text_style += "font-size:" + font_size + ";font-family:" + this.getFontType(node, type, pFontStyle) + ";font-weight:" + this.getFontBold(node) + ";font-style:" + this.getFontItalic(node) + ";text-decoration:" + this.getFontDecoration(node) + ";text-align:" + this.getTextHorizontalAlign(node, pNode, type) + ";vertical-align:" + this.getTextVerticalAlign(node) + ";";
    if (isRtlLan) {
      styleText += "direction:rtl;";
    } else {
      styleText += "direction:ltr;";
    }
    let highlight = getTextByPathList(node, ["a:rPr", "a:highlight"]);
    if (highlight !== void 0) {
      styleText += "background-color:#" + this.getSolidFill(highlight) + ";";
    }
    let spcNode = getTextByPathList(node, ["a:rPr", "attrs", "spc"]);
    if (spcNode === void 0) {
      spcNode = getTextByPathList(pPrNodeLaout, ["a:defRPr", "attrs", "spc"]);
      if (spcNode === void 0) {
        spcNode = getTextByPathList(pPrNodeMaster, ["a:defRPr", "attrs", "spc"]);
      }
    }
    if (spcNode !== void 0) {
      let ltrSpc = parseInt(spcNode) / 100;
      styleText += "letter-spacing: " + ltrSpc + "px;";
    }
    let capNode = getTextByPathList(node, ["a:rPr", "attrs", "cap"]);
    if (capNode === void 0) {
      capNode = getTextByPathList(pPrNodeLaout, ["a:defRPr", "attrs", "cap"]);
      if (capNode === void 0) {
        capNode = getTextByPathList(pPrNodeMaster, ["a:defRPr", "attrs", "cap"]);
      }
    }
    if (capNode == "small" || capNode == "all") {
      styleText += "text-transform: uppercase";
    }
    let cssName = "";
    if ((_a = this.options.styleTable) == null ? void 0 : _a.has(styleText)) {
      cssName = this.options.styleTable.get(styleText).name;
    } else {
      cssName = "_css_" + ((_b = this.options.styleTable) == null ? void 0 : _b.nextIndex());
      (_c = this.options.styleTable) == null ? void 0 : _c.update(styleText, {
        "name": cssName,
        "text": styleText
      });
    }
    let linkColorSyle = "";
    if (fontClrType == "solid" && linkID !== void 0) {
      linkColorSyle = "style='color: inherit;'";
    }
    if (linkID !== void 0 && linkID != "") {
      let linkURL = (_d = this.resources) == null ? void 0 : _d["slideResObj"][linkID]["target"];
      linkURL = escapeHtml(linkURL);
      return openElemnt + " class='text-block " + cssName + "' style='" + text_style + "'><a href='" + linkURL + "' " + linkColorSyle + "  " + linkTooltip + " target='_blank'>" + escapeHtml(text) + "</a>" + closeElemnt;
    } else {
      return openElemnt + " class='text-block " + cssName + "' style='" + text_style + "'>" + escapeHtml(text) + closeElemnt;
    }
  }
  getPregraphMargn(pNode, idx, type, isBullate) {
    if (!isBullate) {
      return ["", 0];
    }
    let marLStr = "", marRStr = "", maginVal = 0;
    let pPrNode = pNode["a:pPr"];
    let layoutMasterNode = this.getLayoutAndMasterNode(pNode, idx, type);
    let pPrNodeLaout = layoutMasterNode.nodeLaout;
    let pPrNodeMaster = layoutMasterNode.nodeMaster;
    let getRtlVal = getTextByPathList(pPrNode, ["attrs", "rtl"]);
    if (getRtlVal === void 0) {
      getRtlVal = getTextByPathList(pPrNodeLaout, ["attrs", "rtl"]);
      if (getRtlVal === void 0 && type != "shape") {
        getRtlVal = getTextByPathList(pPrNodeMaster, ["attrs", "rtl"]);
      }
    }
    let isRTL = false;
    let dirStr = "ltr";
    if (getRtlVal !== void 0 && getRtlVal == "1") {
      isRTL = true;
      dirStr = "rtl";
    }
    let alignNode = getTextByPathList(pPrNode, ["attrs", "algn"]);
    if (alignNode === void 0) {
      alignNode = getTextByPathList(pPrNodeLaout, ["attrs", "algn"]);
      if (alignNode === void 0) {
        alignNode = getTextByPathList(pPrNodeMaster, ["attrs", "algn"]);
      }
    }
    let indentNode = getTextByPathList(pPrNode, ["attrs", "indent"]);
    if (indentNode === void 0) {
      indentNode = getTextByPathList(pPrNodeLaout, ["attrs", "indent"]);
      if (indentNode === void 0) {
        indentNode = getTextByPathList(pPrNodeMaster, ["attrs", "indent"]);
      }
    }
    let indent = 0;
    if (indentNode !== void 0) {
      indent = parseInt(indentNode) * this.options.slideFactor;
    }
    let marLNode = getTextByPathList(pPrNode, ["attrs", "marL"]);
    if (marLNode === void 0) {
      marLNode = getTextByPathList(pPrNodeLaout, ["attrs", "marL"]);
      if (marLNode === void 0) {
        marLNode = getTextByPathList(pPrNodeMaster, ["attrs", "marL"]);
      }
    }
    let marginLeft = 0;
    if (marLNode !== void 0) {
      marginLeft = parseInt(marLNode) * this.options.slideFactor;
    }
    if (indentNode !== void 0 || marLNode !== void 0) {
      if (isRTL) {
        marLStr = "padding-right: ";
      } else {
        marLStr = "padding-left: ";
      }
      if (isBullate) {
        maginVal = Math.abs(0 - indent);
        marLStr += maginVal + "px;";
      } else {
        maginVal = Math.abs(marginLeft + indent);
        marLStr += maginVal + "px;";
      }
    }
    let marRNode = getTextByPathList(pPrNode, ["attrs", "marR"]);
    if (marRNode === void 0 && marLNode === void 0) {
      marRNode = getTextByPathList(pPrNodeLaout, ["attrs", "marR"]);
      if (marRNode === void 0) {
        marRNode = getTextByPathList(pPrNodeMaster, ["attrs", "marR"]);
      }
    }
    if (marRNode !== void 0 && isBullate) {
      let marginRight = parseInt(marRNode) * this.options.slideFactor;
      if (isRTL) {
        marRStr = "padding-right: ";
      } else {
        marRStr = "padding-left: ";
      }
      marRStr += Math.abs(0 - indent) + "px;";
    }
    return [marLStr, maginVal];
  }
  genTable(node) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      let order = (_a = node["attrs"]) == null ? void 0 : _a["order"];
      let tableNode = getTextByPathList(node, ["a:graphic", "a:graphicData", "a:tbl"]);
      let xfrmNode = getTextByPathList(node, ["p:xfrm"]);
      let getTblPr = getTextByPathList(node, ["a:graphic", "a:graphicData", "a:tbl", "a:tblPr"]);
      let getColsGrid = getTextByPathList(node, ["a:graphic", "a:graphicData", "a:tbl", "a:tblGrid", "a:gridCol"]);
      let tblDir = "";
      if (getTblPr !== void 0) {
        let isRTL = (_b = getTblPr["attrs"]) == null ? void 0 : _b["rtl"];
        tblDir = isRTL == 1 ? "dir=rtl" : "dir=ltr";
      }
      let firstRowAttr = (_c = getTblPr["attrs"]) == null ? void 0 : _c["firstRow"];
      let firstColAttr = (_d = getTblPr["attrs"]) == null ? void 0 : _d["firstCol"];
      let lastRowAttr = (_e = getTblPr["attrs"]) == null ? void 0 : _e["lastRow"];
      let lastColAttr = (_f = getTblPr["attrs"]) == null ? void 0 : _f["lastCol"];
      let bandRowAttr = (_g = getTblPr["attrs"]) == null ? void 0 : _g["bandRow"];
      let bandColAttr = (_h = getTblPr["attrs"]) == null ? void 0 : _h["bandCol"];
      let tblStylAttrObj = {
        isFrstRowAttr: firstRowAttr !== void 0 && firstRowAttr == "1" ? 1 : 0,
        isFrstColAttr: firstColAttr !== void 0 && firstColAttr == "1" ? 1 : 0,
        isLstRowAttr: lastRowAttr !== void 0 && lastRowAttr == "1" ? 1 : 0,
        isLstColAttr: lastColAttr !== void 0 && lastColAttr == "1" ? 1 : 0,
        isBandRowAttr: bandRowAttr !== void 0 && bandRowAttr == "1" ? 1 : 0,
        isBandColAttr: bandColAttr !== void 0 && bandColAttr == "1" ? 1 : 0
      };
      let thisTblStyle;
      let tbleStyleId = getTblPr["a:tableStyleId"];
      if (tbleStyleId !== void 0) {
        let tbleStylList = (_j = (_i = this.options.tableStyles) == null ? void 0 : _i["a:tblStyleLst"]) == null ? void 0 : _j["a:tblStyle"];
        if (tbleStylList !== void 0) {
          if (Array.isArray(tbleStylList)) {
            for (var k = 0; k < tbleStylList.length; k++) {
              if (((_k = tbleStylList[k]["attrs"]) == null ? void 0 : _k["styleId"]) == tbleStyleId) {
                thisTblStyle = tbleStylList[k];
              }
            }
          } else {
            if (((_l = tbleStylList["attrs"]) == null ? void 0 : _l["styleId"]) == tbleStyleId) {
              thisTblStyle = tbleStylList;
            }
          }
        }
      }
      if (thisTblStyle !== void 0) {
        thisTblStyle["tblStylAttrObj"] = tblStylAttrObj;
        if (this.resources) {
          this.resources.tableStyles = thisTblStyle;
        }
      }
      let tblStyl = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle"]);
      let tblBorderStyl = getTextByPathList(tblStyl, ["a:tcBdr"]);
      let tbl_borders = "";
      if (tblBorderStyl !== void 0) {
        tbl_borders = this.getTableBorders(tblBorderStyl);
      }
      let tbl_bgcolor = "";
      let tbl_opacity = 1;
      let tbl_bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:tblBg", "a:fillRef"]);
      if (tbl_bgFillschemeClr !== void 0) {
        tbl_bgcolor = this.getSolidFill(tbl_bgFillschemeClr);
      }
      if (tbl_bgFillschemeClr === void 0) {
        tbl_bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:fill", "a:solidFill"]);
        tbl_bgcolor = this.getSolidFill(tbl_bgFillschemeClr);
      }
      if (tbl_bgcolor !== "") {
        tbl_bgcolor = "background-color: #" + tbl_bgcolor + ";";
      }
      let tableHtml = "<table " + tblDir + " style='border-collapse: collapse;" + this.getPosition(xfrmNode, node, void 0, void 0) + this.getSize(xfrmNode, node, void 0, void 0) + " z-index: " + order + ";" + tbl_borders + ";" + tbl_bgcolor + "'>";
      let trNodes = tableNode["a:tr"];
      if (trNodes.constructor !== Array) {
        trNodes = [trNodes];
      }
      let totalrowSpan = 0;
      let rowSpanAry = [];
      for (var i = 0; i < trNodes.length; i++) {
        let rowHeightParam = (_m = trNodes[i]["attrs"]) == null ? void 0 : _m["h"];
        let rowHeight = 0;
        let rowsStyl = "";
        if (rowHeightParam !== void 0) {
          rowHeight = parseInt(rowHeightParam) * this.options.slideFactor;
          rowsStyl += "height:" + rowHeight + "px;";
        }
        let fillColor = "";
        let row_borders = "";
        let fontClrPr = "";
        let fontWeight = "";
        let band_1H_fillColor;
        let band_2H_fillColor;
        if (thisTblStyle !== void 0 && thisTblStyle["a:wholeTbl"] !== void 0) {
          let bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:fill", "a:solidFill"]);
          if (bgFillschemeClr !== void 0) {
            let local_fillColor = this.getSolidFill(bgFillschemeClr);
            if (local_fillColor !== void 0) {
              fillColor = local_fillColor;
            }
          }
          let rowTxtStyl = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcTxStyle"]);
          if (rowTxtStyl !== void 0) {
            let local_fontColor = this.getSolidFill(rowTxtStyl);
            if (local_fontColor !== void 0) {
              fontClrPr = local_fontColor;
            }
            let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
            if (local_fontWeight != "") {
              fontWeight = local_fontWeight;
            }
          }
        }
        if (i == 0 && tblStylAttrObj["isFrstRowAttr"] == 1 && thisTblStyle !== void 0) {
          let bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:firstRow", "a:tcStyle", "a:fill", "a:solidFill"]);
          if (bgFillschemeClr !== void 0) {
            let local_fillColor = this.getSolidFill(bgFillschemeClr);
            if (local_fillColor !== void 0) {
              fillColor = local_fillColor;
            }
          }
          let borderStyl = getTextByPathList(thisTblStyle, ["a:firstRow", "a:tcStyle", "a:tcBdr"]);
          if (borderStyl !== void 0) {
            let local_row_borders = this.getTableBorders(borderStyl);
            if (local_row_borders != "") {
              row_borders = local_row_borders;
            }
          }
          let rowTxtStyl = getTextByPathList(thisTblStyle, ["a:firstRow", "a:tcTxStyle"]);
          if (rowTxtStyl !== void 0) {
            let local_fontClrPr = this.getSolidFill(rowTxtStyl);
            if (local_fontClrPr !== void 0) {
              fontClrPr = local_fontClrPr;
            }
            let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
            if (local_fontWeight !== "") {
              fontWeight = local_fontWeight;
            }
          }
        } else if (i > 0 && tblStylAttrObj["isBandRowAttr"] == 1 && thisTblStyle !== void 0) {
          fillColor = "";
          row_borders = void 0;
          if (i % 2 == 0 && thisTblStyle["a:band2H"] !== void 0) {
            let bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:band2H", "a:tcStyle", "a:fill", "a:solidFill"]);
            if (bgFillschemeClr !== void 0) {
              let local_fillColor = this.getSolidFill(bgFillschemeClr);
              if (local_fillColor !== "") {
                fillColor = local_fillColor;
                band_2H_fillColor = local_fillColor;
              }
            }
            let borderStyl = getTextByPathList(thisTblStyle, ["a:band2H", "a:tcStyle", "a:tcBdr"]);
            if (borderStyl !== void 0) {
              let local_row_borders = this.getTableBorders(borderStyl);
              if (local_row_borders != "") {
                row_borders = local_row_borders;
              }
            }
            let rowTxtStyl = getTextByPathList(thisTblStyle, ["a:band2H", "a:tcTxStyle"]);
            if (rowTxtStyl !== void 0) {
              let local_fontClrPr = this.getSolidFill(rowTxtStyl);
              if (local_fontClrPr !== void 0) {
                fontClrPr = local_fontClrPr;
              }
            }
            let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
            if (local_fontWeight !== "") {
              fontWeight = local_fontWeight;
            }
          }
          if (i % 2 != 0 && thisTblStyle["a:band1H"] !== void 0) {
            let bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:band1H", "a:tcStyle", "a:fill", "a:solidFill"]);
            if (bgFillschemeClr !== void 0) {
              let local_fillColor = this.getSolidFill(bgFillschemeClr);
              if (local_fillColor !== void 0) {
                fillColor = local_fillColor;
                band_1H_fillColor = local_fillColor;
              }
            }
            let borderStyl = getTextByPathList(thisTblStyle, ["a:band1H", "a:tcStyle", "a:tcBdr"]);
            if (borderStyl !== void 0) {
              let local_row_borders = this.getTableBorders(borderStyl);
              if (local_row_borders != "") {
                row_borders = local_row_borders;
              }
            }
            let rowTxtStyl = getTextByPathList(thisTblStyle, ["a:band1H", "a:tcTxStyle"]);
            if (rowTxtStyl !== void 0) {
              let local_fontClrPr = this.getSolidFill(rowTxtStyl);
              if (local_fontClrPr !== void 0) {
                fontClrPr = local_fontClrPr;
              }
              let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
              if (local_fontWeight != "") {
                fontWeight = local_fontWeight;
              }
            }
          }
        }
        if (i == trNodes.length - 1 && tblStylAttrObj["isLstRowAttr"] == 1 && thisTblStyle !== void 0) {
          let bgFillschemeClr = getTextByPathList(thisTblStyle, ["a:lastRow", "a:tcStyle", "a:fill", "a:solidFill"]);
          if (bgFillschemeClr !== void 0) {
            let local_fillColor = this.getSolidFill(bgFillschemeClr);
            if (local_fillColor !== void 0) {
              fillColor = local_fillColor;
            }
          }
          let borderStyl = getTextByPathList(thisTblStyle, ["a:lastRow", "a:tcStyle", "a:tcBdr"]);
          if (borderStyl !== void 0) {
            let local_row_borders = this.getTableBorders(borderStyl);
            if (local_row_borders != "") {
              row_borders = local_row_borders;
            }
          }
          let rowTxtStyl = getTextByPathList(thisTblStyle, ["a:lastRow", "a:tcTxStyle"]);
          if (rowTxtStyl !== void 0) {
            let local_fontClrPr = this.getSolidFill(rowTxtStyl);
            if (local_fontClrPr !== void 0) {
              fontClrPr = local_fontClrPr;
            }
            let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
            if (local_fontWeight !== "") {
              fontWeight = local_fontWeight;
            }
          }
        }
        rowsStyl += row_borders !== void 0 ? row_borders : "";
        rowsStyl += fontClrPr !== void 0 ? " color: #" + fontClrPr + ";" : "";
        rowsStyl += fontWeight != "" ? " font-weight:" + fontWeight + ";" : "";
        if (fillColor !== void 0 && fillColor != "") {
          rowsStyl += "background-color: #" + fillColor + ";";
        }
        tableHtml += "<tr style='" + rowsStyl + "'>";
        let tcNodes = trNodes[i]["a:tc"];
        if (tcNodes !== void 0) {
          if (tcNodes.constructor === Array) {
            let j = 0;
            if (rowSpanAry.length == 0) {
              rowSpanAry = Array.apply(null, Array(tcNodes.length)).map(function() {
                return 0;
              });
            }
            let totalColSpan = 0;
            while (j < tcNodes.length) {
              if (rowSpanAry[j] == 0 && totalColSpan == 0) {
                let a_sorce;
                if (j == 0 && tblStylAttrObj["isFrstColAttr"] == 1) {
                  a_sorce = "a:firstCol";
                  if (tblStylAttrObj["isLstRowAttr"] == 1 && i == trNodes.length - 1 && getTextByPathList(thisTblStyle, ["a:seCell"]) !== void 0) {
                    a_sorce = "a:seCell";
                  } else if (tblStylAttrObj["isFrstRowAttr"] == 1 && i == 0 && getTextByPathList(thisTblStyle, ["a:neCell"]) !== void 0) {
                    a_sorce = "a:neCell";
                  }
                } else if (j > 0 && tblStylAttrObj["isBandColAttr"] == 1 && !(tblStylAttrObj["isFrstColAttr"] == 1 && i == 0) && !(tblStylAttrObj["isLstRowAttr"] == 1 && i == trNodes.length - 1) && j != tcNodes.length - 1) {
                  if (j % 2 != 0) {
                    let aBandNode = getTextByPathList(thisTblStyle, ["a:band2V"]);
                    if (aBandNode === void 0) {
                      aBandNode = getTextByPathList(thisTblStyle, ["a:band1V"]);
                      if (aBandNode !== void 0) {
                        a_sorce = "a:band2V";
                      }
                    } else {
                      a_sorce = "a:band2V";
                    }
                  }
                }
                if (j == tcNodes.length - 1 && tblStylAttrObj["isLstColAttr"] == 1) {
                  a_sorce = "a:lastCol";
                  if (tblStylAttrObj["isLstRowAttr"] == 1 && i == trNodes.length - 1 && getTextByPathList(thisTblStyle, ["a:swCell"]) !== void 0) {
                    a_sorce = "a:swCell";
                  } else if (tblStylAttrObj["isFrstRowAttr"] == 1 && i == 0 && getTextByPathList(thisTblStyle, ["a:nwCell"]) !== void 0) {
                    a_sorce = "a:nwCell";
                  }
                }
                let cellParmAry = yield this.getTableCellParams(tcNodes[j], getColsGrid, i, j, thisTblStyle, a_sorce);
                let text = cellParmAry[0];
                let colStyl = cellParmAry[1];
                let cssName = cellParmAry[2];
                let rowSpan = cellParmAry[3];
                let colSpan = cellParmAry[4];
                if (rowSpan !== void 0) {
                  totalrowSpan++;
                  rowSpanAry[j] = parseInt(rowSpan) - 1;
                  tableHtml += "<td class='" + cssName + "' data-row='" + i + "," + j + "' rowspan ='" + parseInt(rowSpan) + "' style='" + colStyl + "'>" + text + "</td>";
                } else if (colSpan !== void 0) {
                  tableHtml += "<td class='" + cssName + "' data-row='" + i + "," + j + "' colspan = '" + parseInt(colSpan) + "' style='" + colStyl + "'>" + text + "</td>";
                  totalColSpan = parseInt(colSpan) - 1;
                } else {
                  tableHtml += "<td class='" + cssName + "' data-row='" + i + "," + j + "' style = '" + colStyl + "'>" + text + "</td>";
                }
              } else {
                if (rowSpanAry[j] != 0) {
                  rowSpanAry[j] -= 1;
                }
                if (totalColSpan != 0) {
                  totalColSpan--;
                }
              }
              j++;
            }
          } else {
            let a_sorce;
            if (tblStylAttrObj["isFrstColAttr"] == 1 && !(tblStylAttrObj["isLstRowAttr"] == 1)) {
              a_sorce = "a:firstCol";
            } else if (tblStylAttrObj["isBandColAttr"] == 1 && !(tblStylAttrObj["isLstRowAttr"] == 1)) {
              let aBandNode = getTextByPathList(thisTblStyle, ["a:band2V"]);
              if (aBandNode === void 0) {
                aBandNode = getTextByPathList(thisTblStyle, ["a:band1V"]);
                if (aBandNode !== void 0) {
                  a_sorce = "a:band2V";
                }
              } else {
                a_sorce = "a:band2V";
              }
            }
            if (tblStylAttrObj["isLstColAttr"] == 1 && !(tblStylAttrObj["isLstRowAttr"] == 1)) {
              a_sorce = "a:lastCol";
            }
            let cellParmAry = yield this.getTableCellParams(tcNodes, getColsGrid, i, void 0, thisTblStyle, a_sorce);
            let text = cellParmAry[0];
            let colStyl = cellParmAry[1];
            let cssName = cellParmAry[2];
            let rowSpan = cellParmAry[3];
            if (rowSpan !== void 0) {
              tableHtml += "<td  class='" + cssName + "' rowspan='" + parseInt(rowSpan) + "' style = '" + colStyl + "'>" + text + "</td>";
            } else {
              tableHtml += "<td class='" + cssName + "' style='" + colStyl + "'>" + text + "</td>";
            }
          }
        }
        tableHtml += "</tr>";
      }
      return tableHtml;
    });
  }
  getTableCellParams(tcNodes, getColsGrid, row_idx, col_idx, thisTblStyle, cellSource) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let rowSpan = getTextByPathList(tcNodes, ["attrs", "rowSpan"]);
      let colSpan = getTextByPathList(tcNodes, ["attrs", "gridSpan"]);
      let vMerge = getTextByPathList(tcNodes, ["attrs", "vMerge"]);
      let hMerge = getTextByPathList(tcNodes, ["attrs", "hMerge"]);
      let colStyl = "word-wrap: break-word;";
      let colWidth;
      let celFillColor = "";
      let col_borders = "";
      let colFontClrPr = "";
      let colFontWeight = "";
      let lin_bottm = "", lin_top = "", lin_left = "", lin_right = "", lin_bottom_left_to_top_right = "", lin_top_left_to_bottom_right = "";
      let colSapnInt = parseInt(colSpan);
      let total_col_width = 0;
      if (!isNaN(colSapnInt) && colSapnInt > 1) {
        for (var k = 0; k < colSapnInt; k++) {
          total_col_width += parseInt(getTextByPathList(getColsGrid[col_idx + k], ["attrs", "w"]));
        }
      } else {
        total_col_width = getTextByPathList(col_idx === void 0 ? getColsGrid : getColsGrid[col_idx], ["attrs", "w"]);
      }
      let text = yield this.genTextBody(tcNodes["a:txBody"], tcNodes, void 0, void 0, void 0, void 0, total_col_width);
      if (total_col_width != 0) {
        colWidth = _2.default.toInteger(total_col_width) * this.options.slideFactor;
        colStyl += "width:" + colWidth + "px;";
      }
      lin_bottm = getTextByPathList(tcNodes, ["a:tcPr", "a:lnB"]);
      if (lin_bottm === void 0 && cellSource !== void 0) {
        if (cellSource !== void 0)
          lin_bottm = getTextByPathList(thisTblStyle[cellSource], ["a:tcStyle", "a:tcBdr", "a:bottom", "a:ln"]);
        if (lin_bottm === void 0) {
          lin_bottm = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:tcBdr", "a:bottom", "a:ln"]);
        }
      }
      lin_top = getTextByPathList(tcNodes, ["a:tcPr", "a:lnT"]);
      if (lin_top === void 0) {
        if (cellSource !== void 0)
          lin_top = getTextByPathList(thisTblStyle[cellSource], ["a:tcStyle", "a:tcBdr", "a:top", "a:ln"]);
        if (lin_top === void 0) {
          lin_top = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:tcBdr", "a:top", "a:ln"]);
        }
      }
      lin_left = getTextByPathList(tcNodes, ["a:tcPr", "a:lnL"]);
      if (lin_left === void 0) {
        if (cellSource !== void 0)
          lin_left = getTextByPathList(thisTblStyle[cellSource], ["a:tcStyle", "a:tcBdr", "a:left", "a:ln"]);
        if (lin_left === void 0) {
          lin_left = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:tcBdr", "a:left", "a:ln"]);
        }
      }
      lin_right = getTextByPathList(tcNodes, ["a:tcPr", "a:lnR"]);
      if (lin_right === void 0) {
        if (cellSource !== void 0)
          lin_right = getTextByPathList(thisTblStyle[cellSource], ["a:tcStyle", "a:tcBdr", "a:right", "a:ln"]);
        if (lin_right === void 0) {
          lin_right = getTextByPathList(thisTblStyle, ["a:wholeTbl", "a:tcStyle", "a:tcBdr", "a:right", "a:ln"]);
        }
      }
      lin_bottom_left_to_top_right = getTextByPathList(tcNodes, ["a:tcPr", "a:lnBlToTr"]);
      lin_top_left_to_bottom_right = getTextByPathList(tcNodes, ["a:tcPr", "a:InTlToBr"]);
      if (lin_bottm !== void 0 && lin_bottm != "") {
        let bottom_line_border = this.getBorder(lin_bottm, void 0, false, "");
        if (bottom_line_border != "") {
          colStyl += "border-bottom:" + bottom_line_border + ";";
        }
      }
      if (lin_top !== void 0 && lin_top != "") {
        let top_line_border = this.getBorder(lin_top, void 0, false, "");
        if (top_line_border != "") {
          colStyl += "border-top: " + top_line_border + ";";
        }
      }
      if (lin_left !== void 0 && lin_left != "") {
        let left_line_border = this.getBorder(lin_left, void 0, false, "");
        if (left_line_border != "") {
          colStyl += "border-left: " + left_line_border + ";";
        }
      }
      if (lin_right !== void 0 && lin_right != "") {
        let right_line_border = this.getBorder(lin_right, void 0, false, "");
        if (right_line_border != "") {
          colStyl += "border-right:" + right_line_border + ";";
        }
      }
      let getCelFill = getTextByPathList(tcNodes, ["a:tcPr"]);
      if (getCelFill !== void 0 && getCelFill != "") {
        let cellObj = {
          "p:spPr": getCelFill
        };
        celFillColor = yield this.getShapeFill(cellObj, void 0, false, "slide");
      }
      if (celFillColor == "" || celFillColor == "background-color: inherit;") {
        let bgFillschemeClr;
        if (cellSource !== void 0)
          bgFillschemeClr = getTextByPathList(thisTblStyle, [cellSource, "a:tcStyle", "a:fill", "a:solidFill"]);
        if (bgFillschemeClr !== void 0) {
          let local_fillColor = this.getSolidFill(bgFillschemeClr);
          if (local_fillColor !== void 0) {
            celFillColor = " background-color: #" + local_fillColor + ";";
          }
        }
      }
      let cssName = "";
      if (celFillColor !== void 0 && celFillColor != "") {
        if ((_a = this.options.styleTable) == null ? void 0 : _a.has(celFillColor)) {
          cssName = this.options.styleTable.get(celFillColor).name;
        } else {
          cssName = "_tbl_cell_css_" + ((_b = this.options.styleTable) == null ? void 0 : _b.nextIndex());
          (_c = this.options.styleTable) == null ? void 0 : _c.update(celFillColor, {
            "name": cssName,
            "text": celFillColor
          });
        }
      }
      let rowTxtStyl;
      if (cellSource !== void 0) {
        rowTxtStyl = getTextByPathList(thisTblStyle, [cellSource, "a:tcTxStyle"]);
      }
      if (rowTxtStyl !== void 0) {
        let local_fontClrPr = this.getSolidFill(rowTxtStyl);
        if (local_fontClrPr !== void 0) {
          colFontClrPr = local_fontClrPr;
        }
        let local_fontWeight = getTextByPathList(rowTxtStyl, ["attrs", "b"]) == "on" ? "bold" : "";
        if (local_fontWeight !== "") {
          colFontWeight = local_fontWeight;
        }
      }
      colStyl += colFontClrPr !== "" ? "color: #" + colFontClrPr + ";" : "";
      colStyl += colFontWeight != "" ? " font-weight:" + colFontWeight + ";" : "";
      return [text, colStyl, cssName, rowSpan, colSpan];
    });
  }
  genChart(node) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let order = (_a = node["attrs"]) == null ? void 0 : _a["order"];
      let xfrmNode = getTextByPathList(node, ["p:xfrm"]);
      const chartID = `chart-${_uuid.v4.call(void 0, )}`;
      let result = "<div id='" + chartID + "' class='block content' style='" + this.getPosition(xfrmNode, node, void 0, void 0) + this.getSize(xfrmNode, node, void 0, void 0) + " z-index: " + order + ";'></div>";
      let rid = (_b = node["a:graphic"]["a:graphicData"]["c:chart"]["attrs"]) == null ? void 0 : _b["r:id"];
      let refName = (_c = this.resources) == null ? void 0 : _c.slideResObj[rid]["target"];
      let content = yield this.readXmlFile(refName);
      let plotArea = getTextByPathList(content, ["c:chartSpace", "c:chart", "c:plotArea"]);
      let chartData = null;
      for (var key in plotArea) {
        switch (key) {
          case "c:lineChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "lineChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:barChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "barChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:pieChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "pieChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:pie3DChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "pie3DChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:areaChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "areaChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:scatterChart":
            chartData = {
              "type": "createChart",
              "data": {
                "chartID": chartID,
                "chartType": "scatterChart",
                "chartData": this.extractChartData(plotArea[key]["c:ser"])
              }
            };
            break;
          case "c:catAx":
            break;
          case "c:valAx":
            break;
          default:
        }
      }
      if (chartData !== null) {
        this.MsgQueue.push(chartData);
      }
      return result;
    });
  }
  genDiagram(node, source, sType) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let order = (_a = node["attrs"]) == null ? void 0 : _a["order"];
      let xfrmNode = getTextByPathList(node, ["p:xfrm"]);
      let dgmRelIds = getTextByPathList(node, ["a:graphic", "a:graphicData", "dgm:relIds", "attrs"]);
      let dgmClrFileId = dgmRelIds["r:cs"];
      let dgmDataFileId = dgmRelIds["r:dm"];
      let dgmLayoutFileId = dgmRelIds["r:lo"];
      let dgmQuickStyleFileId = dgmRelIds["r:qs"];
      const slideResObj = (_b = this.resources) == null ? void 0 : _b.slideResObj;
      let dgmClrFileName = slideResObj[dgmClrFileId].target, dgmDataFileName = slideResObj[dgmDataFileId].target, dgmLayoutFileName = slideResObj[dgmLayoutFileId].target, dgmQuickStyleFileName = slideResObj[dgmQuickStyleFileId].target;
      const [
        dgmClr,
        dgmData,
        dgmLayout,
        dgmQuickStyle
      ] = yield Promise.all([
        this.readXmlFile(dgmClrFileName),
        this.readXmlFile(dgmDataFileName),
        this.readXmlFile(dgmLayoutFileName),
        this.readXmlFile(dgmQuickStyleFileName)
      ]);
      let dgmDrwSpArray = getTextByPathList((_c = this.resources) == null ? void 0 : _c.digramFileContent, ["p:drawing", "p:spTree", "p:sp"]);
      let rslt = "";
      if (dgmDrwSpArray !== void 0) {
        let dgmDrwSpArrayLen = dgmDrwSpArray.length;
        for (var i = 0; i < dgmDrwSpArrayLen; i++) {
          let dspSp = dgmDrwSpArray[i];
          rslt += this.processSpNode(dspSp, node, "diagramBg", sType);
        }
      }
      return "<div class='block diagram-content' style='" + this.getPosition(xfrmNode, node, void 0, void 0, sType) + this.getSize(xfrmNode, node, void 0, void 0, sType) + "'>" + rslt + "</div>";
    });
  }
  getPosition(slideSpNode, pNode, slideLayoutSpNode, slideMasterSpNode, sType) {
    let off;
    let x = -1, y = -1;
    if (slideSpNode !== void 0) {
      off = slideSpNode["a:off"]["attrs"];
    }
    if (off === void 0 && slideLayoutSpNode !== void 0) {
      off = slideLayoutSpNode["a:off"]["attrs"];
    } else if (off === void 0 && slideMasterSpNode !== void 0) {
      off = slideMasterSpNode["a:off"]["attrs"];
    }
    if (off === void 0) {
      return "";
    } else {
      x = parseInt(off["x"]) * this.options.slideFactor;
      y = parseInt(off["y"]) * this.options.slideFactor;
      return isNaN(x) || isNaN(y) ? "" : "top:" + y + "px; left:" + x + "px;";
    }
  }
  getSize(slideSpNode, pNode, slideLayoutSpNode, slideMasterSpNode, sType) {
    let ext = void 0;
    let w = -1, h = -1;
    if (slideSpNode !== void 0) {
      ext = slideSpNode["a:ext"]["attrs"];
    } else if (slideLayoutSpNode !== void 0) {
      ext = slideLayoutSpNode["a:ext"]["attrs"];
    } else if (slideMasterSpNode !== void 0) {
      ext = slideMasterSpNode["a:ext"]["attrs"];
    }
    if (ext === void 0) {
      return "";
    } else {
      w = parseInt(ext["cx"]) * this.options.slideFactor;
      h = parseInt(ext["cy"]) * this.options.slideFactor;
      return isNaN(w) || isNaN(h) ? "" : "width:" + w + "px; height:" + h + "px;";
    }
  }
  getVerticalMargins(pNode, textBodyNode, type, idx) {
    var _a, _b;
    let lvl = 1;
    let spcBefNode = getTextByPathList(pNode, ["a:pPr", "a:spcBef", "a:spcPts", "attrs", "val"]);
    let spcAftNode = getTextByPathList(pNode, ["a:pPr", "a:spcAft", "a:spcPts", "attrs", "val"]);
    let lnSpcNode = getTextByPathList(pNode, ["a:pPr", "a:lnSpc", "a:spcPct", "attrs", "val"]);
    let lnSpcNodeType = "Pct";
    if (lnSpcNode === void 0) {
      lnSpcNode = getTextByPathList(pNode, ["a:pPr", "a:lnSpc", "a:spcPts", "attrs", "val"]);
      if (lnSpcNode !== void 0) {
        lnSpcNodeType = "Pts";
      }
    }
    let lvlNode = getTextByPathList(pNode, ["a:pPr", "attrs", "lvl"]);
    if (lvlNode !== void 0) {
      lvl = parseInt(lvlNode) + 1;
    }
    let fontSize;
    if (getTextByPathList(pNode, ["a:r"]) !== void 0) {
      let fontSizeStr = this.getFontSize(pNode["a:r"], textBodyNode, void 0, lvl, type);
      if (fontSizeStr != "inherit") {
        fontSize = parseInt(fontSizeStr);
      }
    }
    let isInLayoutOrMaster = true;
    if (type == "shape" || type == "textBox") {
      isInLayoutOrMaster = false;
    }
    if (isInLayoutOrMaster && (spcBefNode === void 0 || spcAftNode === void 0 || lnSpcNode === void 0)) {
      if (idx !== void 0) {
        let laypPrNode = getTextByPathList((_a = this.resources) == null ? void 0 : _a.slideLayoutTables, ["idxTable", idx, "p:txBody", "a:p", lvl - 1, "a:pPr"]);
        if (spcBefNode === void 0) {
          spcBefNode = getTextByPathList(laypPrNode, ["a:spcBef", "a:spcPts", "attrs", "val"]);
        }
        if (spcAftNode === void 0) {
          spcAftNode = getTextByPathList(laypPrNode, ["a:spcAft", "a:spcPts", "attrs", "val"]);
        }
        if (lnSpcNode === void 0) {
          lnSpcNode = getTextByPathList(laypPrNode, ["a:lnSpc", "a:spcPct", "attrs", "val"]);
          if (lnSpcNode === void 0) {
            lnSpcNode = getTextByPathList(laypPrNode, ["a:pPr", "a:lnSpc", "a:spcPts", "attrs", "val"]);
            if (lnSpcNode !== void 0) {
              lnSpcNodeType = "Pts";
            }
          }
        }
      }
    }
    if (isInLayoutOrMaster && (spcBefNode === void 0 || spcAftNode === void 0 || lnSpcNode === void 0)) {
      let slideMasterTextStyles = (_b = this.resources) == null ? void 0 : _b.slideMasterTextStyles;
      let dirLoc = "";
      lvl = "a:lvl" + lvl + "pPr";
      switch (type) {
        case "title":
        case "ctrTitle":
          dirLoc = "p:titleStyle";
          break;
        case "body":
        case "obj":
        case "dt":
        case "ftr":
        case "sldNum":
        case "textBox":
          dirLoc = "p:bodyStyle";
          break;
        case "shape":
        //case "textBox":
        default:
          dirLoc = "p:otherStyle";
      }
      let inLvlNode = getTextByPathList(slideMasterTextStyles, [dirLoc, lvl]);
      if (inLvlNode !== void 0) {
        if (spcBefNode === void 0) {
          spcBefNode = getTextByPathList(inLvlNode, ["a:spcBef", "a:spcPts", "attrs", "val"]);
        }
        if (spcAftNode === void 0) {
          spcAftNode = getTextByPathList(inLvlNode, ["a:spcAft", "a:spcPts", "attrs", "val"]);
        }
        if (lnSpcNode === void 0) {
          lnSpcNode = getTextByPathList(inLvlNode, ["a:lnSpc", "a:spcPct", "attrs", "val"]);
          if (lnSpcNode === void 0) {
            lnSpcNode = getTextByPathList(inLvlNode, ["a:pPr", "a:lnSpc", "a:spcPts", "attrs", "val"]);
            if (lnSpcNode !== void 0) {
              lnSpcNodeType = "Pts";
            }
          }
        }
      }
    }
    let spcBefor = 0, spcAfter = 0, spcLines = 0;
    let marginTopBottomStr = "";
    if (spcBefNode !== void 0) {
      spcBefor = parseInt(spcBefNode) / 100;
    }
    if (spcAftNode !== void 0) {
      spcAfter = parseInt(spcAftNode) / 100;
    }
    if (lnSpcNode !== void 0 && fontSize !== void 0) {
      if (lnSpcNodeType == "Pts") {
        marginTopBottomStr += "padding-top: " + (parseInt(lnSpcNode) / 100 - fontSize) + "px;";
      } else {
        let fct = parseInt(lnSpcNode) / 1e5;
        spcLines = fontSize * (fct - 1) - fontSize;
        let pTop = fct > 1 ? spcLines : 0;
        let pBottom = fct > 1 ? fontSize : 0;
        marginTopBottomStr += "padding-top: " + pBottom + "px;";
        marginTopBottomStr += "padding-bottom: " + spcLines + "px;";
      }
    }
    marginTopBottomStr += "margin-top: " + (spcBefor - 1) + "px;";
    if (spcAftNode !== void 0 || lnSpcNode !== void 0) {
      marginTopBottomStr += "margin-bottom: " + spcAfter + "px;";
    }
    return marginTopBottomStr;
  }
  getHorizontalAlign(node, textBodyNode, idx, type, prg_dir) {
    var _a, _b, _c, _d;
    let algn = getTextByPathList(node, ["a:pPr", "attrs", "algn"]);
    if (algn === void 0) {
      let lvlIdx = 1;
      let lvlNode = getTextByPathList(node, ["a:pPr", "attrs", "lvl"]);
      if (lvlNode !== void 0) {
        lvlIdx = parseInt(lvlNode) + 1;
      }
      let lvlStr = "a:lvl" + lvlIdx + "pPr";
      let lstStyle = textBodyNode["a:lstStyle"];
      algn = getTextByPathList(lstStyle, [lvlStr, "attrs", "algn"]);
      const slideLayoutTables = (_a = this.resources) == null ? void 0 : _a.slideLayoutTables;
      const slideMasterTextStyles = (_b = this.resources) == null ? void 0 : _b.slideMasterTextStyles;
      if (algn === void 0 && idx !== void 0) {
        algn = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:lstStyle", lvlStr, "attrs", "algn"]);
        if (algn === void 0) {
          algn = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:p", "a:pPr", "attrs", "algn"]);
          if (algn === void 0) {
            algn = getTextByPathList(slideLayoutTables["idxTable"][idx], ["p:txBody", "a:p", lvlIdx - 1, "a:pPr", "attrs", "algn"]);
          }
        }
      }
      if (algn === void 0) {
        if (type !== void 0) {
          algn = getTextByPathList(slideLayoutTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlStr, "attrs", "algn"]);
          if (algn === void 0) {
            if (type == "title" || type == "ctrTitle") {
              algn = getTextByPathList(slideMasterTextStyles, ["p:titleStyle", lvlStr, "attrs", "algn"]);
            } else if (type == "body" || type == "obj" || type == "subTitle") {
              algn = getTextByPathList(slideMasterTextStyles, ["p:bodyStyle", lvlStr, "attrs", "algn"]);
            } else if (type == "shape" || type == "diagram") {
              algn = getTextByPathList(slideMasterTextStyles, ["p:otherStyle", lvlStr, "attrs", "algn"]);
            } else if (type == "textBox") {
              algn = getTextByPathList((_c = this.options.basicInfo) == null ? void 0 : _c.defaultTextStyle, [lvlStr, "attrs", "algn"]);
            } else {
              algn = getTextByPathList((_d = this.resources) == null ? void 0 : _d.slideMasterTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlStr, "attrs", "algn"]);
            }
          }
        } else {
          algn = getTextByPathList(slideMasterTextStyles, ["p:bodyStyle", lvlStr, "attrs", "algn"]);
        }
      }
    }
    if (algn === void 0) {
      if (type == "title" || type == "subTitle" || type == "ctrTitle") {
        return "h-mid";
      } else if (type == "sldNum") {
        return "h-right";
      }
    }
    if (algn !== void 0) {
      switch (algn) {
        case "l":
          if (prg_dir == "pregraph-rtl") {
            return "h-left-rtl";
          } else {
            return "h-left";
          }
          break;
        case "r":
          if (prg_dir == "pregraph-rtl") {
            return "h-right-rtl";
          } else {
            return "h-right";
          }
          break;
        case "ctr":
          return "h-mid";
          break;
        case "just":
        case "dist":
        default:
          return "h-" + algn;
      }
    }
  }
  getPregraphDir(node, textBodyNode, idx, type) {
    let rtl = getTextByPathList(node, ["a:pPr", "attrs", "rtl"]);
    if (rtl === void 0) {
      let layoutMasterNode = this.getLayoutAndMasterNode(node, idx, type);
      let pPrNodeLaout = layoutMasterNode.nodeLaout;
      let pPrNodeMaster = layoutMasterNode.nodeMaster;
      rtl = getTextByPathList(pPrNodeLaout, ["attrs", "rtl"]);
      if (rtl === void 0 && type != "shape") {
        rtl = getTextByPathList(pPrNodeMaster, ["attrs", "rtl"]);
      }
    }
    if (rtl == "1") {
      return "pregraph-rtl";
    } else if (rtl == "0") {
      return "pregraph-ltr";
    }
    return "pregraph-inherit";
  }
  getVerticalAlign(node, slideLayoutSpNode, slideMasterSpNode, type) {
    let anchor = getTextByPathList(node, ["p:txBody", "a:bodyPr", "attrs", "anchor"]);
    if (anchor === void 0) {
      anchor = getTextByPathList(slideLayoutSpNode, ["p:txBody", "a:bodyPr", "attrs", "anchor"]);
      if (anchor === void 0) {
        anchor = getTextByPathList(slideMasterSpNode, ["p:txBody", "a:bodyPr", "attrs", "anchor"]);
        if (anchor === void 0) {
          anchor = "t";
        }
      }
    }
    return anchor === "ctr" ? "v-mid" : anchor === "b" ? "v-down" : "v-up";
  }
  getContentDir(node, type) {
    var _a;
    return "content";
    let defRtl = getTextByPathList(node, ["p:txBody", "a:lstStyle", "a:defPPr", "attrs", "rtl"]);
    if (defRtl !== void 0) {
      if (defRtl == "1") {
        return "content-rtl";
      } else if (defRtl == "0") {
        return "content";
      }
    }
    let rtlCol = getTextByPathList(node, ["p:txBody", "a:bodyPr", "attrs", "rtlCol"]);
    if (rtlCol !== void 0) {
      if (rtlCol == "1") {
        return "content-rtl";
      } else if (rtlCol == "0") {
        return "content";
      }
    }
    if (type === void 0) {
      return "content";
    }
    let slideMasterTextStyles = (_a = this.resources) == null ? void 0 : _a.slideMasterTextStyles;
    let dirLoc = "";
    switch (type) {
      case "title":
      case "ctrTitle":
        dirLoc = "p:titleStyle";
        break;
      case "body":
      case "dt":
      case "ftr":
      case "sldNum":
      case "textBox":
        dirLoc = "p:bodyStyle";
        break;
      case "shape":
        dirLoc = "p:otherStyle";
    }
    if (slideMasterTextStyles !== void 0 && dirLoc !== "") {
      let dirVal = getTextByPathList(slideMasterTextStyles[dirLoc], ["a:lvl1pPr", "attrs", "rtl"]);
      if (dirVal == "1") {
        return "content-rtl";
      }
    }
    return "content";
  }
  getFontType(node, type, pFontStyle) {
    var _a;
    let typeface = getTextByPathList(node, ["a:rPr", "a:latin", "attrs", "typeface"]);
    if (typeface === void 0) {
      let fontIdx = "";
      let fontGrup = "";
      if (pFontStyle !== void 0) {
        fontIdx = getTextByPathList(pFontStyle, ["attrs", "idx"]);
      }
      let fontSchemeNode = getTextByPathList((_a = this.resources) == null ? void 0 : _a.themeContent, ["a:theme", "a:themeElements", "a:fontScheme"]);
      if (fontIdx == "") {
        if (type == "title" || type == "subTitle" || type == "ctrTitle") {
          fontIdx = "major";
        } else {
          fontIdx = "minor";
        }
      }
      fontGrup = "a:" + fontIdx + "Font";
      typeface = getTextByPathList(fontSchemeNode, [fontGrup, "a:latin", "attrs", "typeface"]);
    }
    return typeface === void 0 ? "inherit" : typeface;
  }
  getFontColorPr(node, pNode, lstStyle, pFontStyle, lvl, idx, type) {
    var _a, _b, _c;
    let rPrNode = getTextByPathList(node, ["a:rPr"]);
    let filTyp, color, textBordr = "", colorType = "", highlightColor = "";
    if (rPrNode !== void 0) {
      filTyp = this.getFillType(rPrNode);
      if (filTyp == "SOLID_FILL") {
        let solidFillNode = rPrNode["a:solidFill"];
        color = this.getSolidFill(solidFillNode);
        let highlightNode = rPrNode["a:highlight"];
        if (highlightNode !== void 0) {
          highlightColor = this.getSolidFill(highlightNode);
        }
        colorType = "solid";
      } else if (filTyp == "PATTERN_FILL") {
        let pattFill = rPrNode["a:pattFill"];
        color = this.getPatternFill(pattFill);
        colorType = "pattern";
      } else if (filTyp == "PIC_FILL") {
        color = this.getBgPicFill(rPrNode, "slideBg");
        colorType = "pic";
      } else if (filTyp == "GRADIENT_FILL") {
        let shpFill = rPrNode["a:gradFill"];
        color = this.getGradientFill(shpFill);
        colorType = "gradient";
      }
    }
    if (color === void 0 && getTextByPathList(lstStyle, ["a:lvl" + lvl + "pPr", "a:defRPr"]) !== void 0) {
      let lstStyledefRPr = getTextByPathList(lstStyle, ["a:lvl" + lvl + "pPr", "a:defRPr"]);
      filTyp = this.getFillType(lstStyledefRPr);
      if (filTyp == "SOLID_FILL") {
        let solidFillNode = lstStyledefRPr["a:solidFill"];
        color = this.getSolidFill(solidFillNode);
        let highlightNode = lstStyledefRPr["a:highlight"];
        if (highlightNode !== void 0) {
          highlightColor = this.getSolidFill(highlightNode);
        }
        colorType = "solid";
      } else if (filTyp == "PATTERN_FILL") {
        let pattFill = lstStyledefRPr["a:pattFill"];
        color = this.getPatternFill(pattFill);
        colorType = "pattern";
      } else if (filTyp == "PIC_FILL") {
        color = this.getBgPicFill(lstStyledefRPr, "slideBg");
        colorType = "pic";
      } else if (filTyp == "GRADIENT_FILL") {
        let shpFill = lstStyledefRPr["a:gradFill"];
        color = this.getGradientFill(shpFill);
        colorType = "gradient";
      }
    }
    if (color === void 0) {
      let sPstyle = getTextByPathList(pNode, ["p:style", "a:fontRef"]);
      if (sPstyle !== void 0) {
        color = this.getSolidFill(sPstyle);
        if (color !== void 0) {
          colorType = "solid";
        }
        let highlightNode = sPstyle["a:highlight"];
        if (highlightNode !== void 0) {
          highlightColor = this.getSolidFill(highlightNode);
        }
      }
      if (color === void 0) {
        if (pFontStyle !== void 0) {
          color = this.getSolidFill(pFontStyle);
          if (color !== void 0) {
            colorType = "solid";
          }
        }
      }
    }
    if (color === void 0) {
      let layoutMasterNode = this.getLayoutAndMasterNode(pNode, idx, type);
      let pPrNodeLaout = layoutMasterNode.nodeLaout;
      let pPrNodeMaster = layoutMasterNode.nodeMaster;
      if (pPrNodeLaout !== void 0) {
        let defRpRLaout = getTextByPathList(pPrNodeLaout, ["a:defRPr", "a:solidFill"]);
        if (defRpRLaout !== void 0) {
          color = this.getSolidFill(defRpRLaout);
          let highlightNode = getTextByPathList(pPrNodeLaout, ["a:defRPr", "a:highlight"]);
          if (highlightNode !== void 0) {
            highlightColor = this.getSolidFill(highlightNode);
          }
          colorType = "solid";
        }
      }
      if (color === void 0) {
        if (pPrNodeMaster !== void 0) {
          let defRprMaster = getTextByPathList(pPrNodeMaster, ["a:defRPr", "a:solidFill"]);
          if (defRprMaster !== void 0) {
            color = this.getSolidFill(defRprMaster);
            let highlightNode = getTextByPathList(pPrNodeMaster, ["a:defRPr", "a:highlight"]);
            if (highlightNode !== void 0) {
              highlightColor = this.getSolidFill(highlightNode);
            }
            colorType = "solid";
          }
        }
      }
    }
    let txtEffects = [];
    let txtEffObj = {};
    let txtBrdrNode = getTextByPathList(node, ["a:rPr", "a:ln"]);
    if (txtBrdrNode !== void 0 && txtBrdrNode["a:noFill"] === void 0) {
      let txBrd = this.getBorder(node, pNode, false, "text");
      let txBrdAry = txBrd.split(" ");
      let brdSize = parseInt(txBrdAry[0].substring(0, txBrdAry[0].indexOf("px"))) + "px";
      let brdClr = txBrdAry[2];
      if (colorType == "solid") {
        textBordr = "-" + brdSize + " 0 " + brdClr + ", 0 " + brdSize + " " + brdClr + ", " + brdSize + " 0 " + brdClr + ", 0 -" + brdSize + " " + brdClr;
        txtEffects.push(textBordr);
      } else {
        txtEffObj.border = brdSize + " " + brdClr;
      }
    }
    let txtGlowNode = getTextByPathList(node, ["a:rPr", "a:effectLst", "a:glow"]);
    let oGlowStr = "";
    if (txtGlowNode !== void 0) {
      let glowClr = this.getSolidFill(txtGlowNode);
      let rad = ((_a = txtGlowNode["attrs"]) == null ? void 0 : _a["rad"]) ? ((_b = txtGlowNode["attrs"]) == null ? void 0 : _b["rad"]) * this.options.slideFactor : 0;
      oGlowStr = "0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr + ", 0 0 " + rad + "px #" + glowClr;
      if (colorType == "solid") {
        txtEffects.push(oGlowStr);
      } else {
        txtEffects.push(
          "drop-shadow(0 0 " + rad / 3 + "px #" + glowClr + ") drop-shadow(0 0 " + rad * 2 / 3 + "px #" + glowClr + ") drop-shadow(0 0 " + rad + "px #" + glowClr + ")"
        );
      }
    }
    let txtShadow = getTextByPathList(node, ["a:rPr", "a:effectLst", "a:outerShdw"]);
    let oShadowStr = "";
    if (txtShadow !== void 0) {
      let shadowClr = this.getSolidFill(txtShadow);
      let outerShdwAttrs = (_c = txtShadow["attrs"]) != null ? _c : {};
      let algn = outerShdwAttrs["algn"];
      let dir = outerShdwAttrs["dir"] ? parseInt(outerShdwAttrs["dir"]) / 6e4 : 0;
      let dist = parseInt(outerShdwAttrs["dist"]) * this.options.slideFactor;
      let rotWithShape = outerShdwAttrs["rotWithShape"];
      let blurRad = outerShdwAttrs["blurRad"] ? parseInt(outerShdwAttrs["blurRad"]) * this.options.slideFactor + "px" : "";
      let sx = outerShdwAttrs["sx"] ? parseInt(outerShdwAttrs["sx"]) / 1e5 : 1;
      let sy = outerShdwAttrs["sy"] ? parseInt(outerShdwAttrs["sy"]) / 1e5 : 1;
      let vx = dist * Math.sin(dir * Math.PI / 180);
      let hx = dist * Math.cos(dir * Math.PI / 180);
      if (!isNaN(vx) && !isNaN(hx)) {
        oShadowStr = hx + "px " + vx + "px " + blurRad + " #" + shadowClr;
        if (colorType == "solid") {
          txtEffects.push(oShadowStr);
        } else {
          txtEffects.push("drop-shadow(" + hx + "px " + vx + "px " + blurRad + " #" + shadowClr + ")");
        }
      }
    }
    let text_effcts = "", txt_effects;
    if (colorType == "solid") {
      if (txtEffects.length > 0) {
        text_effcts = txtEffects.join(",");
      }
      txt_effects = text_effcts + ";";
    } else {
      if (txtEffects.length > 0) {
        text_effcts = txtEffects.join(" ");
      }
      txtEffObj.effcts = text_effcts;
      txt_effects = txtEffObj;
    }
    return [color, txt_effects, colorType, highlightColor];
  }
  getFontSize(node, textBodyNode, pFontStyle, lvl, type) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let lstStyle = textBodyNode !== void 0 ? textBodyNode["a:lstStyle"] : void 0;
    let lvlpPr = "a:lvl" + lvl + "pPr";
    let fontSize = void 0;
    let sz, kern;
    if (node["a:rPr"] !== void 0) {
      fontSize = parseInt((_a = node["a:rPr"]["attrs"]) == null ? void 0 : _a["sz"]) / 100;
    }
    if (isNaN(fontSize) || fontSize === void 0 && node["a:fld"] !== void 0) {
      sz = getTextByPathList(node["a:fld"], ["a:rPr", "attrs", "sz"]);
      fontSize = parseInt(sz) / 100;
    }
    if ((isNaN(fontSize) || fontSize === void 0) && node["a:t"] === void 0) {
      sz = getTextByPathList(node["a:endParaRPr"], ["attrs", "sz"]);
      fontSize = parseInt(sz) / 100;
    }
    if ((isNaN(fontSize) || fontSize === void 0) && lstStyle !== void 0) {
      sz = getTextByPathList(lstStyle, [lvlpPr, "a:defRPr", "attrs", "sz"]);
      fontSize = parseInt(sz) / 100;
    }
    let isAutoFit = false;
    let isKerning = false;
    if (textBodyNode !== void 0) {
      let spAutoFitNode = getTextByPathList(textBodyNode, ["a:bodyPr", "a:spAutoFit"]);
      if (spAutoFitNode !== void 0) {
        isAutoFit = true;
        isKerning = true;
      }
    }
    if (isNaN(fontSize) || fontSize === void 0) {
      sz = getTextByPathList((_b = this.resources) == null ? void 0 : _b.slideLayoutTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlpPr, "a:defRPr", "attrs", "sz"]);
      fontSize = parseInt(sz) / 100;
      kern = getTextByPathList((_c = this.resources) == null ? void 0 : _c.slideLayoutTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlpPr, "a:defRPr", "attrs", "kern"]);
      if (isKerning && kern !== void 0 && !isNaN(fontSize) && fontSize - parseInt(kern) / 100 > 0) {
        fontSize = fontSize - parseInt(kern) / 100;
      }
    }
    if (isNaN(fontSize) || fontSize === void 0) {
      sz = getTextByPathList((_d = this.resources) == null ? void 0 : _d.slideMasterTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlpPr, "a:defRPr", "attrs", "sz"]);
      kern = getTextByPathList((_e = this.resources) == null ? void 0 : _e.slideMasterTables, ["typeTable", type, "p:txBody", "a:lstStyle", lvlpPr, "a:defRPr", "attrs", "kern"]);
      if (sz === void 0) {
        const slideMasterTextStyles = (_f = this.resources) == null ? void 0 : _f.slideMasterTextStyles;
        if (type == "title" || type == "subTitle" || type == "ctrTitle") {
          sz = getTextByPathList(slideMasterTextStyles, ["p:titleStyle", lvlpPr, "a:defRPr", "attrs", "sz"]);
          kern = getTextByPathList(slideMasterTextStyles, ["p:titleStyle", lvlpPr, "a:defRPr", "attrs", "kern"]);
        } else if (type == "body" || type == "obj" || type == "dt" || type == "sldNum" || type === "textBox") {
          sz = getTextByPathList(slideMasterTextStyles, ["p:bodyStyle", lvlpPr, "a:defRPr", "attrs", "sz"]);
          kern = getTextByPathList(slideMasterTextStyles, ["p:bodyStyle", lvlpPr, "a:defRPr", "attrs", "kern"]);
        } else if (type == "shape") {
          sz = getTextByPathList(slideMasterTextStyles, ["p:otherStyle", lvlpPr, "a:defRPr", "attrs", "sz"]);
          kern = getTextByPathList(slideMasterTextStyles, ["p:otherStyle", lvlpPr, "a:defRPr", "attrs", "kern"]);
          isKerning = false;
        }
        if (sz === void 0) {
          sz = getTextByPathList((_g = this.options.basicInfo) == null ? void 0 : _g.defaultTextStyle, [lvlpPr, "a:defRPr", "attrs", "sz"]);
          kern = kern === void 0 ? getTextByPathList((_h = this.options.basicInfo) == null ? void 0 : _h.defaultTextStyle, [lvlpPr, "a:defRPr", "attrs", "kern"]) : void 0;
          isKerning = false;
        }
      }
      fontSize = parseInt(sz) / 100;
      if (isKerning && kern !== void 0 && !isNaN(fontSize) && fontSize - parseInt(kern) / 100 > parseInt(kern) / 100) {
        fontSize = fontSize - parseInt(kern) / 100;
      }
    }
    let baseline = getTextByPathList(node, ["a:rPr", "attrs", "baseline"]);
    if (baseline !== void 0 && !isNaN(fontSize)) {
      let baselineVl = parseInt(baseline) / 1e5;
      fontSize -= baselineVl;
    }
    if (!isNaN(fontSize)) {
      let normAutofit = getTextByPathList(textBodyNode, ["a:bodyPr", "a:normAutofit", "attrs", "fontScale"]);
      if (normAutofit !== void 0 && normAutofit != 0) {
        fontSize = Math.round(fontSize * (normAutofit / 1e5));
      }
    }
    return isNaN(fontSize) ? type == "br" ? "initial" : "inherit" : fontSize * this.options.fontSizeFactor + "px";
  }
  getFontBold(node) {
    var _a;
    return node["a:rPr"] !== void 0 && ((_a = node["a:rPr"]["attrs"]) == null ? void 0 : _a["b"]) === "1" ? "bold" : "inherit";
  }
  getFontItalic(node) {
    var _a;
    return node["a:rPr"] !== void 0 && ((_a = node["a:rPr"]["attrs"]) == null ? void 0 : _a["i"]) === "1" ? "italic" : "inherit";
  }
  getFontDecoration(node) {
    var _a, _b, _c, _d;
    if (node["a:rPr"] !== void 0) {
      let underLine = ((_a = node["a:rPr"]["attrs"]) == null ? void 0 : _a["u"]) !== void 0 ? (_b = node["a:rPr"]["attrs"]) == null ? void 0 : _b["u"] : "none";
      let strikethrough = ((_c = node["a:rPr"]["attrs"]) == null ? void 0 : _c["strike"]) !== void 0 ? (_d = node["a:rPr"]["attrs"]) == null ? void 0 : _d["strike"] : "noStrike";
      if (underLine != "none" && strikethrough == "noStrike") {
        return "underline";
      } else if (underLine == "none" && strikethrough != "noStrike") {
        return "line-through";
      } else if (underLine != "none" && strikethrough != "noStrike") {
        return "underline line-through";
      } else {
        return "inherit";
      }
    } else {
      return "inherit";
    }
  }
  ////////////////////////////////////Amir/////////////////////////////////////
  getTextHorizontalAlign(node, pNode, type) {
    let getAlgn = getTextByPathList(node, ["a:pPr", "attrs", "algn"]);
    if (getAlgn === void 0) {
      getAlgn = getTextByPathList(pNode, ["a:pPr", "attrs", "algn"]);
    }
    if (getAlgn === void 0) {
      if (type == "title" || type == "ctrTitle" || type == "subTitle") {
        let lvlIdx = 1;
        let lvlNode = getTextByPathList(pNode, ["a:pPr", "attrs", "lvl"]);
        if (lvlNode !== void 0) {
          lvlIdx = parseInt(lvlNode) + 1;
        }
        let lvlStr = "a:lvl" + lvlIdx + "pPr";
        getAlgn = getTextByPathList(this.resources, ["slideLayoutTables", "typeTable", type, "p:txBody", "a:lstStyle", lvlStr, "attrs", "algn"]);
        if (getAlgn === void 0) {
          getAlgn = getTextByPathList(this.resources, ["slideMasterTables", "typeTable", type, "p:txBody", "a:lstStyle", lvlStr, "attrs", "algn"]);
          if (getAlgn === void 0) {
            getAlgn = getTextByPathList(this.resources, ["slideMasterTextStyles", "p:titleStyle", lvlStr, "attrs", "algn"]);
            if (getAlgn === void 0 && type === "subTitle") {
              getAlgn = getTextByPathList(this.resources, ["slideMasterTextStyles", "p:bodyStyle", lvlStr, "attrs", "algn"]);
            }
          }
        }
      } else if (type == "body") {
        getAlgn = getTextByPathList(this.resources, ["slideMasterTextStyles", "p:bodyStyle", "a:lvl1pPr", "attrs", "algn"]);
      } else {
        getAlgn = getTextByPathList(this.resources, ["slideMasterTables", "typeTable", type, "p:txBody", "a:lstStyle", "a:lvl1pPr", "attrs", "algn"]);
      }
    }
    let align = "inherit";
    if (getAlgn !== void 0) {
      switch (getAlgn) {
        case "l":
          align = "left";
          break;
        case "r":
          align = "right";
          break;
        case "ctr":
          align = "center";
          break;
        case "just":
          align = "justify";
          break;
        case "dist":
          align = "justify";
          break;
        default:
          align = "inherit";
      }
    }
    return align;
  }
  /////////////////////////////////////////////////////////////////////
  getTextVerticalAlign(node) {
    let baseline = getTextByPathList(node, ["a:rPr", "attrs", "baseline"]);
    return baseline === void 0 ? "baseline" : parseInt(baseline) / 1e3 + "%";
  }
  getTableBorders(node) {
    let borderStyle = "";
    if (node["a:bottom"] !== void 0) {
      let obj = {
        "p:spPr": {
          "a:ln": node["a:bottom"]["a:ln"]
        }
      };
      let borders = this.getBorder(obj, void 0, false, "shape");
      borderStyle += borders.replace("border", "border-bottom");
    }
    if (node["a:top"] !== void 0) {
      let obj = {
        "p:spPr": {
          "a:ln": node["a:top"]["a:ln"]
        }
      };
      let borders = this.getBorder(obj, void 0, false, "shape");
      borderStyle += borders.replace("border", "border-top");
    }
    if (node["a:right"] !== void 0) {
      let obj = {
        "p:spPr": {
          "a:ln": node["a:right"]["a:ln"]
        }
      };
      let borders = this.getBorder(obj, void 0, false, "shape");
      borderStyle += borders.replace("border", "border-right");
    }
    if (node["a:left"] !== void 0) {
      let obj = {
        "p:spPr": {
          "a:ln": node["a:left"]["a:ln"]
        }
      };
      let borders = this.getBorder(obj, void 0, false, "shape");
      borderStyle += borders.replace("border", "border-left");
    }
    return borderStyle;
  }
  //////////////////////////////////////////////////////////////////
  getBorder(node, pNode, isSvgMode, bType) {
    var _a;
    let cssText, lineNode, subNodeTxt, borderWidth, borderType, strokeDasharray = "0";
    if (bType == "shape") {
      cssText = "border: ";
      lineNode = node["p:spPr"]["a:ln"];
    } else if (bType == "text") {
      cssText = "";
      lineNode = node["a:rPr"]["a:ln"];
    }
    if (lineNode == void 0) {
      let lnRefNode = getTextByPathList(node, ["p:style", "a:lnRef"]);
      if (lnRefNode !== void 0) {
        let lnIdx = getTextByPathList(lnRefNode, ["attrs", "idx"]);
        lineNode = (_a = this.resources) == null ? void 0 : _a["themeContent"]["a:theme"]["a:themeElements"]["a:fmtScheme"]["a:lnStyleLst"]["a:ln"][Number(lnIdx) - 1];
      }
    }
    if (lineNode == void 0) {
      cssText = "";
      lineNode = node;
    }
    let is_noFill = getTextByPathList(lineNode, ["a:noFill"]);
    if (is_noFill !== void 0) {
      return "hidden";
    }
    let borderColor;
    if (lineNode !== void 0) {
      borderWidth = parseInt(getTextByPathList(lineNode, ["attrs", "w"])) / 12700;
      if (isNaN(borderWidth) || borderWidth < 1) {
        cssText += 4 / 3 + "px ";
      } else {
        cssText += borderWidth + "px ";
      }
      borderType = getTextByPathList(lineNode, ["a:prstDash", "attrs", "val"]);
      if (borderType === void 0) {
        borderType = getTextByPathList(lineNode, ["attrs", "cmpd"]);
      }
      switch (borderType) {
        case "solid":
          cssText += "solid";
          strokeDasharray = "0";
          break;
        case "dash":
          cssText += "dashed";
          strokeDasharray = "5";
          break;
        case "dashDot":
          cssText += "dashed";
          strokeDasharray = "5, 5, 1, 5";
          break;
        case "dot":
          cssText += "dotted";
          strokeDasharray = "1, 5";
          break;
        case "lgDash":
          cssText += "dashed";
          strokeDasharray = "10, 5";
          break;
        case "dbl":
          cssText += "double";
          strokeDasharray = "0";
          break;
        case "lgDashDotDot":
          cssText += "dashed";
          strokeDasharray = "10, 5, 1, 5, 1, 5";
          break;
        case "sysDash":
          cssText += "dashed";
          strokeDasharray = "5, 2";
          break;
        case "sysDashDot":
          cssText += "dashed";
          strokeDasharray = "5, 2, 1, 5";
          break;
        case "sysDashDotDot":
          cssText += "dashed";
          strokeDasharray = "5, 2, 1, 5, 1, 5";
          break;
        case "sysDot":
          cssText += "dotted";
          strokeDasharray = "2, 5";
          break;
        case void 0:
        //console.log(borderType);
        default:
          cssText += "solid";
          strokeDasharray = "0";
      }
      let fillTyp = this.getFillType(lineNode);
      if (fillTyp == "NO_FILL") {
        borderColor = isSvgMode ? "none" : "";
      } else if (fillTyp == "SOLID_FILL") {
        borderColor = this.getSolidFill(lineNode["a:solidFill"]);
      } else if (fillTyp == "GRADIENT_FILL") {
        borderColor = this.getGradientFill(lineNode["a:gradFill"]);
      } else if (fillTyp == "PATTERN_FILL") {
        borderColor = this.getPatternFill(lineNode["a:pattFill"]);
      }
    }
    if (borderColor === void 0) {
      let lnRefNode = getTextByPathList(node, ["p:style", "a:lnRef"]);
      if (lnRefNode !== void 0) {
        borderColor = this.getSolidFill(lnRefNode);
      }
    }
    if (borderColor === void 0) {
      if (isSvgMode) {
        borderColor = "none";
      } else {
        borderColor = "hidden";
      }
    } else {
      borderColor = "#" + borderColor;
    }
    cssText += " " + borderColor + " ";
    if (isSvgMode) {
      return { "color": borderColor, "width": borderWidth, "type": borderType, "strokeDasharray": strokeDasharray };
    } else {
      return cssText + ";";
    }
  }
  getBackground() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let slideContent = (_a = this.resources) == null ? void 0 : _a.slideContent;
      let slideLayoutContent = (_b = this.resources) == null ? void 0 : _b.slideLayoutContent;
      let slideMasterContent = (_c = this.resources) == null ? void 0 : _c.slideMasterContent;
      let nodesSldLayout = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:cSld", "p:spTree"]);
      let nodesSldMaster = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:cSld", "p:spTree"]);
      let showMasterSp = getTextByPathList(slideLayoutContent, ["p:sldLayout", "attrs", "showMasterSp"]);
      let bgColor = yield this.getSlideBackgroundFill();
      let result = "<div class='slide-background-" + this.options.index + "' style='width:" + this.options.basicInfo.width + "px; height:" + this.options.basicInfo.height + "px;" + bgColor + "'>";
      let node_ph_type_ary = [];
      if (nodesSldLayout !== void 0) {
        for (var nodeKey in nodesSldLayout) {
          if (nodesSldLayout[nodeKey].constructor === Array) {
            for (var i = 0; i < nodesSldLayout[nodeKey].length; i++) {
              let ph_type = getTextByPathList(nodesSldLayout[nodeKey][i], ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
              if (ph_type != "pic") {
                result += yield this.processNodesInSlide(nodeKey, nodesSldLayout[nodeKey][i], nodesSldLayout, "slideLayoutBg");
              }
            }
          } else {
            let ph_type = getTextByPathList(nodesSldLayout[nodeKey], ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
            if (ph_type != "pic") {
              result += yield this.processNodesInSlide(nodeKey, nodesSldLayout[nodeKey], nodesSldLayout, "slideLayoutBg");
            }
          }
        }
      }
      if (nodesSldMaster !== void 0 && (showMasterSp == "1" || showMasterSp === void 0)) {
        for (var nodeKey in nodesSldMaster) {
          if (nodesSldMaster[nodeKey].constructor === Array) {
            for (var i = 0; i < nodesSldMaster[nodeKey].length; i++) {
              let ph_type = getTextByPathList(nodesSldMaster[nodeKey][i], ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
              result += yield this.processNodesInSlide(nodeKey, nodesSldMaster[nodeKey][i], nodesSldMaster, "slideMasterBg");
            }
          } else {
            let ph_type = getTextByPathList(nodesSldMaster[nodeKey], ["p:nvSpPr", "p:nvPr", "p:ph", "attrs", "type"]);
            result += yield this.processNodesInSlide(nodeKey, nodesSldMaster[nodeKey], nodesSldMaster, "slideMasterBg");
          }
        }
      }
      result += "</div>";
      return result;
    });
  }
  getSlideBackgroundFill() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    let slideContent = (_a = this.resources) == null ? void 0 : _a.slideContent;
    let slideLayoutContent = (_b = this.resources) == null ? void 0 : _b.slideLayoutContent;
    let slideMasterContent = (_c = this.resources) == null ? void 0 : _c.slideMasterContent;
    let bgPr = getTextByPathList(slideContent, ["p:sld", "p:cSld", "p:bg", "p:bgPr"]);
    let bgRef = getTextByPathList(slideContent, ["p:sld", "p:cSld", "p:bg", "p:bgRef"]);
    let bgcolor;
    if (bgPr !== void 0) {
      let bgFillTyp = this.getFillType(bgPr);
      if (bgFillTyp == "SOLID_FILL") {
        let sldFill = bgPr["a:solidFill"];
        let clrMapOvr;
        let sldClrMapOvr = getTextByPathList(slideContent, ["p:sld", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
        if (sldClrMapOvr !== void 0) {
          clrMapOvr = sldClrMapOvr;
        } else {
          let sldClrMapOvr2 = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
          if (sldClrMapOvr2 !== void 0) {
            clrMapOvr = sldClrMapOvr2;
          } else {
            clrMapOvr = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:clrMap", "attrs"]);
          }
        }
        let sldBgClr = this.getSolidFill(sldFill, clrMapOvr);
        bgcolor = "background: #" + sldBgClr + ";";
      } else if (bgFillTyp == "GRADIENT_FILL") {
        bgcolor = this.getBgGradientFill(bgPr);
      } else if (bgFillTyp == "PIC_FILL") {
        bgcolor = this.getBgPicFill(bgPr, "slideBg");
      }
    } else if (bgRef !== void 0) {
      let clrMapOvr;
      let sldClrMapOvr = getTextByPathList(slideContent, ["p:sld", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
      if (sldClrMapOvr !== void 0) {
        clrMapOvr = sldClrMapOvr;
      } else {
        let sldClrMapOvr2 = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
        if (sldClrMapOvr2 !== void 0) {
          clrMapOvr = sldClrMapOvr2;
        } else {
          clrMapOvr = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:clrMap", "attrs"]);
        }
      }
      let phClr = this.getSolidFill(bgRef, clrMapOvr);
      let idx = Number((_d = bgRef["attrs"]) == null ? void 0 : _d["idx"]);
      if (idx == 0 || idx == 1e3) {
      } else if (idx > 0 && idx < 1e3) {
      } else if (idx > 1e3) {
        let trueIdx = idx - 1e3;
        let bgFillLst = (_e = this.resources) == null ? void 0 : _e["themeContent"]["a:theme"]["a:themeElements"]["a:fmtScheme"]["a:bgFillStyleLst"];
        let sortblAry = [];
        Object.keys(bgFillLst).forEach((key) => {
          var _a2, _b2, _c2, _d2;
          let bgFillLstTyp = bgFillLst[key];
          if (key != "attrs") {
            if (bgFillLstTyp.constructor === Array) {
              for (var i = 0; i < bgFillLstTyp.length; i++) {
                let obj = {};
                obj[key] = bgFillLstTyp[i];
                obj["idex"] = (_a2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _a2["order"];
                obj["attrs"] = {
                  "order": (_b2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _b2["order"]
                };
                sortblAry.push(obj);
              }
            } else {
              let obj = {};
              obj[key] = bgFillLstTyp;
              obj["idex"] = (_c2 = bgFillLstTyp["attrs"]) == null ? void 0 : _c2["order"];
              obj["attrs"] = {
                "order": (_d2 = bgFillLstTyp["attrs"]) == null ? void 0 : _d2["order"]
              };
              sortblAry.push(obj);
            }
          }
        });
        let sortByOrder = sortblAry.slice(0);
        sortByOrder.sort(function(a, b) {
          return a.idex - b.idex;
        });
        let bgFillLstIdx = sortByOrder[trueIdx - 1];
        let bgFillTyp = this.getFillType(bgFillLstIdx);
        if (bgFillTyp == "SOLID_FILL") {
          let sldFill = bgFillLstIdx["a:solidFill"];
          let sldBgClr = this.getSolidFill(sldFill, clrMapOvr);
          bgcolor = "background: #" + sldBgClr + ";";
        } else if (bgFillTyp == "GRADIENT_FILL") {
          bgcolor = this.getBgGradientFill(bgFillLstIdx, phClr);
        } else {
          console.log(bgFillTyp);
        }
      }
    } else {
      bgPr = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:cSld", "p:bg", "p:bgPr"]);
      bgRef = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:cSld", "p:bg", "p:bgRef"]);
      let clrMapOvr;
      let sldClrMapOvr = getTextByPathList(slideLayoutContent, ["p:sldLayout", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
      if (sldClrMapOvr !== void 0) {
        clrMapOvr = sldClrMapOvr;
      } else {
        clrMapOvr = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:clrMap", "attrs"]);
      }
      if (bgPr !== void 0) {
        let bgFillTyp = this.getFillType(bgPr);
        if (bgFillTyp == "SOLID_FILL") {
          let sldFill = bgPr["a:solidFill"];
          let sldBgClr = this.getSolidFill(sldFill, clrMapOvr);
          bgcolor = "background: #" + sldBgClr + ";";
        } else if (bgFillTyp == "GRADIENT_FILL") {
          bgcolor = this.getBgGradientFill(bgPr);
        } else if (bgFillTyp == "PIC_FILL") {
          bgcolor = this.getBgPicFill(bgPr, "slideLayoutBg");
        }
      } else if (bgRef !== void 0) {
        console.log("slideLayoutContent: bgRef", bgRef);
        let phClr = this.getSolidFill(bgRef, clrMapOvr);
        let idx = Number((_f = bgRef["attrs"]) == null ? void 0 : _f["idx"]);
        if (idx == 0 || idx == 1e3) {
        } else if (idx > 0 && idx < 1e3) {
        } else if (idx > 1e3) {
          let trueIdx = idx - 1e3;
          let bgFillLst = (_g = this.resources) == null ? void 0 : _g["themeContent"]["a:theme"]["a:themeElements"]["a:fmtScheme"]["a:bgFillStyleLst"];
          let sortblAry = [];
          Object.keys(bgFillLst).forEach((key) => {
            var _a2, _b2, _c2, _d2;
            let bgFillLstTyp = bgFillLst[key];
            if (key != "attrs") {
              if (bgFillLstTyp.constructor === Array) {
                for (var i = 0; i < bgFillLstTyp.length; i++) {
                  let obj = {};
                  obj[key] = bgFillLstTyp[i];
                  obj["idex"] = (_a2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _a2["order"];
                  obj["attrs"] = {
                    "order": (_b2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _b2["order"]
                  };
                  sortblAry.push(obj);
                }
              } else {
                let obj = {};
                obj[key] = bgFillLstTyp;
                obj["idex"] = (_c2 = bgFillLstTyp["attrs"]) == null ? void 0 : _c2["order"];
                obj["attrs"] = {
                  "order": (_d2 = bgFillLstTyp["attrs"]) == null ? void 0 : _d2["order"]
                };
                sortblAry.push(obj);
              }
            }
          });
          let sortByOrder = sortblAry.slice(0);
          sortByOrder.sort(function(a, b) {
            return a.idex - b.idex;
          });
          let bgFillLstIdx = sortByOrder[trueIdx - 1];
          let bgFillTyp = this.getFillType(bgFillLstIdx);
          if (bgFillTyp == "SOLID_FILL") {
            let sldFill = bgFillLstIdx["a:solidFill"];
            let sldBgClr = this.getSolidFill(sldFill, clrMapOvr, phClr);
            bgcolor = "background: #" + sldBgClr + ";";
          } else if (bgFillTyp == "GRADIENT_FILL") {
            bgcolor = this.getBgGradientFill(bgFillLstIdx, phClr);
          } else if (bgFillTyp == "PIC_FILL") {
            bgcolor = this.getBgPicFill(bgFillLstIdx, "themeBg", phClr);
          } else {
            console.log(bgFillTyp);
          }
        }
      } else {
        bgPr = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:cSld", "p:bg", "p:bgPr"]);
        bgRef = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:cSld", "p:bg", "p:bgRef"]);
        let clrMap = getTextByPathList(slideMasterContent, ["p:sldMaster", "p:clrMap", "attrs"]);
        if (bgPr !== void 0) {
          let bgFillTyp = this.getFillType(bgPr);
          if (bgFillTyp == "SOLID_FILL") {
            let sldFill = bgPr["a:solidFill"];
            let sldBgClr = this.getSolidFill(sldFill, clrMap);
            bgcolor = "background: #" + sldBgClr + ";";
          } else if (bgFillTyp == "GRADIENT_FILL") {
            bgcolor = this.getBgGradientFill(bgPr);
          } else if (bgFillTyp == "PIC_FILL") {
            bgcolor = this.getBgPicFill(bgPr, "slideMasterBg");
          }
        } else if (bgRef !== void 0) {
          let phClr = this.getSolidFill(bgRef, clrMap);
          let idx = Number((_h = bgRef["attrs"]) == null ? void 0 : _h["idx"]);
          if (idx == 0 || idx == 1e3) {
          } else if (idx > 0 && idx < 1e3) {
          } else if (idx > 1e3) {
            let trueIdx = idx - 1e3;
            let bgFillLst = (_i = this.resources) == null ? void 0 : _i["themeContent"]["a:theme"]["a:themeElements"]["a:fmtScheme"]["a:bgFillStyleLst"];
            let sortblAry = [];
            Object.keys(bgFillLst).forEach((key) => {
              var _a2, _b2, _c2, _d2;
              let bgFillLstTyp = bgFillLst[key];
              if (key != "attrs") {
                if (bgFillLstTyp.constructor === Array) {
                  for (var i = 0; i < bgFillLstTyp.length; i++) {
                    let obj = {};
                    obj[key] = bgFillLstTyp[i];
                    obj["idex"] = (_a2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _a2["order"];
                    obj["attrs"] = {
                      "order": (_b2 = bgFillLstTyp[i]["attrs"]) == null ? void 0 : _b2["order"]
                    };
                    sortblAry.push(obj);
                  }
                } else {
                  let obj = {};
                  obj[key] = bgFillLstTyp;
                  obj["idex"] = (_c2 = bgFillLstTyp["attrs"]) == null ? void 0 : _c2["order"];
                  obj["attrs"] = {
                    "order": (_d2 = bgFillLstTyp["attrs"]) == null ? void 0 : _d2["order"]
                  };
                  sortblAry.push(obj);
                }
              }
            });
            let sortByOrder = sortblAry.slice(0);
            sortByOrder.sort(function(a, b) {
              return a.idex - b.idex;
            });
            let bgFillLstIdx = sortByOrder[trueIdx - 1];
            let bgFillTyp = this.getFillType(bgFillLstIdx);
            if (bgFillTyp == "SOLID_FILL") {
              let sldFill = bgFillLstIdx["a:solidFill"];
              let sldBgClr = this.getSolidFill(sldFill, clrMap, phClr);
              bgcolor = "background: #" + sldBgClr + ";";
            } else if (bgFillTyp == "GRADIENT_FILL") {
              bgcolor = this.getBgGradientFill(bgFillLstIdx, phClr);
            } else if (bgFillTyp == "PIC_FILL") {
              bgcolor = this.getBgPicFill(bgFillLstIdx, "themeBg", phClr);
            } else {
              console.log(bgFillTyp);
            }
          }
        }
      }
    }
    return bgcolor;
  }
  getBgGradientFill(bgPr, phClr) {
    var _a, _b;
    let bgcolor = "";
    const slideMasterContent = (_a = this.resources) == null ? void 0 : _a.slideMasterContent;
    if (bgPr !== void 0) {
      let grdFill = bgPr["a:gradFill"];
      let gsLst = grdFill["a:gsLst"]["a:gs"];
      let color_ary = [];
      let pos_ary = [];
      for (var i = 0; i < gsLst.length; i++) {
        let lo_tint;
        let lo_color = this.getSolidFill(gsLst[i], slideMasterContent["p:sldMaster"]["p:clrMap"]["attrs"], phClr);
        let pos = getTextByPathList(gsLst[i], ["attrs", "pos"]);
        if (pos !== void 0) {
          pos_ary[i] = pos / 1e3 + "%";
        } else {
          pos_ary[i] = "";
        }
        color_ary[i] = "#" + lo_color;
      }
      let lin = grdFill["a:lin"];
      let rot = 90;
      if (lin !== void 0) {
        rot = angleToDegrees((_b = lin["attrs"]) == null ? void 0 : _b["ang"]);
        rot = rot + 90;
      }
      bgcolor = "background: linear-gradient(" + rot + "deg,";
      for (var i = 0; i < gsLst.length; i++) {
        if (i == gsLst.length - 1) {
          bgcolor += color_ary[i] + " " + pos_ary[i] + ");";
        } else {
          bgcolor += color_ary[i] + " " + pos_ary[i] + ", ";
          ;
        }
      }
    } else {
      if (phClr !== void 0) {
        bgcolor = "background: #" + phClr + ";";
      }
    }
    return bgcolor;
  }
  getBgPicFill(bgPr, sorce, phClr) {
    return __async(this, null, function* () {
      var _a;
      let bgcolor;
      let picFillBase64 = yield this.getPicFill(sorce, bgPr["a:blipFill"]);
      let ordr = (_a = bgPr["attrs"]) == null ? void 0 : _a["order"];
      let aBlipNode = bgPr["a:blipFill"]["a:blip"];
      let duotone = getTextByPathList(aBlipNode, ["a:duotone"]);
      if (duotone !== void 0) {
        let clr_ary = [];
        Object.keys(duotone).forEach((clr_type) => {
          if (clr_type != "attrs") {
            let obj = {};
            obj[clr_type] = duotone[clr_type];
            clr_ary.push(this.getSolidFill(obj, void 0, phClr));
          }
        });
      }
      let aphaModFixNode = getTextByPathList(aBlipNode, ["a:alphaModFix", "attrs"]);
      let imgOpacity = "";
      if (aphaModFixNode !== void 0 && aphaModFixNode["amt"] !== void 0 && aphaModFixNode["amt"] != "") {
        let amt = parseInt(aphaModFixNode["amt"]) / 1e5;
        imgOpacity = "opacity:" + amt + ";";
      }
      let tileNode = getTextByPathList(bgPr, ["a:blipFill", "a:tile", "attrs"]);
      let prop_style = "";
      if (tileNode !== void 0 && tileNode["sx"] !== void 0) {
        let sx = parseInt(tileNode["sx"]) / 1e5;
        let sy = parseInt(tileNode["sy"]) / 1e5;
        let tx = parseInt(tileNode["tx"]) / 1e5;
        let ty = parseInt(tileNode["ty"]) / 1e5;
        let algn = tileNode["algn"];
        let flip = tileNode["flip"];
        prop_style += "background-repeat: round;";
      }
      let stretch = getTextByPathList(bgPr, ["a:blipFill", "a:stretch"]);
      if (stretch !== void 0) {
        let fillRect = getTextByPathList(stretch, ["a:fillRect"]);
        prop_style += "background-repeat: no-repeat;";
        prop_style += "background-position: center;";
        if (fillRect !== void 0) {
          prop_style += "background-size:  100% 100%;;";
        }
      }
      bgcolor = "background: url(" + picFillBase64 + ");  z-index: " + ordr + ";" + prop_style + imgOpacity;
      return bgcolor;
    });
  }
  // function hexToRgbNew(hex) {
  //     let arrBuff = new ArrayBuffer(4);
  //     let vw = new DataView(arrBuff);
  //     vw.setUint32(0, parseInt(hex, 16), false);
  //     let arrByte = new Uint8Array(arrBuff);
  //     return arrByte[1] + "," + arrByte[2] + "," + arrByte[3];
  // }
  getShapeFill(node, pNode, isSvgMode, source) {
    return __async(this, null, function* () {
      let fillType = this.getFillType(getTextByPathList(node, ["p:spPr"]));
      let fillColor;
      if (fillType == "NO_FILL") {
        return isSvgMode ? "none" : "";
      } else if (fillType == "SOLID_FILL") {
        let shpFill = node["p:spPr"]["a:solidFill"];
        fillColor = this.getSolidFill(shpFill);
      } else if (fillType == "GRADIENT_FILL") {
        let shpFill = node["p:spPr"]["a:gradFill"];
        fillColor = this.getGradientFill(shpFill);
      } else if (fillType == "PATTERN_FILL") {
        let shpFill = node["p:spPr"]["a:pattFill"];
        fillColor = this.getPatternFill(shpFill);
      } else if (fillType == "PIC_FILL") {
        let shpFill = node["p:spPr"]["a:blipFill"];
        fillColor = yield this.getPicFill(source, shpFill);
      }
      if (fillColor === void 0) {
        let clrName = getTextByPathList(node, ["p:style", "a:fillRef"]);
        let idx = parseInt(getTextByPathList(node, ["p:style", "a:fillRef", "attrs", "idx"]));
        if (idx == 0 || idx == 1e3) {
          return isSvgMode ? "none" : "";
        } else if (idx > 0 && idx < 1e3) {
        } else if (idx > 1e3) {
        }
        fillColor = this.getSolidFill(clrName);
      }
      if (fillColor === void 0) {
        let grpFill = getTextByPathList(node, ["p:spPr", "a:grpFill"]);
        if (grpFill !== void 0) {
          let grpShpFill = pNode["p:grpSpPr"];
          let spShpNode = { "p:spPr": grpShpFill };
          return yield this.getShapeFill(spShpNode, node, isSvgMode, source);
        } else if (fillType == "NO_FILL") {
          return isSvgMode ? "none" : "";
        }
      }
      if (fillColor !== void 0) {
        if (fillType == "GRADIENT_FILL") {
          if (isSvgMode) {
            return fillColor;
          } else {
            let colorAry = fillColor.color;
            let rot = fillColor.rot;
            let bgcolor = "background: linear-gradient(" + rot + "deg,";
            for (var i = 0; i < colorAry.length; i++) {
              if (i == colorAry.length - 1) {
                bgcolor += "#" + colorAry[i] + ");";
              } else {
                bgcolor += "#" + colorAry[i] + ", ";
              }
            }
            return bgcolor;
          }
        } else if (fillType == "PIC_FILL") {
          if (isSvgMode) {
            return fillColor;
          } else {
            return "background-image:url(" + fillColor + ");";
          }
        } else if (fillType == "PATTERN_FILL") {
          let bgPtrn = "", bgSize = "", bgPos = "";
          bgPtrn = fillColor[0];
          if (fillColor[1] !== null && fillColor[1] !== void 0 && fillColor[1] != "") {
            bgSize = " background-size:" + fillColor[1] + ";";
          }
          if (fillColor[2] !== null && fillColor[2] !== void 0 && fillColor[2] != "") {
            bgPos = " background-position:" + fillColor[2] + ";";
          }
          return "background: " + bgPtrn + ";" + bgSize + bgPos;
        } else {
          if (isSvgMode) {
            let color = _tinycolor22.default.call(void 0, fillColor);
            fillColor = color.toRgbString();
            return fillColor;
          } else {
            return "background-color: #" + fillColor + ";";
          }
        }
      } else {
        if (isSvgMode) {
          return "none";
        } else {
          return "background-color: inherit;";
        }
      }
    });
  }
  ///////////////////////Amir//////////////////////////////
  getFillType(node) {
    let fillType = "";
    if (node["a:noFill"] !== void 0) {
      fillType = "NO_FILL";
    }
    if (node["a:solidFill"] !== void 0) {
      fillType = "SOLID_FILL";
    }
    if (node["a:gradFill"] !== void 0) {
      fillType = "GRADIENT_FILL";
    }
    if (node["a:pattFill"] !== void 0) {
      fillType = "PATTERN_FILL";
    }
    if (node["a:blipFill"] !== void 0) {
      fillType = "PIC_FILL";
    }
    if (node["a:grpFill"] !== void 0) {
      fillType = "GROUP_FILL";
    }
    return fillType;
  }
  getGradientFill(node) {
    var _a;
    let gsLst = node["a:gsLst"]["a:gs"];
    let color_ary = [];
    let tint_ary = [];
    for (var i = 0; i < gsLst.length; i++) {
      let lo_tint;
      let lo_color = this.getSolidFill(gsLst[i]);
      color_ary[i] = lo_color;
    }
    let lin = node["a:lin"];
    let rot = 0;
    if (lin !== void 0) {
      rot = angleToDegrees((_a = lin["attrs"]) == null ? void 0 : _a["ang"]) + 90;
    }
    return {
      "color": color_ary,
      "rot": rot
    };
  }
  getPicFill(type, node) {
    return __async(this, null, function* () {
      var _a, _b;
      let img;
      let rId = (_a = node["a:blip"]["attrs"]) == null ? void 0 : _a["r:embed"];
      let imgPath;
      if (type == "slideBg" || type == "slide") {
        imgPath = getTextByPathList(this.resources, ["slideResObj", rId, "target"]);
      } else if (type == "slideLayoutBg") {
        imgPath = getTextByPathList(this.resources, ["layoutResObj", rId, "target"]);
      } else if (type == "slideMasterBg") {
        imgPath = getTextByPathList(this.resources, ["masterResObj", rId, "target"]);
      } else if (type == "themeBg") {
        imgPath = getTextByPathList(this.resources, ["themeResObj", rId, "target"]);
      } else if (type == "diagramBg") {
        imgPath = getTextByPathList(this.resources, ["diagramResObj", rId, "target"]);
      }
      if (imgPath === void 0) {
        return void 0;
      }
      img = getTextByPathList(this.resources, ["loaded-images", imgPath]);
      if (img === void 0) {
        imgPath = escapeHtml(imgPath);
        img = yield (_b = this.options.resourceReader) == null ? void 0 : _b.getImgBase64Data(imgPath);
        if (img) setTextByPathList(this.resources, ["loaded-images", imgPath], img);
      }
      return img;
    });
  }
  getPatternFill(node) {
    var _a;
    let fgColor, bgColor, prst = "";
    let bgClr = node["a:bgClr"];
    let fgClr = node["a:fgClr"];
    prst = (_a = node["attrs"]) == null ? void 0 : _a["prst"];
    fgColor = this.getSolidFill(fgClr);
    bgColor = this.getSolidFill(bgClr);
    let linear_gradient = getLinerGrandient(prst, bgColor, fgColor);
    return linear_gradient;
  }
  getSolidFill(node, clrMap, phClr) {
    var _a, _b;
    if (node === void 0) {
      return void 0;
    }
    let color = "";
    let clrNode;
    if (node["a:srgbClr"] !== void 0) {
      clrNode = node["a:srgbClr"];
      color = getTextByPathList(clrNode, ["attrs", "val"]);
    } else if (node["a:schemeClr"] !== void 0) {
      clrNode = node["a:schemeClr"];
      let schemeClr = getTextByPathList(clrNode, ["attrs", "val"]);
      color = this.getSchemeColorFromTheme("a:" + schemeClr, clrMap, phClr);
    } else if (node["a:scrgbClr"] !== void 0) {
      clrNode = node["a:scrgbClr"];
      let defBultColorVals = (_a = clrNode["attrs"]) != null ? _a : {};
      let red = defBultColorVals["r"].indexOf("%") != -1 ? defBultColorVals["r"].split("%").shift() : defBultColorVals["r"];
      let green = defBultColorVals["g"].indexOf("%") != -1 ? defBultColorVals["g"].split("%").shift() : defBultColorVals["g"];
      let blue = defBultColorVals["b"].indexOf("%") != -1 ? defBultColorVals["b"].split("%").shift() : defBultColorVals["b"];
      color = toHex(255 * (Number(red) / 100)) + toHex(255 * (Number(green) / 100)) + toHex(255 * (Number(blue) / 100));
    } else if (node["a:prstClr"] !== void 0) {
      clrNode = node["a:prstClr"];
      let prstClr = getTextByPathList(clrNode, ["attrs", "val"]);
      color = colorMap.get(prstClr);
    } else if (node["a:hslClr"] !== void 0) {
      clrNode = node["a:hslClr"];
      let defBultColorVals = (_b = clrNode["attrs"]) != null ? _b : {};
      let hue = Number(defBultColorVals["hue"]) / 1e5;
      let sat = Number(defBultColorVals["sat"].indexOf("%") != -1 ? defBultColorVals["sat"].split("%").shift() : defBultColorVals["sat"]) / 100;
      let lum = Number(defBultColorVals["lum"].indexOf("%") != -1 ? defBultColorVals["lum"].split("%").shift() : defBultColorVals["lum"]) / 100;
      let hsl2rgb = hslToRgb(hue, sat, lum);
      color = toHex(hsl2rgb.r) + toHex(hsl2rgb.g) + toHex(hsl2rgb.b);
    } else if (node["a:sysClr"] !== void 0) {
      clrNode = node["a:sysClr"];
      let sysClr = getTextByPathList(clrNode, ["attrs", "lastClr"]);
      if (sysClr !== void 0) {
        color = sysClr;
      }
    }
    let isAlpha = false;
    let alpha = parseInt(getTextByPathList(clrNode, ["a:alpha", "attrs", "val"])) / 1e5;
    if (!isNaN(alpha)) {
      let al_color = _tinycolor22.default.call(void 0, color);
      al_color.setAlpha(alpha);
      color = al_color.toHex8();
      isAlpha = true;
    }
    let hueMod = parseInt(getTextByPathList(clrNode, ["a:hueMod", "attrs", "val"])) / 1e5;
    if (!isNaN(hueMod)) {
      color = applyHueMod(color, hueMod, isAlpha);
    }
    let lumMod = parseInt(getTextByPathList(clrNode, ["a:lumMod", "attrs", "val"])) / 1e5;
    if (!isNaN(lumMod)) {
      color = applyLumMod(color, lumMod, isAlpha);
    }
    let lumOff = parseInt(getTextByPathList(clrNode, ["a:lumOff", "attrs", "val"])) / 1e5;
    if (!isNaN(lumOff)) {
      color = applyLumOff(color, lumOff, isAlpha);
    }
    let satMod = parseInt(getTextByPathList(clrNode, ["a:satMod", "attrs", "val"])) / 1e5;
    if (!isNaN(satMod)) {
      color = applySatMod(color, satMod, isAlpha);
    }
    let shade = parseInt(getTextByPathList(clrNode, ["a:shade", "attrs", "val"])) / 1e5;
    if (!isNaN(shade)) {
      color = applyShade(color, shade, isAlpha);
    }
    let tint = parseInt(getTextByPathList(clrNode, ["a:tint", "attrs", "val"])) / 1e5;
    if (!isNaN(tint)) {
      color = applyTint(color, tint, isAlpha);
    }
    return color;
  }
  getSchemeColorFromTheme(schemeClr, clrMap, phClr) {
    var _a, _b, _c, _d;
    let slideLayoutClrOvride;
    if (clrMap !== void 0) {
      slideLayoutClrOvride = clrMap;
    } else {
      let sldClrMapOvr = getTextByPathList((_a = this.resources) == null ? void 0 : _a.slideContent, ["p:sld", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
      if (sldClrMapOvr !== void 0) {
        slideLayoutClrOvride = sldClrMapOvr;
      } else {
        let sldClrMapOvr2 = getTextByPathList((_b = this.resources) == null ? void 0 : _b.slideLayoutContent, ["p:sldLayout", "p:clrMapOvr", "a:overrideClrMapping", "attrs"]);
        if (sldClrMapOvr2 !== void 0) {
          slideLayoutClrOvride = sldClrMapOvr2;
        } else {
          slideLayoutClrOvride = getTextByPathList((_c = this.resources) == null ? void 0 : _c.slideMasterContent, ["p:sldMaster", "p:clrMap", "attrs"]);
        }
      }
    }
    let schmClrName = schemeClr.substr(2);
    let color;
    if (schmClrName == "phClr" && phClr !== void 0) {
      color = phClr;
    } else {
      if (slideLayoutClrOvride !== void 0) {
        switch (schmClrName) {
          case "tx1":
          case "tx2":
          case "bg1":
          case "bg2":
            schemeClr = "a:" + slideLayoutClrOvride[schmClrName];
            break;
        }
      } else {
        switch (schmClrName) {
          case "tx1":
            schemeClr = "a:dk1";
            break;
          case "tx2":
            schemeClr = "a:dk2";
            break;
          case "bg1":
            schemeClr = "a:lt1";
            break;
          case "bg2":
            schemeClr = "a:lt2";
            break;
        }
      }
      let refNode = getTextByPathList((_d = this.resources) == null ? void 0 : _d.themeContent, ["a:theme", "a:themeElements", "a:clrScheme", schemeClr]);
      color = getTextByPathList(refNode, ["a:srgbClr", "attrs", "val"]);
      if (color === void 0 && refNode !== void 0) {
        color = getTextByPathList(refNode, ["a:sysClr", "attrs", "lastClr"]);
      }
    }
    return color;
  }
  extractChartData(serNode) {
    let dataMat = new Array();
    if (serNode === void 0) {
      return dataMat;
    }
    if (serNode["c:xVal"] !== void 0) {
      let dataRow = new Array();
      eachElement(serNode["c:xVal"]["c:numRef"]["c:numCache"]["c:pt"], (innerNode) => {
        dataRow.push(parseFloat(innerNode["c:v"]));
        return "";
      });
      dataMat.push(dataRow);
      dataRow = new Array();
      eachElement(serNode["c:yVal"]["c:numRef"]["c:numCache"]["c:pt"], (innerNode) => {
        dataRow.push(parseFloat(innerNode["c:v"]));
        return "";
      });
      dataMat.push(dataRow);
    } else {
      eachElement(serNode, (innerNode, index) => {
        let dataRow = new Array();
        let colName = getTextByPathList(innerNode, ["c:tx", "c:strRef", "c:strCache", "c:pt", "c:v"]) || index;
        let rowNames = {};
        if (getTextByPathList(innerNode, ["c:cat", "c:strRef", "c:strCache", "c:pt"]) !== void 0) {
          eachElement(innerNode["c:cat"]["c:strRef"]["c:strCache"]["c:pt"], (innerNode2) => {
            var _a;
            rowNames[(_a = innerNode2["attrs"]) == null ? void 0 : _a["idx"]] = innerNode2["c:v"];
            return "";
          });
        } else if (getTextByPathList(innerNode, ["c:cat", "c:numRef", "c:numCache", "c:pt"]) !== void 0) {
          eachElement(innerNode["c:cat"]["c:numRef"]["c:numCache"]["c:pt"], (innerNode2) => {
            var _a;
            rowNames[(_a = innerNode2["attrs"]) == null ? void 0 : _a["idx"]] = innerNode2["c:v"];
            return "";
          });
        }
        if (getTextByPathList(innerNode, ["c:val", "c:numRef", "c:numCache", "c:pt"]) !== void 0) {
          eachElement(innerNode["c:val"]["c:numRef"]["c:numCache"]["c:pt"], (innerNode2) => {
            var _a;
            dataRow.push({ x: (_a = innerNode2["attrs"]) == null ? void 0 : _a["idx"], y: parseFloat(innerNode2["c:v"]) });
            return "";
          });
        }
        dataMat.push({ key: colName, values: dataRow, xlabels: rowNames });
        return "";
      });
    }
    return dataMat;
  }
  getSvgImagePattern(node, fill, shpId) {
    var _a, _b;
    let pic_dim = getBase64ImageDimensions(fill);
    let width = (_a = pic_dim == null ? void 0 : pic_dim[0]) != null ? _a : 0;
    let height = (_b = pic_dim == null ? void 0 : pic_dim[1]) != null ? _b : 0;
    let blipFillNode = node["p:spPr"]["a:blipFill"];
    let tileNode = getTextByPathList(blipFillNode, ["a:tile", "attrs"]);
    let sx, sy;
    if (tileNode !== void 0 && tileNode["sx"] !== void 0) {
      sx = parseInt(tileNode["sx"]) / 1e5 * width;
      sy = parseInt(tileNode["sy"]) / 1e5 * height;
    }
    let blipNode = node["p:spPr"]["a:blipFill"]["a:blip"];
    let tialphaModFixNode = getTextByPathList(blipNode, ["a:alphaModFix", "attrs"]);
    let imgOpacity = "";
    if (tialphaModFixNode !== void 0 && tialphaModFixNode["amt"] !== void 0 && tialphaModFixNode["amt"] != "") {
      let amt = parseInt(tialphaModFixNode["amt"]) / 1e5;
      let opacity = amt;
      let imgOpacity2 = "opacity='" + opacity + "'";
    }
    let ptrn;
    if (sx !== void 0 && sx != 0) {
      ptrn = '<pattern id="imgPtrn_' + shpId + '" x="0" y="0"  width="' + sx + '" height="' + sy + '" patternUnits="userSpaceOnUse">';
    } else {
      ptrn = '<pattern id="imgPtrn_' + shpId + '"  patternContentUnits="objectBoundingBox"  width="1" height="1">';
    }
    let duotoneNode = getTextByPathList(blipNode, ["a:duotone"]);
    let fillterNode = "";
    let filterUrl = "";
    if (duotoneNode !== void 0) {
      let clr_ary = [];
      Object.keys(duotoneNode).forEach((clr_type) => {
        if (clr_type != "attrs") {
          let obj = {};
          obj[clr_type] = duotoneNode[clr_type];
          let hexClr = this.getSolidFill(obj);
          let color = _tinycolor22.default.call(void 0, "#" + hexClr);
          clr_ary.push(color.toRgb());
        }
      });
      if (clr_ary.length == 2) {
        fillterNode = '<filter id="svg_image_duotone"> <feColorMatrix type="matrix" values=".33 .33 .33 0 0.33 .33 .33 0 0.33 .33 .33 0 00 0 0 1 0"></feColorMatrix><feComponentTransfer color-interpolation-filters="sRGB"><feFuncR type="table" tableValues="' + clr_ary[0].r / 255 + " " + clr_ary[1].r / 255 + '"></feFuncR><feFuncG type="table" tableValues="' + clr_ary[0].g / 255 + " " + clr_ary[1].g / 255 + '"></feFuncG><feFuncB type="table" tableValues="' + clr_ary[0].b / 255 + " " + clr_ary[1].b / 255 + '"></feFuncB></feComponentTransfer> </filter>';
      }
      filterUrl = 'filter="url(#svg_image_duotone)"';
      ptrn += fillterNode;
    }
    fill = escapeHtml(fill);
    if (sx !== void 0 && sx != 0) {
      ptrn += '<image  xlink:href="' + fill + '" x="0" y="0" width="' + sx + '" height="' + sy + '" ' + imgOpacity + " " + filterUrl + "></image>";
    } else {
      ptrn += '<image  xlink:href="' + fill + '" preserveAspectRatio="none" width="1" height="1" ' + imgOpacity + " " + filterUrl + "></image>";
    }
    ptrn += "</pattern>";
    return ptrn;
  }
  processMsgQueue() {
    for (var i = 0; i < this.MsgQueue.length; i++) {
      this.processSingleMsg(this.MsgQueue[i].data);
    }
  }
  processSingleMsg(d) {
    var chartID = d.chartID;
    var chartType = d.chartType;
    var chartData = d.chartData;
    var data = [];
    var chart = null;
    const nv = window.nv;
    const d32 = window.d3;
    switch (chartType) {
      case "lineChart":
        data = chartData;
        chart = nv.models.lineChart().useInteractiveGuideline(true);
        chart.xAxis.tickFormat(function(d2) {
          return chartData[0].xlabels[d2] || d2;
        });
        break;
      case "barChart":
        data = chartData;
        chart = nv.models.multiBarChart();
        chart.xAxis.tickFormat(function(d2) {
          return chartData[0].xlabels[d2] || d2;
        });
        break;
      case "pieChart":
      case "pie3DChart":
        if (chartData.length > 0) {
          data = chartData[0].values;
        }
        chart = nv.models.pieChart();
        break;
      case "areaChart":
        data = chartData;
        chart = nv.models.stackedAreaChart().clipEdge(true).useInteractiveGuideline(true);
        chart.xAxis.tickFormat(function(d2) {
          return chartData[0].xlabels[d2] || d2;
        });
        break;
      case "scatterChart":
        for (var i = 0; i < chartData.length; i++) {
          var arr = [];
          for (var j = 0; j < chartData[i].length; j++) {
            arr.push({ x: j, y: chartData[i][j] });
          }
          data.push({ key: "data" + (i + 1), values: arr });
        }
        chart = nv.models.scatterChart().showDistX(true).showDistY(true).color(d32.scale.category10().range());
        chart.xAxis.axisLabel("X").tickFormat(d32.format(".02f"));
        chart.yAxis.axisLabel("Y").tickFormat(d32.format(".02f"));
        break;
      default:
    }
    if (chart !== null) {
      d32.select("#" + chartID).append("svg").datum(data).transition().duration(500).call(chart);
      nv.utils.windowResize(chart.update);
    }
  }
  // d3 and nv d3 are initialized after the PPTX is rendered
  // so we need to call this function after the PPTX is rendered
  postRender() {
    if (this.postRenderDone) return;
    this.processMsgQueue();
    this.postRenderDone = true;
  }
};

// src/helpers/pptx/ResourceReader.ts
var import_jszip = __toESM(require_lib3(), 1);

// src/helpers/pptx/utils/xml.ts
var _fastxmlparser = require('fast-xml-parser');
var xmlParser = new (0, _fastxmlparser.XMLParser)({
  ignoreAttributes: false,
  attributeNamePrefix: "",
  attributesGroupName: "attrs",
  ignorePiTags: true,
  trimValues: false,
  cdataPropName: "@CDATA"
});
var parse = (xml) => {
  if (!xml) {
    return null;
  }
  const result = xmlParser.parse(xml);
  return result;
};

// src/helpers/pptx/ResourceReader.ts
var ResourceReader = class {
  constructor(file) {
    this.zip = null;
    this.loadingPromise = null;
    this.loadingPromise = this.load(file);
  }
  load(file) {
    return __async(this, null, function* () {
      this.zip = yield import_jszip.default.loadAsync(file);
      this.loadingPromise = null;
    });
  }
  getFile(filename, extension) {
    return __async(this, null, function* () {
      var _a, _b;
      if (this.loadingPromise) {
        yield this.loadingPromise;
      }
      return yield (_b = (_a = this.zip) == null ? void 0 : _a.file(filename)) == null ? void 0 : _b.async(extension);
    });
  }
  readXmlFile(filename) {
    return __async(this, null, function* () {
      try {
        const fileContent = yield this.getFile(filename, "text");
        if (fileContent) {
          return parse(fileContent);
        }
      } catch (e) {
        console.log("error readXmlFile: the file '", filename, "' not exit");
      }
      return null;
    });
  }
  getImgBase64Data(filename) {
    return __async(this, null, function* () {
      const imgExt = filename.split(".").pop();
      if (imgExt == "xml") {
        return void 0;
      }
      const fileBase64 = yield this.getFile(filename, "base64");
      const imgMimeType = getMimeType(imgExt);
      if (fileBase64) return "data:" + imgMimeType + ";base64," + fileBase64;
      return void 0;
    });
  }
};

// src/helpers/pptx/PPTX.ts
var PPTX = class {
  constructor(options) {
    this.options = {
      processFullTheme: true,
      incSlide: {
        width: 0,
        height: 0
      },
      mediaProcess: false,
      slideFactor: 96 / 914400,
      fontSizeFactor: 4 / 3.2
    };
    this.resourceReader = null;
    this.tableStyles = null;
    this.basicInfo = null;
    // html result of convert
    this.htmlResultArray = [];
    this.isDone = false;
    this.postRenderDone = false;
    this.convertPromise = null;
    this.styleTable = new StyleTable();
    this.slides = [];
    _2.default.assign(this.options, options);
    this.convertPromise = this.convert();
  }
  convert() {
    return __async(this, null, function* () {
      const url = this.options.url;
      let file = this.options.file;
      if (url) {
        try {
          const response = yield fetch(url);
          file = yield response.arrayBuffer();
        } catch (e) {
        }
      }
      if (file) {
        this.resourceReader = new ResourceReader(file);
        return yield this.convertPPTX();
      }
    });
  }
  getThumbnail() {
    return __async(this, null, function* () {
      var _a;
      return yield (_a = this.resourceReader) == null ? void 0 : _a.getFile("docProps/thumbnail.jpeg", "base64");
    });
  }
  convertPPTX() {
    return __async(this, null, function* () {
      const post_ary = [];
      const [thubmnail, basicInfo, tableStyles] = yield Promise.all([
        this.getThumbnail(),
        this.getBasicInfo(),
        this.readXmlFile("ppt/tableStyles.xml")
      ]);
      this.basicInfo = basicInfo;
      this.tableStyles = tableStyles;
      let numOfSlides = basicInfo["slides"].length;
      for (var i = 0; i < numOfSlides; i++) {
        let fileName = basicInfo["slides"][i];
        let filename_no_path = "";
        let filename_no_path_ary = [];
        if (fileName.indexOf("/") != -1) {
          filename_no_path_ary = fileName.split("/");
          filename_no_path = filename_no_path_ary.pop();
        } else {
          filename_no_path = fileName;
        }
        let filename_no_path_no_ext = "";
        if (filename_no_path.indexOf(".") != -1) {
          let filename_no_path_no_ext_ary = filename_no_path.split(".");
          let slide_ext = filename_no_path_no_ext_ary.pop();
          filename_no_path_no_ext = filename_no_path_no_ext_ary.join(".");
        }
        let slide_number = 1;
        if (filename_no_path_no_ext != "" && filename_no_path.indexOf("slide") != -1) {
          slide_number = Number(filename_no_path_no_ext.substr(5));
        }
        const slide = new Slide({
          fileName,
          index: i,
          processFullTheme: this.options.processFullTheme,
          mediaProcess: this.options.mediaProcess,
          resourceReader: this.resourceReader,
          basicInfo: this.basicInfo,
          container: this.options.container,
          tableStyles: this.tableStyles,
          styleTable: this.styleTable,
          slideFactor: this.options.slideFactor,
          fontSizeFactor: this.options.fontSizeFactor
        });
        this.slides.push(slide);
        let slideHtml = yield slide.processSingleSlide();
        post_ary.push({
          "type": "slide",
          "data": slideHtml,
          "slide_num": slide_number,
          "file_name": filename_no_path_no_ext
        });
      }
      post_ary.sort(function(a, b) {
        return a.slide_num - b.slide_num;
      });
      post_ary.push({
        "type": "globalCSS",
        "data": this.styleTable.genGlobalCSS()
      });
      this.htmlResultArray = post_ary;
      return post_ary;
    });
  }
  readXmlFile(filename) {
    return __async(this, null, function* () {
      var _a;
      return (_a = this.resourceReader) == null ? void 0 : _a.readXmlFile(filename);
    });
  }
  getBasicInfo() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      const [ContentTypesData, app, presentation] = yield Promise.all([
        this.readXmlFile("[Content_Types].xml"),
        this.readXmlFile("docProps/app.xml"),
        this.readXmlFile("ppt/presentation.xml")
      ]);
      let subObj = ContentTypesData["Types"]["Override"];
      let slidesLocArray = [];
      let slideLayoutsLocArray = [];
      for (var i = 0; i < subObj.length; i++) {
        switch ((_a = subObj[i]["attrs"]) == null ? void 0 : _a["ContentType"]) {
          case "application/vnd.openxmlformats-officedocument.presentationml.slide+xml":
            slidesLocArray.push((_b = subObj[i]["attrs"]) == null ? void 0 : _b["PartName"].substr(1));
            break;
          case "application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml":
            slideLayoutsLocArray.push((_c = subObj[i]["attrs"]) == null ? void 0 : _c["PartName"].substr(1));
            break;
          default:
        }
      }
      let sldSzAttrs = presentation["p:presentation"]["p:sldSz"]["attrs"];
      let sldSzWidth = parseInt(sldSzAttrs["cx"]);
      let sldSzHeight = parseInt(sldSzAttrs["cy"]);
      let sldSzType = sldSzAttrs["type"];
      return {
        slides: slidesLocArray,
        slideLayouts: slideLayoutsLocArray,
        defaultTextStyle: presentation["p:presentation"]["p:defaultTextStyle"],
        width: sldSzWidth * this.options.slideFactor + (((_d = this.options.incSlide) == null ? void 0 : _d.width) || 0),
        // * scaleX;//parseInt(sldSzAttrs["cx"]) * 96 / 914400;
        height: sldSzHeight * this.options.slideFactor + (((_e = this.options.incSlide) == null ? void 0 : _e.height) || 0)
        // * scaleY;//parseInt(sldSzAttrs["cy"]) * 96 / 914400;
      };
    });
  }
  /*
  shapePolygon(sidesNum) {
      let sides  = sidesNum;
      let radius = 100;
      let angle  = 2 * Math.PI / sides;
      let points = []; 
      
      for (var i = 0; i < sides; i++) {
          points.push(radius + radius * Math.sin(i * angle));
          points.push(radius - radius * Math.cos(i * angle));
      }
      
      return points;
  }
  */
  render(container) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (container) {
        this.options.container = container;
      }
      if (!this.options.container) {
        throw new Error("Container is not set");
      }
      yield this.convertPromise;
      let htmlString = "";
      const result = this.htmlResultArray;
      for (var i = 0; i < result.length; i++) {
        switch (result[i]["type"]) {
          case "slide":
            htmlString += result[i]["data"];
            break;
          case "pptx-thumb":
            break;
          case "globalCSS":
            htmlString += "<style>" + result[i]["data"] + "</style>";
            break;
          default:
        }
      }
      this.options.container.style.height = ((_b = (_a = this.basicInfo) == null ? void 0 : _a.height) != null ? _b : 0) * ((_d = (_c = this.basicInfo) == null ? void 0 : _c.slides.length) != null ? _d : 0) + "px";
      this.options.container.innerHTML = htmlString;
      this.postRender();
    });
  }
  setNumericBullets(elem) {
    var _a, _b;
    let prgrphs_arry = elem;
    for (var i = 0; i < prgrphs_arry.length; i++) {
      let buSpan = prgrphs_arry[i].querySelectorAll(".numeric-bullet-style");
      if (buSpan.length > 0) {
        let prevBultTyp = "";
        let prevBultLvl = "";
        let buletIndex = 0;
        let tmpArry = new Array();
        let tmpArryIndx = 0;
        let buletTypSrry = new Array();
        for (var j = 0; j < buSpan.length; j++) {
          let bult_typ = (_a = buSpan[j].getAttribute("data-bulltname")) != null ? _a : "";
          let bult_lvl = (_b = buSpan[j].getAttribute("data-bulltlvl")) != null ? _b : "";
          if (buletIndex == 0) {
            prevBultTyp = bult_typ;
            prevBultLvl = bult_lvl;
            tmpArry[tmpArryIndx] = buletIndex;
            buletTypSrry[tmpArryIndx] = bult_typ;
            buletIndex++;
          } else {
            if (bult_typ == prevBultTyp && bult_lvl == prevBultLvl) {
              prevBultTyp = bult_typ;
              prevBultLvl = bult_lvl;
              buletIndex++;
              tmpArry[tmpArryIndx] = buletIndex;
              buletTypSrry[tmpArryIndx] = bult_typ;
            } else if (bult_typ != prevBultTyp && bult_lvl == prevBultLvl) {
              prevBultTyp = bult_typ;
              prevBultLvl = bult_lvl;
              tmpArryIndx++;
              tmpArry[tmpArryIndx] = buletIndex;
              buletTypSrry[tmpArryIndx] = bult_typ;
              buletIndex = 1;
            } else if (bult_typ != prevBultTyp && Number(bult_lvl) > Number(prevBultLvl)) {
              prevBultTyp = bult_typ;
              prevBultLvl = bult_lvl;
              tmpArryIndx++;
              tmpArry[tmpArryIndx] = buletIndex;
              buletTypSrry[tmpArryIndx] = bult_typ;
              buletIndex = 1;
            } else if (bult_typ != prevBultTyp && Number(bult_lvl) < Number(prevBultLvl)) {
              prevBultTyp = bult_typ;
              prevBultLvl = bult_lvl;
              tmpArryIndx--;
              buletIndex = tmpArry[tmpArryIndx] + 1;
            }
          }
          let numIdx = getNumTypeNum(buletTypSrry[tmpArryIndx], buletIndex);
          buSpan[j].innerHTML = numIdx;
        }
      }
    }
  }
  // d3 and nv d3 are initialized after the PPTX is rendered
  // so we need to call this function after the PPTX is rendered
  postRender() {
    if (this.postRenderDone) return;
    this.slides.forEach((slide) => {
      slide.postRender();
    });
    this.setNumericBullets(document.querySelectorAll(".block"));
    this.setNumericBullets(document.querySelectorAll("table td"));
    this.postRenderDone = true;
  }
};

// src/helpers/pptx/usePPTX.tsx
var usePPTX = (options) => {
  var _a;
  const pptxRef = _react.useRef.call(void 0, null);
  const loadingRef = _react.useRef.call(void 0, false);
  _react.useEffect.call(void 0, () => {
    pptxRef.current = new PPTX({
      file: options.file,
      url: options.url
    });
  }, []);
  _react.useEffect.call(void 0, () => {
    var _a2, _b, _c;
    if (!((_a2 = options.containerRef) == null ? void 0 : _a2.current) || loadingRef.current) {
      return;
    }
    (_c = pptxRef.current) == null ? void 0 : _c.render((_b = options.containerRef) == null ? void 0 : _b.current).then(() => {
      loadingRef.current = true;
    });
  }, [(_a = options.containerRef) == null ? void 0 : _a.current]);
};

// src/components/PPTXPreview.tsx

var PPTXPreview = ({ fileUrl }) => {
  const containerRef = _react.useRef.call(void 0, null);
  usePPTX({ url: fileUrl, containerRef });
  return _jsxruntime.jsx.call(void 0, "div", { ref: containerRef });
};
var PPTXPreview_default = PPTXPreview;

// src/Viewer.tsx

var FilePreview = ({ fileUrl, fileType }) => {
  const renderPreview = () => {
    switch (fileType) {
      case "pdf":
        return _jsxruntime.jsx.call(void 0, PDFPreview_default, { fileUrl });
      case "xlsx":
        return _jsxruntime.jsx.call(void 0, XLSXPreview_default, { fileUrl });
      case "docx":
        return _jsxruntime.jsx.call(void 0, DOCXPreview_default, { fileUrl });
      case "pptx":
        return _jsxruntime.jsx.call(void 0, PPTXPreview_default, { fileUrl });
      default:
        return _jsxruntime.jsx.call(void 0, "div", { children: "Unsupported file type" });
    }
  };
  return _jsxruntime.jsx.call(void 0, "div", { className: "file-preview-container", children: renderPreview() });
};
var Viewer_default = FilePreview;

// src/index.ts
var src_default = Viewer_default;






exports.DOCXPreview = DOCXPreview_default; exports.PDFPreview = PDFPreview_default; exports.PPTXPreview = PPTXPreview_default; exports.XLSXPreview = XLSXPreview_default; exports.default = src_default;
